{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Hitchhiker's Guide to Developing","text":""},{"location":"#dont-panic","title":"Don't Panic","text":"<p>A comprehensive, structured journey through systems engineering, embedded development, and infrastructure automation.</p> <p>View on GitHub Read The Journey</p>"},{"location":"#what-is-this","title":"What is This?","text":"<p>This is a comprehensive repository that contains multiple focused research areas. Each domain represents a distinct area of study with its own documentation and experiments.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>The Journey - Philosophy and approach</li> <li>Roadmap - Learning progression</li> <li>Architecture - Repository structure</li> <li>Future Domains - Planned research areas</li> <li>Bibliography - References and resources</li> </ul>"},{"location":"#focus-areas","title":"Focus Areas","text":"<ul> <li>Embedded Linux development and board bring-up</li> <li>Yocto Project and build systems</li> <li>Linux kernel development and debugging</li> <li>DevOps infrastructure automation</li> <li>Hardware platform integration</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code># Clone with all submodules\ngit clone --recursive https://github.com/Jofralso/hitchhikers-guide-to-developing.git\ncd hitchhikers-guide-to-developing\n\n# Or initialize specific submodule\ngit submodule update --init &lt;submodule-name&gt;\n</code></pre>"},{"location":"#current-status","title":"Current Status","text":"<p>Phase: Initial setup and planning</p> <p>Next Steps:</p> <ul> <li>[DONE] Complete BeaglePlay embedded Linux labs</li> <li>[TODO] Begin domain-specific documentation</li> <li>[TODO] Set up development environment</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If this guide has helped you on your journey, consider supporting its continued development:</p> <p></p> <p>Remember: Don't Panic, Always Know Where Your Documentation Is</p> <p>Made with \u2615 and a profound appreciation for towels</p>"},{"location":"ARCHITECTURE/","title":"Repository Architecture","text":""},{"location":"ARCHITECTURE/#design-philosophy","title":"Design Philosophy","text":"<p>This repository uses a modular architecture where each engineering domain is organized in dedicated directories. This provides:</p> <ul> <li>Isolation: Clear separation between different domains</li> <li>Scalability: Add new areas without affecting existing work</li> <li>Simplicity: All content in one repository</li> <li>Organization: Clear separation of concerns</li> </ul>"},{"location":"ARCHITECTURE/#structure","title":"Structure","text":"<pre><code>hitchhikers-guide-to-developing/\n\u251c\u2500\u2500 README.md              # Project overview and navigation\n\u251c\u2500\u2500 ARCHITECTURE.md        # This file - structural documentation\n\u251c\u2500\u2500 ROADMAP.md            # Learning progression and milestones\n\u251c\u2500\u2500 BIBLIOGRAPHY.md       # Centralized reference collection\n\u251c\u2500\u2500 LICENSE               # MIT License\n\u251c\u2500\u2500 .gitmodules           # Not used (kept for documentation)\n\u251c\u2500\u2500 .gitignore            # Global ignore patterns\n\u251c\u2500\u2500 docs/                 # Documentation and labs\n\u251c\u2500\u2500 artifacts/            # Shared resources\n\u2514\u2500\u2500 tests/                # Test infrastructure\n</code></pre>"},{"location":"ARCHITECTURE/#documentation-directory","title":"Documentation Directory","text":"<pre><code>docs/\n\u251c\u2500\u2500 methodologies/\n\u251c\u2500\u2500 standards/\n\u2514\u2500\u2500 templates/\n</code></pre>"},{"location":"ARCHITECTURE/#artifacts-directory","title":"Artifacts Directory","text":"<pre><code>artifacts/\n\u251c\u2500\u2500 configurations/\n\u251c\u2500\u2500 scripts/\n\u2514\u2500\u2500 datasets/\n</code></pre>"},{"location":"ARCHITECTURE/#repository-structure","title":"Repository Structure","text":"<p>The repository is organized into clear sections for documentation and training content.</p>"},{"location":"ARCHITECTURE/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Repository names: lowercase with hyphens</li> <li>File names: lowercase with hyphens for markdown</li> <li>Directory names: lowercase with hyphens</li> </ul>"},{"location":"ARCHITECTURE/#version-control","title":"Version Control","text":""},{"location":"ARCHITECTURE/#branches","title":"Branches","text":"<ul> <li><code>main</code>: Stable, documented work</li> <li><code>develop</code>: Active development</li> <li><code>feature/*</code>: Specific features</li> <li><code>fix/*</code>: Bug fixes</li> </ul>"},{"location":"ARCHITECTURE/#commits","title":"Commits","text":"<p>Format: <code>type(scope): brief description</code></p> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p>"},{"location":"ARCHITECTURE/#maintenance","title":"Maintenance","text":"<ul> <li>Regular updates to documentation and labs</li> <li>Periodic documentation reviews</li> <li>Milestone tagging</li> </ul> <p>Last Updated: November 2025</p>"},{"location":"BEAGLEPLAY_SETUP/","title":"BeaglePlay Hardware Setup Guide","text":"<p>This guide covers the initial setup and configuration of the BeaglePlay development board.</p>"},{"location":"BEAGLEPLAY_SETUP/#hardware-overview","title":"Hardware Overview","text":""},{"location":"BEAGLEPLAY_SETUP/#beagleplay-specifications","title":"BeaglePlay Specifications","text":"<ul> <li>SoC: Texas Instruments AM6254</li> <li>Quad-core ARM Cortex-A53 @ 1.4GHz (64-bit)</li> <li>Arm Cortex-M4F MCU for real-time operations</li> <li>Memory: 2GB DDR4 RAM</li> <li>Storage: </li> <li>16GB eMMC flash (on-board)</li> <li>microSD card slot (up to 128GB)</li> <li>Wireless:</li> <li>WiFi 5 (802.11ac) 2.4/5GHz</li> <li>Bluetooth 5.2 LE</li> <li>SubGHz radio (868/915 MHz CC1352)</li> <li>Wired Networking: Gigabit Ethernet (10/100/1000 Mbps)</li> <li>USB:</li> <li>1x USB Type-C (power, data, console)</li> <li>1x USB 2.0 Type-A host port</li> <li>Expansion:</li> <li>mikroBUS connector</li> <li>Grove connector</li> <li>QWIIC/STEMMA QT connector (I2C)</li> <li>2x 46-pin headers (GPIOs, SPI, I2C, UART, PWM, etc.)</li> <li>Debug: </li> <li>UART console via USB-C</li> <li>JTAG/SWD interface</li> <li>Power: USB Type-C (5V, minimum 3A recommended)</li> <li>Dimensions: 86.36mm x 54.61mm</li> </ul>"},{"location":"BEAGLEPLAY_SETUP/#comparison-to-other-platforms","title":"Comparison to Other Platforms","text":"Feature BeaglePlay Raspberry Pi 4B Raspberry Pi 5 CPU ARM Cortex-A53 (4-core) ARM Cortex-A72 (4-core) ARM Cortex-A76 (4-core) Clock 1.4 GHz 1.5 GHz 2.4 GHz RAM 2 GB DDR4 1/2/4/8 GB 4/8 GB SubGHz \u2705 Yes (CC1352) \u274c No \u274c No Real-time MCU \u2705 Yes (M4F) \u274c No \u274c No mikroBUS \u2705 Yes \u274c No \u274c No Price ~$99 ~$35-75 ~$60-80 <p>Why BeaglePlay for Embedded Linux? - Industrial-focused design with expansion connectors - Real-time MCU for deterministic tasks - SubGHz radio for IoT/LPWAN applications - Better documentation for low-level development - Active community and professional support</p>"},{"location":"BEAGLEPLAY_SETUP/#initial-setup","title":"Initial Setup","text":""},{"location":"BEAGLEPLAY_SETUP/#what-you-need","title":"What You Need","text":"<ol> <li>BeaglePlay board</li> <li>USB Type-C cable (data + power capable)</li> <li>microSD card (32GB or larger, Class 10/UHS-I)</li> <li>Development PC running Linux (Ubuntu 24.04 recommended)</li> <li>Ethernet cable (optional, for network boot labs)</li> <li>5V/3A power supply (USB-C, optional but recommended for peripherals)</li> </ol>"},{"location":"BEAGLEPLAY_SETUP/#power-options","title":"Power Options","text":"<p>BeaglePlay can be powered via: 1. USB Type-C: Easiest for development (also provides serial console) 2. mikroBUS 5V pin: For standalone deployments 3. Barrel jack (with optional adapter): Legacy power option</p> <p>Recommendation: Use USB-C for all development work.</p>"},{"location":"BEAGLEPLAY_SETUP/#first-boot","title":"First Boot","text":""},{"location":"BEAGLEPLAY_SETUP/#step-1-download-a-working-image","title":"Step 1: Download a Working Image","text":"<p>For initial testing, download the latest BeaglePlay Debian image:</p> <pre><code>cd ~/Downloads\nwget https://debian.beagleboard.org/images/bone-debian-latest-console-armhf.img.xz\n# Or download from: https://www.beagleboard.org/distros\n</code></pre> <p>Note: We'll build our own minimal images in the labs, but this confirms hardware works.</p>"},{"location":"BEAGLEPLAY_SETUP/#step-2-flash-to-microsd-card","title":"Step 2: Flash to microSD Card","text":"<p>Linux: <pre><code># Find your SD card device (be careful!)\nlsblk\n\n# Assuming your SD card is /dev/sdX (replace X with actual letter)\n# CAUTION: This will erase all data on the card!\nxzcat bone-debian-latest-console-armhf.img.xz | sudo dd of=/dev/sdX bs=4M status=progress\nsync\n</code></pre></p> <p>Etcher (cross-platform): <pre><code># Download from: https://www.balena.io/etcher/\n# Use GUI to flash image\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#step-3-insert-sd-card-and-connect","title":"Step 3: Insert SD Card and Connect","text":"<ol> <li>Power off BeaglePlay (if powered)</li> <li>Insert microSD card into slot</li> <li>Connect USB-C cable from BeaglePlay to your PC</li> <li>BeaglePlay should boot automatically (LEDs will blink)</li> </ol>"},{"location":"BEAGLEPLAY_SETUP/#step-4-access-serial-console","title":"Step 4: Access Serial Console","text":"<p>The USB-C connection provides a serial console at 115200 baud.</p> <p>Find the device: <pre><code># Linux: usually /dev/ttyACM0 or /dev/ttyUSB0\nls -l /dev/ttyACM*\nls -l /dev/ttyUSB*\n\n# Check kernel messages\ndmesg | tail\n</code></pre></p> <p>Connect with screen: <pre><code>sudo apt install screen\nsudo screen /dev/ttyACM0 115200\n</code></pre></p> <p>Or use minicom: <pre><code>sudo apt install minicom\nsudo minicom -D /dev/ttyACM0 -b 115200\n</code></pre></p> <p>Or use picocom (recommended): <pre><code>sudo apt install picocom\nsudo picocom -b 115200 /dev/ttyACM0\n# Exit: Ctrl-A, Ctrl-X\n</code></pre></p> <p>Default Credentials (for Debian image): - Username: <code>debian</code> - Password: <code>temppwd</code></p>"},{"location":"BEAGLEPLAY_SETUP/#step-5-network-configuration","title":"Step 5: Network Configuration","text":"<p>Via Ethernet (easiest): - Connect Ethernet cable - DHCP should auto-configure network - Find IP: <code>ip addr show eth0</code></p> <p>Via WiFi: <pre><code># On BeaglePlay (via serial console)\nsudo nmcli device wifi list\nsudo nmcli device wifi connect \"YOUR_SSID\" password \"YOUR_PASSWORD\"\n</code></pre></p> <p>SSH Access: <pre><code># From development PC\nssh debian@beagleplay.local\n# Or use IP address: ssh debian@192.168.1.XXX\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#gpio-and-expansion-headers","title":"GPIO and Expansion Headers","text":""},{"location":"BEAGLEPLAY_SETUP/#pin-headers","title":"Pin Headers","text":"<p>BeaglePlay has two 46-pin headers (P8 and P9) similar to other BeagleBone boards.</p> <p>Important:  - I/O voltage: 3.3V (NOT 5V tolerant!) - Always check pinout before connecting devices</p> <p>Pinout Reference: https://docs.beagleboard.org/latest/boards/beagleplay/</p>"},{"location":"BEAGLEPLAY_SETUP/#mikrobus-socket","title":"mikroBUS Socket","text":"<p>BeaglePlay includes a mikroBUS connector for Click boards from MikroElektronika.</p> <p>Pinout: <pre><code>AN  - Analog Input\nRST - Reset\nCS  - SPI Chip Select\nSCK - SPI Clock\nMISO - SPI Master In\nMOSI - SPI Master Out\nPWM - PWM Output\nINT - Interrupt\nRX  - UART Receive\nTX  - UART Transmit\nSCL - I2C Clock\nSDA - I2C Data\n</code></pre></p> <p>Compatible Modules: 1000+ Click boards available Example Use Cases: Sensors, displays, motor controllers, communication modules</p>"},{"location":"BEAGLEPLAY_SETUP/#grove-connector","title":"Grove Connector","text":"<p>Single Grove connector supporting I2C devices.</p> <p>Use Case: Quick prototyping with Seeed Studio Grove modules</p>"},{"location":"BEAGLEPLAY_SETUP/#qwiicstemma-qt","title":"QWIIC/STEMMA QT","text":"<p>I2C connector compatible with SparkFun QWIIC and Adafruit STEMMA QT ecosystem.</p> <p>Voltage: 3.3V Protocol: I2C Use Case: Chaining multiple I2C sensors without breadboards</p>"},{"location":"BEAGLEPLAY_SETUP/#boot-modes","title":"Boot Modes","text":""},{"location":"BEAGLEPLAY_SETUP/#boot-order","title":"Boot Order","text":"<p>BeaglePlay boot sequence (default): 1. microSD card (if present and bootable) 2. eMMC (on-board flash) 3. USB (DFU mode) 4. UART/Serial boot (rarely used)</p>"},{"location":"BEAGLEPLAY_SETUP/#boot-button","title":"Boot Button","text":"<p>Location: Small button labeled \"BOOT\" or \"USR\"</p> <p>Function: - Hold during power-up: Forces boot from eMMC (skips SD card) - Quick press during boot: Can interrupt U-Boot for console</p>"},{"location":"BEAGLEPLAY_SETUP/#emmc-vs-sd-card","title":"eMMC vs SD Card","text":"<p>For Development: - Use microSD card for easy reflashing - Keep eMMC as recovery/fallback</p> <p>For Production: - Flash final image to eMMC - Faster boot times - More reliable than SD cards</p> <p>Flash to eMMC (from booted system): <pre><code># Boot from SD card first\n# Then flash eMMC with image from SD:\nsudo /opt/scripts/tools/eMMC/beaglebone-black-make-microSD-flasher-from-eMMC.sh\n# Or use custom flashing scripts (covered in labs)\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#led-indicators","title":"LED Indicators","text":"<p>BeaglePlay has multiple LEDs:</p> LED Color Typical Meaning USR0 Blue Heartbeat (system alive) USR1 Blue SD card activity USR2 Blue CPU activity USR3 Blue eMMC activity Power Red/Green Power status <p>Controlling LEDs: <pre><code># On running system\ncd /sys/class/leds/\n\n# Turn on USR LED 0\necho 1 &gt; beagleplay::usr0/brightness\n\n# Set trigger to heartbeat\necho heartbeat &gt; beagleplay::usr0/trigger\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#uartserial-console-details","title":"UART/Serial Console Details","text":""},{"location":"BEAGLEPLAY_SETUP/#hardware-setup","title":"Hardware Setup","text":"<p>USB-C Connection: - Automatically creates <code>/dev/ttyACM0</code> (Linux) - No FTDI cable needed - Integrated UART-to-USB bridge</p> <p>Parameters: - Baud rate: 115200 - Data bits: 8 - Parity: None - Stop bits: 1 - Flow control: None</p>"},{"location":"BEAGLEPLAY_SETUP/#accessing-u-boot-console","title":"Accessing U-Boot Console","text":"<ol> <li>Connect serial terminal before powering on</li> <li>Power on BeaglePlay</li> <li>Quickly press any key when you see:    <pre><code>Hit any key to stop autoboot:  2\n</code></pre></li> <li>You'll get U-Boot prompt: <code>=&gt;</code></li> </ol> <p>U-Boot Commands: <pre><code>=&gt; help                 # List all commands\n=&gt; printenv            # Show environment variables\n=&gt; version             # U-Boot version\n=&gt; bdinfo              # Board info\n=&gt; mmc list            # List MMC devices\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#development-workflow","title":"Development Workflow","text":""},{"location":"BEAGLEPLAY_SETUP/#recommended-setup","title":"Recommended Setup","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         USB-C          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Development PC \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  BeaglePlay  \u2502\n\u2502  (Ubuntu 24.04) \u2502    (Console + Power)   \u2502              \u2502\n\u2502                 \u2502                        \u2502   microSD    \u2502\n\u2502  - Build tools  \u2502      Ethernet          \u2502   card       \u2502\n\u2502  - Cross-comp   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502              \u2502\n\u2502  - Text editor  \u2502     (Optional)         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502  - Git          \u2502                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2502\n                                            Peripherals\n                                            (sensors, etc.)\n</code></pre>"},{"location":"BEAGLEPLAY_SETUP/#workflow-steps-preview","title":"Workflow Steps (Preview)","text":"<ol> <li>Write code on development PC</li> <li>Cross-compile for ARM64 (on PC)</li> <li>Transfer binary to BeaglePlay (via network, SD card, or serial)</li> <li>Execute on BeaglePlay</li> <li>Debug via serial console or SSH</li> <li>Iterate</li> </ol> <p>(Detailed workflows covered in individual labs)</p>"},{"location":"BEAGLEPLAY_SETUP/#troubleshooting","title":"Troubleshooting","text":""},{"location":"BEAGLEPLAY_SETUP/#beagleplay-wont-boot","title":"BeaglePlay Won't Boot","text":"<p>Check: 1. Proper USB-C cable (some cables are power-only) 2. SD card is properly formatted and imaged 3. Power supply provides enough current (3A recommended) 4. LEDs show activity</p> <p>Try: - Re-flash SD card - Try booting from eMMC (remove SD card) - Check serial console for error messages</p>"},{"location":"BEAGLEPLAY_SETUP/#no-serial-console","title":"No Serial Console","text":"<p>Linux: <pre><code># Check if device appears\ndmesg | grep tty\n\n# Check permissions\nls -l /dev/ttyACM0\n\n# Add user to dialout group (logout/login required)\nsudo usermod -a -G dialout $USER\n</code></pre></p> <p>Common Issues: - Driver not loaded: <code>sudo modprobe cdc_acm</code> - Permission denied: User not in <code>dialout</code> group - Wrong device: Try <code>/dev/ttyUSB0</code> or <code>/dev/ttyACM1</code></p>"},{"location":"BEAGLEPLAY_SETUP/#network-not-working","title":"Network Not Working","text":"<p>Ethernet: <pre><code># Check link status\nip link show eth0\n\n# Try manual DHCP\nsudo dhclient eth0\n</code></pre></p> <p>WiFi: <pre><code># Check WiFi device\nnmcli device status\n\n# Scan for networks\nsudo nmcli device wifi rescan\nsudo nmcli device wifi list\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#cant-ssh-to-beagleplay","title":"Can't SSH to BeaglePlay","text":"<p>Check: 1. Network connectivity: <code>ping beagleplay.local</code> or <code>ping &lt;IP&gt;</code> 2. SSH service running: <code>sudo systemctl status ssh</code> (on BeaglePlay) 3. Firewall not blocking (unlikely on default Debian image)</p> <p>Enable SSH (if disabled): <pre><code># On BeaglePlay via serial console\nsudo systemctl enable ssh\nsudo systemctl start ssh\n</code></pre></p>"},{"location":"BEAGLEPLAY_SETUP/#next-steps","title":"Next Steps","text":"<p>Once your BeaglePlay is working:</p> <ol> <li>\u2705 Verify serial console access</li> <li>\u2705 Confirm network connectivity</li> <li>\u2705 Test SSH access</li> <li>\u2705 Explore GPIO (blink LED)</li> <li>\ud83d\udcda Proceed to Lab 1: Cross-Compilation Toolchain</li> </ol>"},{"location":"BEAGLEPLAY_SETUP/#additional-resources","title":"Additional Resources","text":"<ul> <li>Official Documentation: https://docs.beagleboard.org/latest/boards/beagleplay/</li> <li>BeagleBoard Forums: https://forum.beagleboard.org/</li> <li>TI AM62x TRM: https://www.ti.com/product/AM625</li> <li>Schematics: https://git.beagleboard.org/beagleplay/beagleplay</li> <li>Community Projects: https://beagleboard.org/project</li> </ul> <p>Last Updated: 2025-01-24 Hardware: BeaglePlay Rev A1 Compatible with: Debian 11/12, Custom Buildroot/Yocto images</p>"},{"location":"BIBLIOGRAPHY/","title":"Bibliography","text":"<p>Comprehensive collection of references, resources, and authoritative sources used throughout this research odyssey.</p>"},{"location":"BIBLIOGRAPHY/#embedded-linux","title":"Embedded Linux","text":""},{"location":"BIBLIOGRAPHY/#books","title":"Books","text":"<p>Mastering Embedded Linux Programming - Chris Simmonds (3rd Edition) - Publisher: Packt Publishing - Comprehensive guide to embedded Linux development - Covers toolchains, bootloaders, kernel, and root filesystems</p> <p>Embedded Linux Primer - Christopher Hallinan (2nd Edition) - Publisher: Prentice Hall - Foundational concepts and practical examples - Cross-compilation and system bring-up</p> <p>Linux Device Drivers - Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman (3rd Edition) - Publisher: O'Reilly Media - Authoritative guide to kernel module development - Available online: https://lwn.net/Kernel/LDD3/</p>"},{"location":"BIBLIOGRAPHY/#training-materials","title":"Training Materials","text":"<p>Bootlin Embedded Linux Training - Free training materials: https://bootlin.com/docs/ - Hands-on labs and exercises - Kernel and driver development focus</p> <p>Bootlin Yocto Project Training - Layer development and BitBake - Custom distribution creation - Available at: https://bootlin.com/training/yocto/</p>"},{"location":"BIBLIOGRAPHY/#online-resources","title":"Online Resources","text":"<ul> <li>Linux Kernel Documentation: https://www.kernel.org/doc/html/latest/</li> <li>Embedded Linux Wiki: https://elinux.org/</li> <li>Yocto Project Documentation: https://docs.yoctoproject.org/</li> </ul>"},{"location":"BIBLIOGRAPHY/#linux-kernel-development","title":"Linux Kernel Development","text":""},{"location":"BIBLIOGRAPHY/#books_1","title":"Books","text":"<p>Linux Kernel Development - Robert Love (3rd Edition) - Publisher: Addison-Wesley Professional - Kernel internals and development process - Comprehensive coverage of subsystems</p> <p>Understanding the Linux Kernel - Daniel P. Bovet, Marco Cesati (3rd Edition) - Publisher: O'Reilly Media - Detailed kernel internals analysis - Focus on x86 architecture</p> <p>Linux System Programming - Robert Love (2nd Edition) - Publisher: O'Reilly Media - System calls and low-level programming - Performance considerations</p>"},{"location":"BIBLIOGRAPHY/#documentation","title":"Documentation","text":"<ul> <li>Linux Kernel Documentation Project: https://www.kernel.org/doc/</li> <li>Kernel Development Tutorial: https://kernelnewbies.org/</li> <li>Linux Weekly News (LWN): https://lwn.net/</li> </ul>"},{"location":"BIBLIOGRAPHY/#build-systems","title":"Build Systems","text":""},{"location":"BIBLIOGRAPHY/#cmake","title":"CMake","text":"<p>Professional CMake: A Practical Guide - Craig Scott - Modern CMake practices - Target-based design patterns - Available: https://crascit.com/professional-cmake/</p> <p>Mastering CMake - Ken Martin, Bill Hoffman - Publisher: Kitware - Comprehensive reference - Official CMake guide</p>"},{"location":"BIBLIOGRAPHY/#documentation_1","title":"Documentation","text":"<ul> <li>CMake Documentation: https://cmake.org/documentation/</li> <li>CMake Tutorial: https://cmake.org/cmake/help/latest/guide/tutorial/</li> <li>Modern CMake Guide: https://cliutils.gitlab.io/modern-cmake/</li> </ul>"},{"location":"BIBLIOGRAPHY/#autotools","title":"Autotools","text":"<p>Autotools: A Practitioner's Guide to GNU Autoconf, Automake, and Libtool - John Calcote - Publisher: No Starch Press - Comprehensive Autotools coverage - Practical examples</p>"},{"location":"BIBLIOGRAPHY/#yocto-project","title":"Yocto Project","text":""},{"location":"BIBLIOGRAPHY/#documentation_2","title":"Documentation","text":"<ul> <li>Yocto Project Reference Manual: https://docs.yoctoproject.org/ref-manual/</li> <li>Yocto Project Development Tasks Manual: https://docs.yoctoproject.org/dev-manual/</li> <li>BitBake User Manual: https://docs.yoctoproject.org/bitbake/</li> </ul>"},{"location":"BIBLIOGRAPHY/#books_2","title":"Books","text":"<p>Embedded Linux Systems with the Yocto Project - Rudolf J. Streif - Publisher: Prentice Hall - Comprehensive Yocto guide - Layer development and customization</p> <p>Yocto for Raspberry Pi - Pierre-Jean Texier, Petter Mab\u00e4cker - Specific platform focus - Practical examples and recipes</p>"},{"location":"BIBLIOGRAPHY/#real-time-linux","title":"Real-Time Linux","text":""},{"location":"BIBLIOGRAPHY/#books_3","title":"Books","text":"<p>Real-Time Linux Kernel Scheduling - Alberto Fern\u00e1ndez Mart\u00ednez - PREEMPT-RT patch analysis - Scheduling algorithms and latency</p>"},{"location":"BIBLIOGRAPHY/#documentation_3","title":"Documentation","text":"<ul> <li>PREEMPT-RT Wiki: https://wiki.linuxfoundation.org/realtime/start</li> <li>Real-Time Linux Documentation: https://www.kernel.org/doc/Documentation/</li> <li>Xenomai Documentation: https://www.xenomai.org/documentation/</li> </ul>"},{"location":"BIBLIOGRAPHY/#papers","title":"Papers","text":"<p>A Realtime Preemption Overview - Paul McKenney - Technical analysis of PREEMPT-RT - Available through Linux Foundation</p>"},{"location":"BIBLIOGRAPHY/#debugging-and-performance","title":"Debugging and Performance","text":""},{"location":"BIBLIOGRAPHY/#books_4","title":"Books","text":"<p>Systems Performance: Enterprise and the Cloud - Brendan Gregg (2nd Edition) - Publisher: Addison-Wesley Professional - Comprehensive performance analysis - Methodology and tools</p> <p>BPF Performance Tools - Brendan Gregg - Publisher: Addison-Wesley Professional - eBPF-based tracing and analysis - Modern kernel observability</p> <p>Linux Debugging and Performance Tuning - Steve Best - Publisher: Prentice Hall - Debugging techniques and tools - Performance optimization strategies</p>"},{"location":"BIBLIOGRAPHY/#tools-documentation","title":"Tools Documentation","text":"<ul> <li>Ftrace Documentation: https://www.kernel.org/doc/Documentation/trace/</li> <li>Perf Wiki: https://perf.wiki.kernel.org/</li> <li>eBPF Documentation: https://ebpf.io/</li> </ul>"},{"location":"BIBLIOGRAPHY/#devops-and-infrastructure","title":"DevOps and Infrastructure","text":""},{"location":"BIBLIOGRAPHY/#books_5","title":"Books","text":"<p>The DevOps Handbook - Gene Kim, Jez Humble, Patrick Debois, John Willis - Publisher: IT Revolution Press - DevOps principles and practices - Case studies and methodology</p> <p>Infrastructure as Code - Kief Morris (2nd Edition) - Publisher: O'Reilly Media - IaC principles and patterns - Tool-agnostic best practices</p> <p>Kubernetes in Action - Marko Luk\u0161a (2nd Edition) - Publisher: Manning Publications - Container orchestration - Production deployment patterns</p>"},{"location":"BIBLIOGRAPHY/#documentation_4","title":"Documentation","text":"<ul> <li>Docker Documentation: https://docs.docker.com/</li> <li>Kubernetes Documentation: https://kubernetes.io/docs/</li> <li>Terraform Documentation: https://www.terraform.io/docs/</li> <li>Ansible Documentation: https://docs.ansible.com/</li> </ul>"},{"location":"BIBLIOGRAPHY/#networking","title":"Networking","text":""},{"location":"BIBLIOGRAPHY/#books_6","title":"Books","text":"<p>TCP/IP Illustrated, Volume 1: The Protocols - W. Richard Stevens (2nd Edition) - Publisher: Addison-Wesley Professional - Definitive TCP/IP reference - Protocol internals and analysis</p> <p>Linux Network Programming - Jon C. Snader - Publisher: Addison-Wesley Professional - Socket programming - Network application development</p>"},{"location":"BIBLIOGRAPHY/#rfcs","title":"RFCs","text":"<ul> <li>RFC Index: https://www.rfc-editor.org/</li> <li>IETF Documentation: https://www.ietf.org/standards/</li> </ul>"},{"location":"BIBLIOGRAPHY/#hardware-platforms","title":"Hardware Platforms","text":""},{"location":"BIBLIOGRAPHY/#raspberry-pi","title":"Raspberry Pi","text":"<ul> <li>Official Documentation: https://www.raspberrypi.com/documentation/</li> <li>Raspberry Pi Forums: https://forums.raspberrypi.com/</li> <li>Datasheets: https://datasheets.raspberrypi.com/</li> </ul>"},{"location":"BIBLIOGRAPHY/#beagleboard","title":"BeagleBoard","text":"<ul> <li>BeagleBoard Documentation: https://beagleboard.org/support</li> <li>BeaglePlay Resources: https://www.beagleboard.org/boards/beagleplay</li> </ul>"},{"location":"BIBLIOGRAPHY/#rp2040-raspberry-pi-pico","title":"RP2040 (Raspberry Pi Pico)","text":"<ul> <li>RP2040 Datasheet: https://datasheets.raspberrypi.com/rp2040/</li> <li>Pico SDK Documentation: https://raspberrypi.github.io/pico-sdk-doxygen/</li> <li>Getting Started Guide: https://datasheets.raspberrypi.com/pico/getting-started-with-pico.pdf</li> </ul>"},{"location":"BIBLIOGRAPHY/#esp32","title":"ESP32","text":"<ul> <li>ESP32 Documentation: https://docs.espressif.com/projects/esp-idf/</li> <li>ESP-IDF Programming Guide: https://docs.espressif.com/</li> <li>Hardware Reference: https://www.espressif.com/en/products/socs/esp32</li> </ul>"},{"location":"BIBLIOGRAPHY/#arduino","title":"Arduino","text":"<ul> <li>Arduino Reference: https://www.arduino.cc/reference/</li> <li>Arduino Documentation: https://docs.arduino.cc/</li> </ul>"},{"location":"BIBLIOGRAPHY/#standards-and-specifications","title":"Standards and Specifications","text":""},{"location":"BIBLIOGRAPHY/#posix","title":"POSIX","text":"<ul> <li>IEEE Std 1003.1: POSIX Standard</li> <li>The Open Group Base Specifications: https://pubs.opengroup.org/</li> </ul>"},{"location":"BIBLIOGRAPHY/#linux-standards","title":"Linux Standards","text":"<ul> <li>Linux Standard Base: https://refspecs.linuxfoundation.org/lsb.shtml</li> <li>Filesystem Hierarchy Standard: https://refspecs.linuxfoundation.org/fhs.shtml</li> </ul>"},{"location":"BIBLIOGRAPHY/#online-courses-and-platforms","title":"Online Courses and Platforms","text":""},{"location":"BIBLIOGRAPHY/#linux-foundation","title":"Linux Foundation","text":"<ul> <li>Linux Foundation Training: https://training.linuxfoundation.org/</li> <li>edX Linux Courses: https://www.edx.org/school/linuxfoundationx</li> </ul>"},{"location":"BIBLIOGRAPHY/#academic-resources","title":"Academic Resources","text":"<ul> <li>MIT OpenCourseWare - Operating Systems: https://ocw.mit.edu/</li> <li>Stanford CS140: Operating Systems</li> <li>Berkeley CS162: Operating Systems</li> </ul>"},{"location":"BIBLIOGRAPHY/#communities-and-forums","title":"Communities and Forums","text":"<ul> <li>Stack Overflow: https://stackoverflow.com/</li> <li>Unix &amp; Linux Stack Exchange: https://unix.stackexchange.com/</li> <li>Kernel Newbies: https://kernelnewbies.org/</li> <li>Embedded Linux Community: https://www.embedded-linux.org/</li> <li>Yocto Project Mailing Lists: https://lists.yoctoproject.org/</li> </ul>"},{"location":"BIBLIOGRAPHY/#tools-and-software","title":"Tools and Software","text":""},{"location":"BIBLIOGRAPHY/#development-tools","title":"Development Tools","text":"<ul> <li>GCC: https://gcc.gnu.org/</li> <li>GDB: https://www.gnu.org/software/gdb/</li> <li>QEMU: https://www.qemu.org/</li> <li>Git: https://git-scm.com/</li> </ul>"},{"location":"BIBLIOGRAPHY/#analysis-tools","title":"Analysis Tools","text":"<ul> <li>Valgrind: https://valgrind.org/</li> <li>Strace: https://strace.io/</li> <li>Ltrace: https://ltrace.org/</li> <li>Wireshark: https://www.wireshark.org/</li> </ul>"},{"location":"BIBLIOGRAPHY/#conferences-and-events","title":"Conferences and Events","text":"<ul> <li>Embedded Linux Conference (ELC)</li> <li>Linux Plumbers Conference</li> <li>FOSDEM</li> <li>Kernel Recipes</li> <li>Real-Time Linux Workshop</li> </ul>"},{"location":"BIBLIOGRAPHY/#journals-and-publications","title":"Journals and Publications","text":"<ul> <li>Linux Journal (archived)</li> <li>IEEE Embedded Systems Letters</li> <li>ACM Transactions on Embedded Computing Systems</li> <li>Embedded Linux Magazine</li> </ul>"},{"location":"BIBLIOGRAPHY/#citation-format","title":"Citation Format","text":"<p>All citations in research documents use the following format:</p> <pre><code>[AuthorLastName Year] AuthorFirstName AuthorLastName, \"Title\", Publisher/Source, Year.\nURL (if applicable)\nAccessed: Date\n</code></pre> <p>Example: <pre><code>[Gregg 2020] Brendan Gregg, \"Systems Performance: Enterprise and the Cloud\", 2nd Edition,\nAddison-Wesley Professional, 2020.\n</code></pre></p> <p>Document Version: 1.0</p> <p>Last Updated: November 2025</p> <p>Maintenance: Updated as new resources are discovered and utilized</p>"},{"location":"BUYMEACOFFEE-PROFILE/","title":"Buy Me a Coffee - Profile Description","text":""},{"location":"BUYMEACOFFEE-PROFILE/#profile-title","title":"Profile Title","text":"<p>The Hitchhiker's Guide to Developing - Don't Panic! \u2615</p>"},{"location":"BUYMEACOFFEE-PROFILE/#short-bio-160-characters-max","title":"Short Bio (160 characters max)","text":"<p>Creating comprehensive, entertaining guides through embedded Linux, kernel development, and DevOps. Your towel for navigating the development universe! \ud83d\ude80</p>"},{"location":"BUYMEACOFFEE-PROFILE/#full-description","title":"Full Description","text":""},{"location":"BUYMEACOFFEE-PROFILE/#welcome-fellow-traveler","title":"Welcome, Fellow Traveler! \ud83d\udc4b","text":"<p>I'm documenting my journey through the vast universe of systems engineering, embedded development, and infrastructure automation in the form of The Hitchhiker's Guide to Developing - a comprehensive, mostly accurate, and occasionally entertaining resource for developers at all levels.</p>"},{"location":"BUYMEACOFFEE-PROFILE/#what-im-building","title":"What I'm Building \ud83d\udee0\ufe0f","text":"<p>This isn't just another tutorial collection. It's a systematic exploration through:</p> <ul> <li>Embedded Linux Development - Bootlin training materials, cross-compilation, kernel builds</li> <li>Yocto Project - Custom distribution creation and BitBake mastery</li> <li>Linux Kernel Development - Module development, debugging, and internals</li> <li>Device Drivers - Hardware interfacing and platform drivers</li> <li>Real-Time Systems - PREEMPT-RT and deterministic behavior</li> <li>DevOps Homelab - Infrastructure automation and CI/CD pipelines</li> <li>Build Systems - CMake, Meson, and modern build practices</li> <li>Performance Engineering - Profiling, optimization, and analysis</li> </ul>"},{"location":"BUYMEACOFFEE-PROFILE/#the-philosophy","title":"The Philosophy \ud83d\udcda","text":"<p>Following Douglas Adams' wisdom, this guide aims to be: - Always Accurate: Every procedure tested and verified - Sometimes Entertaining: Learning shouldn't feel like reading a manual - Perpetually Useful: Documentation that serves both now and later</p> <p>All content is: \u2705 Professionally documented with reproducible procedures \u2705 Open source and freely available \u2705 Based on real hardware testing (RPi, BeaglePlay, ESP32, Arduino, Pico) \u2705 Updated with new discoveries and learnings  </p>"},{"location":"BUYMEACOFFEE-PROFILE/#how-your-support-helps","title":"How Your Support Helps \u2615","text":"<p>Every coffee you buy directly enables:</p> <p>\ud83d\udcbb Hardware Acquisition - Testing across diverse platforms (new SBCs, microcontrollers, development boards)</p> <p>\ud83d\udcda Deeper Documentation - More time for comprehensive tutorials and case studies</p> <p>\ud83d\udd2c Advanced Research - Exploring real-time systems, performance optimization, and complex topics</p> <p>\u26a1 Faster Updates - Regular content additions and issue responses</p> <p>\ud83c\udf1f New Chapters - Expanding into network protocols, security, and emerging technologies</p>"},{"location":"BUYMEACOFFEE-PROFILE/#what-youre-supporting","title":"What You're Supporting \ud83c\udfaf","text":"<ul> <li>\ud83d\udcd6 Comprehensive Documentation: Professional-grade technical writing</li> <li>\ud83e\uddea Real Hardware Testing: All procedures verified on actual platforms</li> <li>\ud83d\udd27 Practical Projects: Working examples and complete implementations</li> <li>\ud83c\udf93 Educational Content: From basics to advanced topics</li> <li>\ud83e\udd1d Community Resource: Freely available knowledge for everyone</li> </ul>"},{"location":"BUYMEACOFFEE-PROFILE/#current-progress","title":"Current Progress \ud83d\ude80","text":"<p>\u2705 Repository architecture and documentation standards \u2705 Research methodology and templates \ud83d\udd04 Beginning Bootlin embedded Linux training \u23f3 Planning Yocto Project implementation \u23f3 Setting up DevOps homelab infrastructure  </p>"},{"location":"BUYMEACOFFEE-PROFILE/#the-hardware-lab","title":"The Hardware Lab \ud83d\udd27","text":"<p>Currently working with: - Raspberry Pi (multiple models) - Raspberry Pi Pico (RP2040) - BeaglePlay - Arduino boards - ESP32 development boards</p> <p>Your support helps expand this to more platforms!</p>"},{"location":"BUYMEACOFFEE-PROFILE/#why-this-matters","title":"Why This Matters \ud83d\udca1","text":"<p>Quality technical documentation is rare. Most resources are either: - Too basic to be useful for real projects - Too advanced without proper foundations - Not reproducible or tested - Scattered across multiple sources</p> <p>This guide aims to be the comprehensive, tested, well-documented resource that combines: - Academic rigor - Practical application - Systematic progression - Entertainment value (because learning should be fun!)</p>"},{"location":"BUYMEACOFFEE-PROFILE/#join-the-journey","title":"Join the Journey \ud83c\udf0c","text":"<p>Your support makes this guide better for everyone. Every contribution, no matter the size, helps create freely available, high-quality educational content for the entire development community.</p> <p>Remember: Don't Panic, and Always Know Where Your Documentation Is!</p> <p>\ud83d\udd17 GitHub: https://github.com/Jofralso/hitchhikers-guide-to-developing \ud83d\udcd6 Read The Journey: Understand the philosophy and approach \ud83d\uddfa\ufe0f View the Roadmap: See what's planned across 8 learning phases  </p>"},{"location":"BUYMEACOFFEE-PROFILE/#support-tiers","title":"Support Tiers","text":"<p>\u2615 Coffee ($3) - Fuel for late-night documentation sessions</p> <p>\u2615\u2615 Double Shot ($5) - Support deeper research into complex topics</p> <p>\u2615\u2615\u2615 Development Setup ($10) - Help acquire testing hardware</p> <p>\ud83d\ude80 Major Contribution ($25+) - Enables significant new chapters and platforms</p> <p>Thank you for supporting open, comprehensive, and entertaining technical education!</p> <p>Made with \u2615, dedication, and a profound appreciation for towels.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>This is primarily a personal learning repository. However, the methodologies and documentation are designed to be useful to others.</p>"},{"location":"CONTRIBUTING/#feedback-and-suggestions","title":"Feedback and Suggestions","text":"<p>If you find this repository helpful and have suggestions:</p> <ol> <li>Open an issue describing your suggestion</li> <li>Include context about which domain or topic it relates to</li> <li>Provide references if applicable</li> </ol>"},{"location":"CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>If you notice errors in documentation or procedures:</p> <ol> <li>Open an issue with a clear description</li> <li>Include the file and section where the error appears</li> <li>Suggest a correction if possible</li> </ol>"},{"location":"CONTRIBUTING/#general-guidelines","title":"General Guidelines","text":"<ul> <li>This repository follows the \"Don't Panic\" philosophy</li> <li>All procedures should be reproducible</li> <li>Documentation should be clear and concise</li> <li>References should be cited</li> </ul>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, constructive, and helpful.</p>"},{"location":"LAB_STRUCTURE/","title":"Lab Structure and Learning Path","text":"<p>Target Platform: BeaglePlay (Texas Instruments AM62 - Cortex-A53)</p> <p>This document outlines the adapted learning labs for embedded Linux development on BeaglePlay, inspired by professional training materials but created as original content.</p>"},{"location":"LAB_STRUCTURE/#overview","title":"Overview","text":"<p>The learning journey is divided into three main tracks:</p> <ol> <li>Embedded Linux Fundamentals - Core system development skills</li> <li>Yocto Project - Industrial build system mastery</li> <li>Linux Debugging &amp; Performance - Advanced troubleshooting</li> </ol>"},{"location":"LAB_STRUCTURE/#track-1-embedded-linux-fundamentals","title":"Track 1: Embedded Linux Fundamentals","text":""},{"location":"LAB_STRUCTURE/#lab-1-cross-compilation-toolchain","title":"Lab 1: Cross-Compilation Toolchain","text":"<p>Objective: Build a custom toolchain for ARM64/AARCH64</p> <p>Topics: - Crosstool-NG configuration and usage - Target architecture: ARM Cortex-A53 (BeaglePlay CPU) - C library selection: musl vs glibc vs uclibc - GCC configuration for embedded targets - Toolchain testing with QEMU user-mode emulation</p> <p>Key Deliverables: - Working <code>aarch64-linux-gcc</code> toolchain - Cross-compiled \"Hello World\" application - Understanding of sysroot and library paths</p>"},{"location":"LAB_STRUCTURE/#lab-2-hardware-discovery","title":"Lab 2: Hardware Discovery","text":"<p>Objective: Understand BeaglePlay hardware architecture</p> <p>Topics: - TI AM62 SoC architecture (Quad-core Cortex-A53) - Memory layout (DDR4, on-chip SRAM) - Peripheral interfaces (UART, I2C, SPI, GPIO, USB) - BeaglePlay-specific features (WiFi, Bluetooth, SubGHz, mikroBUS) - Device Tree basics for hardware description</p> <p>Key Deliverables: - Hardware connection diagram - Serial console access via UART - Device Tree exploration for BeaglePlay</p>"},{"location":"LAB_STRUCTURE/#lab-3-bootloader-u-boot","title":"Lab 3: Bootloader - U-Boot","text":"<p>Objective: Configure and build U-Boot for BeaglePlay</p> <p>Topics: - U-Boot architecture and boot sequence - BeaglePlay-specific U-Boot configuration - Boot sources: SD card, eMMC - U-Boot environment variables - Network booting (TFTP, NFS) - Loading kernel and device tree</p> <p>Key Deliverables: - Custom U-Boot binary for BeaglePlay - Automated boot script - Network boot configuration</p>"},{"location":"LAB_STRUCTURE/#lab-4-linux-kernel","title":"Lab 4: Linux Kernel","text":"<p>Objective: Configure, build, and boot a custom Linux kernel</p> <p>Topics: - Kernel version selection (LTS vs mainline) - BeaglePlay-specific kernel configuration - Device Tree compilation and customization - Kernel modules and built-in drivers - Kernel command line parameters - Cross-compilation workflow</p> <p>Key Deliverables: - Bootable Linux kernel image - Custom Device Tree blob (.dtb) - Working serial console and basic peripherals</p>"},{"location":"LAB_STRUCTURE/#lab-5-root-filesystem-tiny-system","title":"Lab 5: Root Filesystem - Tiny System","text":"<p>Objective: Create a minimal root filesystem from scratch</p> <p>Topics: - Essential filesystem hierarchy (/bin, /lib, /etc, /dev) - BusyBox configuration and compilation - Static vs dynamic linking - Init process and system startup - Basic device nodes - Manual library dependency resolution</p> <p>Key Deliverables: - Bootable minimal Linux system (&lt;10 MB) - Understanding of what makes Linux \"Linux\" - Custom init scripts</p>"},{"location":"LAB_STRUCTURE/#lab-6-block-filesystems","title":"Lab 6: Block Filesystems","text":"<p>Objective: Implement proper filesystems for storage</p> <p>Topics: - ext4 for SD card/eMMC - Filesystem mounting and fstab - Read-only vs read-write filesystems - Partition schemes (boot, rootfs, data) - Filesystem tools (mkfs, fsck, resize2fs)</p> <p>Key Deliverables: - Multi-partition SD card setup - Persistent data storage - Filesystem optimization for embedded use</p>"},{"location":"LAB_STRUCTURE/#lab-7-flash-filesystems","title":"Lab 7: Flash Filesystems","text":"<p>Objective: Work with flash-specific filesystems</p> <p>Topics: - UBIFS for raw NAND/NOR flash - SquashFS for read-only compressed storage - Overlay filesystems (OverlayFS) - Flash wear leveling concepts - MTD subsystem basics</p> <p>Key Deliverables: - Compressed read-only rootfs - Writable overlay for configuration - Understanding flash constraints</p>"},{"location":"LAB_STRUCTURE/#lab-8-buildroot","title":"Lab 8: Buildroot","text":"<p>Objective: Automate system building with Buildroot</p> <p>Topics: - Buildroot architecture and menuconfig - BeaglePlay board support (custom defconfig) - Package selection and configuration - External tree for customizations - Rebuilding and incremental builds - Generating SDK for application development</p> <p>Key Deliverables: - Automated complete system build - Custom Buildroot configuration - Reproducible builds</p>"},{"location":"LAB_STRUCTURE/#lab-9-application-development","title":"Lab 9: Application Development","text":"<p>Objective: Develop and debug applications on target</p> <p>Topics: - Cross-compilation of applications - Library dependencies and pkg-config - Remote debugging with gdbserver - Application frameworks (Qt, GTK+ if applicable) - Hardware interfacing (GPIO, I2C, SPI via sysfs/libgpiod) - Example: Nunchuk controller driver (I2C device)</p> <p>Key Deliverables: - Custom application for BeaglePlay - Remote debugging session - Hardware interaction demo</p>"},{"location":"LAB_STRUCTURE/#track-2-yocto-project-development","title":"Track 2: Yocto Project Development","text":""},{"location":"LAB_STRUCTURE/#lab-10-yocto-introduction","title":"Lab 10: Yocto Introduction","text":"<p>Objective: Build first image with Yocto for BeaglePlay</p> <p>Topics: - Yocto Project architecture (Poky, BitBake, OpenEmbedded) - Setting up build environment - Understanding layers and recipes - BeaglePlay BSP layer - Image types (core-image-minimal, core-image-full-cmdline)</p> <p>Key Deliverables: - Working Yocto build environment - Basic image running on BeaglePlay - Understanding of BitBake workflow</p>"},{"location":"LAB_STRUCTURE/#lab-11-custom-recipes","title":"Lab 11: Custom Recipes","text":"<p>Objective: Create and modify recipes</p> <p>Topics: - Recipe syntax and structure (.bb files) - Fetching sources (git, tarballs) - do_compile, do_install tasks - Recipe dependencies (DEPENDS, RDEPENDS) - Package splitting and FILES variables - Adding custom applications to image</p> <p>Key Deliverables: - Custom application recipe - Modified existing recipe - Package deployed to target</p>"},{"location":"LAB_STRUCTURE/#lab-12-custom-layers","title":"Lab 12: Custom Layers","text":"<p>Objective: Organize customizations in layers</p> <p>Topics: - Layer structure and layer.conf - Creating meta-beagleplay-custom layer - Layer priorities and bbappend files - Machine configuration files - Distribution policies</p> <p>Key Deliverables: - Custom layer for project-specific code - BeaglePlay machine configuration - Organized build structure</p>"},{"location":"LAB_STRUCTURE/#lab-13-bsp-and-kernel","title":"Lab 13: BSP and Kernel","text":"<p>Objective: Customize kernel in Yocto</p> <p>Topics: - Kernel recipe (linux-yocto, linux-ti) - Device Tree modifications via Yocto - Kernel configuration fragments - Out-of-tree kernel modules as recipes - Kernel version management</p> <p>Key Deliverables: - Custom kernel with modifications - Device Tree overlays - Kernel module integration</p>"},{"location":"LAB_STRUCTURE/#lab-14-sdk-and-devtool","title":"Lab 14: SDK and devtool","text":"<p>Objective: Use Yocto SDK for development</p> <p>Topics: - Generating and installing SDK - SDK sysroot and toolchain - devtool workflow (add, modify, upgrade) - eSDK (extensible SDK) - Application development workflow</p> <p>Key Deliverables: - Installed SDK for BeaglePlay - Application developed with SDK - devtool recipe management</p>"},{"location":"LAB_STRUCTURE/#track-3-linux-debugging-and-performance","title":"Track 3: Linux Debugging and Performance","text":""},{"location":"LAB_STRUCTURE/#lab-15-system-profiling","title":"Lab 15: System Profiling","text":"<p>Objective: Understand system load and resource usage</p> <p>Topics: - top, htop, vmstat, iostat - CPU usage analysis - Memory usage patterns - Process states and scheduling - System resource monitoring</p> <p>Key Deliverables: - System performance baseline - Identified bottlenecks - Monitoring dashboard</p>"},{"location":"LAB_STRUCTURE/#lab-16-application-debugging-gdb","title":"Lab 16: Application Debugging - GDB","text":"<p>Objective: Master gdb for debugging applications</p> <p>Topics: - Local and remote debugging - Breakpoints, watchpoints, catchpoints - Stepping and execution control - Core dump analysis - GDB scripting basics - ELF binary inspection (readelf, objdump, nm)</p> <p>Key Deliverables: - Debug session recordings - Post-mortem crash analysis - Understanding of ELF format</p>"},{"location":"LAB_STRUCTURE/#lab-17-tracing-strace-and-ltrace","title":"Lab 17: Tracing - strace and ltrace","text":"<p>Objective: Trace system calls and library calls</p> <p>Topics: - strace for system call tracing - ltrace for library call tracing - Filtering and focusing traces - Performance impact of tracing - Identifying issues from traces</p> <p>Key Deliverables: - Traced application behavior - Identified system call patterns - Library usage analysis</p>"},{"location":"LAB_STRUCTURE/#lab-18-performance-analysis-perf","title":"Lab 18: Performance Analysis - perf","text":"<p>Objective: Profile CPU usage with perf</p> <p>Topics: - perf record and perf report - CPU profiling (sampling) - Hotspot identification - Flame graphs - Hardware counter events - Kernel and userspace profiling</p> <p>Key Deliverables: - Performance profile of application - Flame graph visualization - Optimization opportunities identified</p>"},{"location":"LAB_STRUCTURE/#lab-19-memory-debugging-valgrind","title":"Lab 19: Memory Debugging - Valgrind","text":"<p>Objective: Detect memory issues</p> <p>Topics: - Memcheck tool for leak detection - Use-after-free and buffer overflows - Massif for heap profiling - Cachegrind for cache simulation - Performance vs debugging builds</p> <p>Key Deliverables: - Memory-clean application - Heap usage visualization - Fixed memory bugs</p>"},{"location":"LAB_STRUCTURE/#lab-20-advanced-tracing-ftrace-and-ebpf","title":"Lab 20: Advanced Tracing - ftrace and eBPF","text":"<p>Objective: Kernel-level tracing and profiling</p> <p>Topics: - ftrace: function tracer, trace events - trace-cmd and KernelShark - eBPF programs and bpftrace - kprobes and uprobes - BCC tools for system analysis - libbpf programming</p> <p>Key Deliverables: - Kernel function traces - Custom eBPF tracing programs - System-wide performance analysis</p>"},{"location":"LAB_STRUCTURE/#lab-21-kernel-debugging","title":"Lab 21: Kernel Debugging","text":"<p>Objective: Debug kernel crashes and issues</p> <p>Topics: - KGDB (Kernel GDB) setup - Kernel panic analysis - Oops messages interpretation - ftrace for kernel debugging - Kmemleak for kernel memory leaks - Lockdep for locking issues</p> <p>Key Deliverables: - KGDB debugging session - Analyzed kernel crash - Fixed kernel-level issue</p>"},{"location":"LAB_STRUCTURE/#hardware-requirements","title":"Hardware Requirements","text":""},{"location":"LAB_STRUCTURE/#primary-platform-beagleplay","title":"Primary Platform: BeaglePlay","text":"<ul> <li>SoC: Texas Instruments AM6254 (Quad-core Cortex-A53 @ 1.4GHz)</li> <li>RAM: 2GB DDR4</li> <li>Storage: 16GB eMMC + microSD slot</li> <li>Connectivity: WiFi 5, Bluetooth 5.2, Gigabit Ethernet, SubGHz (868/915 MHz)</li> <li>Expansion: mikroBUS, Grove, QWIIC/STEMMA QT connectors</li> <li>Debug: UART via USB-C, JTAG</li> </ul>"},{"location":"LAB_STRUCTURE/#development-host-requirements","title":"Development Host Requirements","text":"<ul> <li>OS: Ubuntu 24.04 LTS (or similar Linux distribution)</li> <li>RAM: Minimum 8GB (16GB recommended for Yocto)</li> <li>Storage: 100GB free space (Yocto builds are large)</li> <li>CPU: Modern multi-core processor</li> </ul>"},{"location":"LAB_STRUCTURE/#accessories","title":"Accessories","text":"<ul> <li>USB-C cable (power + serial console)</li> <li>microSD card (32GB+, Class 10 or better)</li> <li>Ethernet cable (for network boot labs)</li> <li>Optional: mikroBUS peripherals (sensors, displays)</li> </ul>"},{"location":"LAB_STRUCTURE/#time-estimates","title":"Time Estimates","text":"Track Labs Estimated Time Embedded Linux Fundamentals Labs 1-9 25-35 hours Yocto Project Labs 10-14 20-25 hours Debugging &amp; Performance Labs 15-21 25-30 hours Total 21 labs 70-90 hours"},{"location":"LAB_STRUCTURE/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux Command Line: Comfortable with shell, file operations, text editing</li> <li>C Programming: Basic to intermediate level</li> <li>Git: Version control fundamentals</li> <li>Hardware: Understanding of basic electronics (optional but helpful)</li> </ul>"},{"location":"LAB_STRUCTURE/#learning-resources","title":"Learning Resources","text":"<ul> <li>Linux kernel documentation</li> <li>U-Boot documentation</li> <li>Yocto Project Mega-Manual</li> <li>BeaglePlay technical reference manual</li> <li>TI AM62x documentation</li> <li>Device Tree specification</li> </ul>"},{"location":"LAB_STRUCTURE/#notes","title":"Notes","text":"<ol> <li>Original Content: All labs are adapted concepts - you must create your own implementations</li> <li>BeaglePlay Focus: Labs specifically target BeaglePlay hardware, not generic boards</li> <li>Progression: Each lab builds on previous knowledge - follow the order</li> <li>Customization: Feel free to extend labs with your own experiments</li> <li>Documentation: Document your journey - this is a learning repository</li> </ol> <p>Last Updated: 2025-01-24 Target Platform: BeaglePlay Based on: Professional embedded Linux training concepts, adapted for self-learning</p>"},{"location":"QUICK_START/","title":"Quick Start: Your First Lab","text":"<p>Goal: Get from zero to running your first embedded Linux lab in 30 minutes.</p>"},{"location":"QUICK_START/#what-youll-do","title":"What You'll Do","text":"<ol> <li>Set up BeaglePlay hardware</li> <li>Verify serial console access</li> <li>Set up development environment</li> <li>Run a simple cross-compiled \"Hello World\"</li> </ol>"},{"location":"QUICK_START/#prerequisites","title":"Prerequisites","text":"<ul> <li>[ ] BeaglePlay board</li> <li>[ ] USB-C cable (data capable)</li> <li>[ ] Ubuntu 24.04 Linux PC (or similar)</li> <li>[ ] Internet connection</li> <li>[ ] ~30 minutes</li> </ul>"},{"location":"QUICK_START/#step-1-hardware-check-5-minutes","title":"Step 1: Hardware Check (5 minutes)","text":""},{"location":"QUICK_START/#connect-beagleplay","title":"Connect BeaglePlay","text":"<ol> <li>Power off your BeaglePlay (if powered)</li> <li>Connect USB-C cable from BeaglePlay to your PC</li> <li>BeaglePlay should power on automatically (LEDs blink)</li> </ol>"},{"location":"QUICK_START/#verify-serial-console","title":"Verify Serial Console","text":"<pre><code># Check if USB serial device appears\nls -l /dev/ttyACM0\n\n# If not found, check for USB devices\ndmesg | grep tty\n# Look for /dev/ttyUSB0 or similar\n</code></pre> <p>Add yourself to dialout group (first time only): <pre><code>sudo usermod -a -G dialout $USER\n# Log out and back in for this to take effect\n</code></pre></p>"},{"location":"QUICK_START/#connect-to-console","title":"Connect to Console","text":"<pre><code># Install picocom if needed\nsudo apt install picocom\n\n# Connect (Ctrl+A, Ctrl+X to exit)\npicocom -b 115200 /dev/ttyACM0\n</code></pre> <p>Expected: You should see boot messages or a login prompt.</p> <p>Troubleshooting: See BeaglePlay Setup Guide</p>"},{"location":"QUICK_START/#step-2-development-environment-10-minutes","title":"Step 2: Development Environment (10 minutes)","text":""},{"location":"QUICK_START/#install-essential-packages","title":"Install Essential Packages","text":"<pre><code># Update package database\nsudo apt update\n\n# Install build essentials and cross-compilation tools\nsudo apt install -y \\\n    build-essential \\\n    git \\\n    wget \\\n    bc \\\n    bison \\\n    flex \\\n    libssl-dev \\\n    libncurses5-dev \\\n    gcc-aarch64-linux-gnu \\\n    g++-aarch64-linux-gnu \\\n    qemu-user\n</code></pre> <p>What these do: - <code>build-essential</code>: GCC, make, and basic build tools - <code>gcc-aarch64-linux-gnu</code>: Cross-compiler for ARM64 (BeaglePlay's architecture) - <code>qemu-user</code>: Run ARM binaries on your x86 PC (for testing)</p>"},{"location":"QUICK_START/#create-workspace","title":"Create Workspace","text":"<pre><code># Create directory for all labs\nmkdir -p ~/embedded-linux-labs\ncd ~/embedded-linux-labs\n\n# Create first lab directory\nmkdir -p lab1-hello-world\ncd lab1-hello-world\n</code></pre>"},{"location":"QUICK_START/#step-3-first-cross-compilation-10-minutes","title":"Step 3: First Cross-Compilation (10 minutes)","text":""},{"location":"QUICK_START/#write-hello-world","title":"Write Hello World","text":"<pre><code># Create hello.c\ncat &gt; hello.c &lt;&lt; 'EOF'\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello from BeaglePlay!\\n\");\n    printf(\"Architecture: ARM64/AARCH64\\n\");\n    printf(\"System: Embedded Linux\\n\");\n    return 0;\n}\nEOF\n</code></pre>"},{"location":"QUICK_START/#compile-for-x86-your-pc","title":"Compile for x86 (your PC)","text":"<pre><code># Native compilation\ngcc -o hello-x86 hello.c\n\n# Run it\n./hello-x86\n</code></pre> <p>Expected output: <pre><code>Hello from BeaglePlay!\nArchitecture: ARM64/AARCH64\nSystem: Embedded Linux\n</code></pre></p>"},{"location":"QUICK_START/#cross-compile-for-arm64-beagleplay","title":"Cross-Compile for ARM64 (BeaglePlay)","text":"<pre><code># Cross-compilation for ARM64\naarch64-linux-gnu-gcc -o hello-arm64 hello.c\n\n# Check the binary\nfile hello-arm64\n</code></pre> <p>Expected output: <pre><code>hello-arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), \ndynamically linked, interpreter /lib/ld-linux-aarch64.so.1, ...\n</code></pre></p> <p>Important: Notice it says \"ARM aarch64\" - this is for BeaglePlay!</p>"},{"location":"QUICK_START/#test-with-qemu","title":"Test with QEMU","text":"<pre><code># Run ARM64 binary on your x86 PC using QEMU\nqemu-aarch64 -L /usr/aarch64-linux-gnu hello-arm64\n</code></pre> <p>Expected output: <pre><code>Hello from BeaglePlay!\nArchitecture: ARM64/AARCH64\nSystem: Embedded Linux\n</code></pre></p> <p>\ud83c\udf89 Success! You've just cross-compiled your first embedded Linux program!</p>"},{"location":"QUICK_START/#step-4-run-on-real-hardware-5-minutes","title":"Step 4: Run on Real Hardware (5 minutes)","text":""},{"location":"QUICK_START/#transfer-to-beagleplay","title":"Transfer to BeaglePlay","text":"<p>Option A: Via Serial Console (if you have working system on BeaglePlay):</p> <ol> <li>Connect to BeaglePlay serial console</li> <li>Log in (default: <code>debian</code> / <code>temppwd</code>)</li> <li>On your PC, start a simple web server:    <pre><code>python3 -m http.server 8000\n</code></pre></li> <li>On BeaglePlay:    <pre><code>wget http://YOUR_PC_IP:8000/hello-arm64\nchmod +x hello-arm64\n./hello-arm64\n</code></pre></li> </ol> <p>Option B: Via SSH (if network is configured): <pre><code># From your PC\nscp hello-arm64 debian@beagleplay.local:~/\nssh debian@beagleplay.local\n./hello-arm64\n</code></pre></p> <p>Option C: Via microSD Card (manual method): 1. Copy <code>hello-arm64</code> to SD card 2. Insert SD card into BeaglePlay 3. Boot and mount SD card 4. Run the binary</p>"},{"location":"QUICK_START/#what-youve-learned","title":"What You've Learned","text":"<p>\u2705 Hardware: BeaglePlay serial console access \u2705 Cross-Compilation: Building code for different architecture \u2705 Toolchain: Using <code>aarch64-linux-gnu-gcc</code> \u2705 Testing: QEMU user-mode emulation \u2705 Deployment: Transferring binaries to target  </p>"},{"location":"QUICK_START/#common-issues","title":"Common Issues","text":""},{"location":"QUICK_START/#permission-denied-for-devttyacm0","title":"\"Permission denied\" for /dev/ttyACM0","text":"<pre><code># Add yourself to dialout group\nsudo usermod -a -G dialout $USER\n# Then log out and log back in\n</code></pre>"},{"location":"QUICK_START/#qemu-aarch64-could-not-open","title":"\"qemu-aarch64: Could not open...\"","text":"<p>You're using dynamically linked binary. Either:</p> <p>Option 1: Static linking: <pre><code>aarch64-linux-gnu-gcc -static -o hello-arm64 hello.c\nqemu-aarch64 hello-arm64\n</code></pre></p> <p>Option 2: Specify library path: <pre><code>qemu-aarch64 -L /usr/aarch64-linux-gnu hello-arm64\n</code></pre></p>"},{"location":"QUICK_START/#cross-compiler-not-found","title":"Cross-compiler not found","text":"<pre><code># Install the cross-compilation toolchain\nsudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n</code></pre>"},{"location":"QUICK_START/#next-steps","title":"Next Steps","text":"<p>You're ready for the full labs! Choose your path:</p> <ol> <li>Lab 1: Build Custom Toolchain</li> <li>Learn Crosstool-NG</li> <li>Customize toolchain</li> <li> <p>Professional workflow</p> </li> <li> <p>Lab 2: Hardware Discovery</p> </li> <li>BeaglePlay architecture</li> <li>Device Tree basics</li> <li> <p>Peripheral interfaces</p> </li> <li> <p>Continue Reading:</p> </li> <li>Full Lab Structure - All 21 labs</li> <li>BeaglePlay Setup - Detailed hardware guide</li> <li>Training Analysis - How labs were created</li> </ol>"},{"location":"QUICK_START/#congratulations","title":"Congratulations! \ud83c\udf89","text":"<p>You've successfully: - Set up BeaglePlay - Installed cross-compilation tools - Built and tested your first embedded program - Deployed to real hardware</p> <p>Remember: Don't Panic. Embedded Linux is a journey, not a destination.</p> <p>Time invested: ~30 minutes Skills gained: Foundation for embedded development Next milestone: Complete Lab 1 (custom toolchain)</p> <p>Last updated: 2025-01-24 Tested on: Ubuntu 24.04, BeaglePlay Rev A1</p>"},{"location":"ROADMAP/","title":"Learning Roadmap","text":""},{"location":"ROADMAP/#overview","title":"Overview","text":"<p>This document outlines the planned learning progression through different engineering domains.</p>"},{"location":"ROADMAP/#approach","title":"Approach","text":"<ol> <li>Build foundation before advanced topics</li> <li>Incremental complexity</li> <li>Hands-on implementation</li> <li>Cross-domain integration</li> <li>Continuous documentation</li> </ol>"},{"location":"ROADMAP/#learning-phases","title":"Learning Phases","text":"<p>The learning journey is divided into phases. Detailed objectives and topics for each phase will be documented as work progresses.</p>"},{"location":"ROADMAP/#phase-1-foundation-todo","title":"Phase 1: Foundation [TODO]","text":"<ul> <li>Linux fundamentals</li> <li>Version control</li> <li>Development tools</li> </ul>"},{"location":"ROADMAP/#phase-2-build-systems-todo","title":"Phase 2: Build Systems [TODO]","text":"<ul> <li>Make and CMake</li> <li>Cross-compilation</li> <li>Build automation</li> </ul>"},{"location":"ROADMAP/#phase-3-embedded-linux-todo","title":"Phase 3: Embedded Linux [TODO]","text":"<ul> <li>Toolchain setup</li> <li>Kernel compilation</li> <li>Board bring-up</li> </ul>"},{"location":"ROADMAP/#phase-4-yocto-project-todo","title":"Phase 4: Yocto Project [TODO]","text":"<ul> <li>BitBake basics</li> <li>Custom layers</li> <li>Image creation</li> </ul>"},{"location":"ROADMAP/#phase-5-kernel-development-todo","title":"Phase 5: Kernel Development [TODO]","text":"<ul> <li>Module development</li> <li>Debugging techniques</li> <li>Driver development</li> </ul>"},{"location":"ROADMAP/#phase-6-real-time-systems-todo","title":"Phase 6: Real-Time Systems [TODO]","text":"<ul> <li>PREEMPT-RT</li> <li>Latency analysis</li> <li>Real-time optimization</li> </ul>"},{"location":"ROADMAP/#phase-7-devops-integration-todo","title":"Phase 7: DevOps Integration [TODO]","text":"<ul> <li>Infrastructure automation</li> <li>CI/CD pipelines</li> <li>Monitoring</li> </ul>"},{"location":"ROADMAP/#phase-8-advanced-topics-todo","title":"Phase 8: Advanced Topics [TODO]","text":"<ul> <li>Performance optimization</li> <li>Security hardening</li> <li>Network protocols</li> </ul>"},{"location":"ROADMAP/#progress-tracking","title":"Progress Tracking","text":""},{"location":"ROADMAP/#completed","title":"Completed","text":"<ul> <li>[x] Repository structure</li> <li>[x] Documentation templates</li> </ul>"},{"location":"ROADMAP/#in-progress","title":"In Progress","text":"<ul> <li>[x] BeaglePlay lab materials (26 labs)</li> <li>[ ] Initial documentation</li> </ul>"},{"location":"ROADMAP/#planned","title":"Planned","text":"<ul> <li>[ ] Domain-specific learning paths</li> <li>[ ] Integration projects</li> </ul>"},{"location":"ROADMAP/#updates","title":"Updates","text":"<p>This roadmap will be updated as the project evolves.</p> <p>Last Updated: November 2025</p> <p>Or: Learning to Panic Less</p>"},{"location":"ROADMAP/#objectives","title":"Objectives","text":"<p>Build fundamental understanding of Linux systems, version control, and development toolchains.</p>"},{"location":"ROADMAP/#topics","title":"Topics","text":""},{"location":"ROADMAP/#linux-system-fundamentals","title":"Linux System Fundamentals","text":"<ul> <li>File system hierarchy and organization</li> <li>Process management and system calls</li> <li>Shell scripting and automation</li> <li>Package management systems</li> <li>User and permission management</li> </ul>"},{"location":"ROADMAP/#version-control-mastery","title":"Version Control Mastery","text":"<ul> <li>Advanced Git operations</li> <li>Repository management</li> <li>Branch strategies and workflows</li> <li>Collaboration patterns</li> <li>Repository maintenance</li> </ul>"},{"location":"ROADMAP/#development-tools","title":"Development Tools","text":"<ul> <li>GCC compiler toolchain</li> <li>GNU Make fundamentals</li> <li>Debugging with GDB</li> <li>Static analysis tools</li> <li>Performance profiling basics</li> </ul>"},{"location":"ROADMAP/#deliverables","title":"Deliverables","text":"<ul> <li>[ ] Documented Linux command reference</li> <li>[ ] Shell script automation library</li> <li>[ ] Git workflow documentation</li> <li>[ ] Development environment setup guide</li> </ul>"},{"location":"ROADMAP/#success-criteria","title":"Success Criteria","text":"<ul> <li>Comfortable with command-line operations</li> <li>Proficient in Git operations</li> <li>Can write and debug basic C programs</li> <li>Understands compilation and linking process</li> </ul>"},{"location":"ROADMAP/#phase-2-build-systems-months-2-4","title":"Phase 2: Build Systems (Months 2-4)","text":"<p>Or: Understanding What Happens When You Type Make</p>"},{"location":"ROADMAP/#objectives_1","title":"Objectives","text":"<p>Master build system tools and understand software compilation at scale.</p>"},{"location":"ROADMAP/#topics_1","title":"Topics","text":""},{"location":"ROADMAP/#make-and-autotools","title":"Make and Autotools","text":"<ul> <li>Makefile syntax and structure</li> <li>Automatic dependency generation</li> <li>Recursive Make patterns</li> <li>Autoconf and Automake</li> <li>Cross-platform builds</li> </ul>"},{"location":"ROADMAP/#cmake","title":"CMake","text":"<ul> <li>CMakeLists.txt structure</li> <li>Target-based build systems</li> <li>Modern CMake practices</li> <li>Package management with CMake</li> <li>Cross-compilation configuration</li> </ul>"},{"location":"ROADMAP/#advanced-build-concepts","title":"Advanced Build Concepts","text":"<ul> <li>Out-of-tree builds</li> <li>Build system generators</li> <li>Dependency management</li> <li>Build optimization</li> <li>Reproducible builds</li> </ul>"},{"location":"ROADMAP/#deliverables_1","title":"Deliverables","text":"<ul> <li>[ ] CMake project template</li> <li>[ ] Build system comparison analysis</li> <li>[ ] Cross-compilation documentation</li> <li>[ ] Build optimization case studies</li> </ul>"},{"location":"ROADMAP/#success-criteria_1","title":"Success Criteria","text":"<ul> <li>Can structure complex multi-directory builds</li> <li>Understands build system trade-offs</li> <li>Proficient in CMake for projects</li> <li>Can configure cross-compilation toolchains</li> </ul>"},{"location":"ROADMAP/#phase-3-embedded-linux-months-3-6","title":"Phase 3: Embedded Linux (Months 3-6)","text":"<p>Or: Where Real Development Begins</p>"},{"location":"ROADMAP/#objectives_2","title":"Objectives","text":"<p>Develop expertise in embedded Linux systems through hands-on labs and systematic study.</p>"},{"location":"ROADMAP/#topics_2","title":"Topics","text":""},{"location":"ROADMAP/#embedded-linux-fundamentals","title":"Embedded Linux Fundamentals","text":"<ul> <li>Toolchain construction and usage</li> <li>Bootloader configuration (U-Boot)</li> <li>Linux kernel configuration and compilation</li> <li>Root filesystem creation (BusyBox, Buildroot)</li> <li>Device tree basics</li> <li>Flash filesystem usage</li> </ul>"},{"location":"ROADMAP/#cross-compilation","title":"Cross-Compilation","text":"<ul> <li>Toolchain components and ABI</li> <li>Sysroot configuration</li> <li>Library dependencies</li> <li>Static vs dynamic linking</li> <li>Debugging cross-compiled applications</li> </ul>"},{"location":"ROADMAP/#board-bring-up","title":"Board Bring-Up","text":"<ul> <li>Serial console configuration</li> <li>Network booting (TFTP, NFS)</li> <li>Flash memory management</li> <li>Bootloader installation</li> <li>Kernel deployment</li> </ul>"},{"location":"ROADMAP/#deliverables_2","title":"Deliverables","text":"<ul> <li>[ ] Complete embedded Linux lab exercises</li> <li>[ ] Custom embedded Linux system for target hardware</li> <li>[ ] Board bring-up documentation</li> <li>[ ] Toolchain configuration and build guide</li> </ul>"},{"location":"ROADMAP/#success-criteria_2","title":"Success Criteria","text":"<ul> <li>Can build complete embedded Linux system</li> <li>Understands boot process from hardware reset</li> <li>Proficient in U-Boot configuration</li> <li>Can troubleshoot boot failures</li> </ul>"},{"location":"ROADMAP/#phase-4-yocto-project-months-5-8","title":"Phase 4: Yocto Project (Months 5-8)","text":"<p>Or: BitBake - Not As Delicious As It Sounds</p>"},{"location":"ROADMAP/#objectives_3","title":"Objectives","text":"<p>Master the Yocto Project for custom Linux distribution creation.</p>"},{"location":"ROADMAP/#topics_3","title":"Topics","text":""},{"location":"ROADMAP/#yocto-fundamentals","title":"Yocto Fundamentals","text":"<ul> <li>BitBake task execution</li> <li>Recipe syntax and organization</li> <li>Layer architecture</li> <li>Image recipes</li> <li>Package management</li> </ul>"},{"location":"ROADMAP/#custom-layer-development","title":"Custom Layer Development","text":"<ul> <li>Layer design principles</li> <li>Recipe creation and modification</li> <li>Append and prepend operations</li> <li>Configuration file management</li> <li>Machine and distro definitions</li> </ul>"},{"location":"ROADMAP/#advanced-yocto","title":"Advanced Yocto","text":"<ul> <li>SDK generation and deployment</li> <li>Multiconfig builds</li> <li>Recipe debugging</li> <li>Build performance optimization</li> <li>Dependency analysis</li> </ul>"},{"location":"ROADMAP/#deliverables_3","title":"Deliverables","text":"<ul> <li>[ ] Custom Yocto layer</li> <li>[ ] Multiple image configurations</li> <li>[ ] SDK for application development</li> <li>[ ] Build system documentation</li> </ul>"},{"location":"ROADMAP/#success-criteria_3","title":"Success Criteria","text":"<ul> <li>Can create custom Yocto layers</li> <li>Understands BitBake execution model</li> <li>Can generate and deploy SDKs</li> <li>Proficient in recipe debugging</li> </ul>"},{"location":"ROADMAP/#phase-5-kernel-development-months-6-10","title":"Phase 5: Kernel Development (Months 6-10)","text":"<p>Or: Where the Real Magic (and Segfaults) Happen</p>"},{"location":"ROADMAP/#objectives_4","title":"Objectives","text":"<p>Develop Linux kernel modules and understand kernel internals.</p>"},{"location":"ROADMAP/#topics_4","title":"Topics","text":""},{"location":"ROADMAP/#kernel-module-development","title":"Kernel Module Development","text":"<ul> <li>Module structure and lifecycle</li> <li>Character device drivers</li> <li>Platform drivers and device tree</li> <li>Interrupt handling</li> <li>DMA operations</li> </ul>"},{"location":"ROADMAP/#kernel-debugging","title":"Kernel Debugging","text":"<ul> <li>printk and dynamic debug</li> <li>KGDB remote debugging</li> <li>Ftrace and trace events</li> <li>Perf profiling</li> <li>Crash dump analysis</li> </ul>"},{"location":"ROADMAP/#advanced-kernel-topics","title":"Advanced Kernel Topics","text":"<ul> <li>Concurrency and locking</li> <li>Memory management</li> <li>Kernel timers and workqueues</li> <li>Power management</li> <li>Real-time considerations</li> </ul>"},{"location":"ROADMAP/#deliverables_4","title":"Deliverables","text":"<ul> <li>[ ] Character device driver implementation</li> <li>[ ] Platform driver with device tree binding</li> <li>[ ] Kernel debugging methodology document</li> <li>[ ] Performance analysis case studies</li> </ul>"},{"location":"ROADMAP/#success-criteria_4","title":"Success Criteria","text":"<ul> <li>Can develop and debug kernel modules</li> <li>Understands kernel synchronization primitives</li> <li>Proficient with kernel tracing tools</li> <li>Can analyze kernel crashes</li> </ul>"},{"location":"ROADMAP/#phase-6-real-time-systems-months-9-12","title":"Phase 6: Real-Time Systems (Months 9-12)","text":"<p>Or: When Microseconds Matter More Than Vogon Poetry</p>"},{"location":"ROADMAP/#objectives_5","title":"Objectives","text":"<p>Investigate real-time Linux capabilities and determinism.</p>"},{"location":"ROADMAP/#topics_5","title":"Topics","text":""},{"location":"ROADMAP/#preempt-rt","title":"PREEMPT-RT","text":"<ul> <li>Real-time patch set</li> <li>Priority inheritance</li> <li>Threaded interrupts</li> <li>Latency measurement</li> <li>Configuration optimization</li> </ul>"},{"location":"ROADMAP/#real-time-analysis","title":"Real-Time Analysis","text":"<ul> <li>Cyclictest and rt-tests</li> <li>Latency sources identification</li> <li>IRQ affinity and isolation</li> <li>CPU isolation techniques</li> <li>Scheduler analysis</li> </ul>"},{"location":"ROADMAP/#alternative-approaches","title":"Alternative Approaches","text":"<ul> <li>Xenomai dual-kernel</li> <li>Linux microkernel patterns</li> <li>Bare-metal comparison</li> <li>Hybrid architectures</li> </ul>"},{"location":"ROADMAP/#deliverables_5","title":"Deliverables","text":"<ul> <li>[ ] PREEMPT-RT system configuration</li> <li>[ ] Latency benchmarking suite</li> <li>[ ] Real-time optimization guide</li> <li>[ ] Comparative analysis document</li> </ul>"},{"location":"ROADMAP/#success-criteria_5","title":"Success Criteria","text":"<ul> <li>Can configure and measure real-time performance</li> <li>Understands determinism trade-offs</li> <li>Can optimize for latency requirements</li> <li>Familiar with alternative RT approaches</li> </ul>"},{"location":"ROADMAP/#phase-7-devops-integration-months-10-14","title":"Phase 7: DevOps Integration (Months 10-14)","text":"<p>Or: The Restaurant at the End of the Build Process</p>"},{"location":"ROADMAP/#objectives_6","title":"Objectives","text":"<p>Build automated infrastructure for development, testing, and deployment.</p>"},{"location":"ROADMAP/#topics_6","title":"Topics","text":""},{"location":"ROADMAP/#infrastructure-as-code","title":"Infrastructure as Code","text":"<ul> <li>Terraform for infrastructure provisioning</li> <li>Ansible for configuration management</li> <li>Docker containerization</li> <li>Container orchestration basics</li> <li>Network automation</li> </ul>"},{"location":"ROADMAP/#cicd-pipelines","title":"CI/CD Pipelines","text":"<ul> <li>Jenkins pipeline configuration</li> <li>GitLab CI/CD</li> <li>GitHub Actions</li> <li>Automated testing integration</li> <li>Artifact management</li> </ul>"},{"location":"ROADMAP/#monitoring-and-observability","title":"Monitoring and Observability","text":"<ul> <li>Prometheus metrics collection</li> <li>Grafana visualization</li> <li>Log aggregation</li> <li>Alerting configuration</li> <li>Performance monitoring</li> </ul>"},{"location":"ROADMAP/#deliverables_6","title":"Deliverables","text":"<ul> <li>[ ] Homelab infrastructure design</li> <li>[ ] Automated build and test pipeline</li> <li>[ ] Monitoring dashboard</li> <li>[ ] Deployment automation documentation</li> </ul>"},{"location":"ROADMAP/#success-criteria_6","title":"Success Criteria","text":"<ul> <li>Operational homelab infrastructure</li> <li>Automated testing for all projects</li> <li>Comprehensive monitoring in place</li> <li>Can deploy and manage containerized applications</li> </ul>"},{"location":"ROADMAP/#phase-8-advanced-topics-months-12","title":"Phase 8: Advanced Topics (Months 12+)","text":"<p>Or: Life, the Universe, and Performance Optimization</p>"},{"location":"ROADMAP/#objectives_7","title":"Objectives","text":"<p>Explore specialized areas and integrate knowledge across domains.</p>"},{"location":"ROADMAP/#topics_7","title":"Topics","text":""},{"location":"ROADMAP/#performance-engineering","title":"Performance Engineering","text":"<ul> <li>System-level profiling</li> <li>Cache analysis</li> <li>Memory optimization</li> <li>I/O performance tuning</li> <li>Power consumption analysis</li> </ul>"},{"location":"ROADMAP/#security","title":"Security","text":"<ul> <li>Secure boot implementation</li> <li>Trusted execution environments</li> <li>Cryptographic operations</li> <li>Vulnerability analysis</li> <li>Security hardening</li> </ul>"},{"location":"ROADMAP/#networking","title":"Networking","text":"<ul> <li>Protocol implementation</li> <li>Network stack optimization</li> <li>Custom protocol development</li> <li>Performance analysis</li> <li>Software-defined networking</li> </ul>"},{"location":"ROADMAP/#deliverables_7","title":"Deliverables","text":"<ul> <li>[ ] Performance optimization case studies</li> <li>[ ] Security hardening procedures</li> <li>[ ] Network protocol implementation</li> <li>[ ] Integration project combining multiple domains</li> </ul>"},{"location":"ROADMAP/#success-criteria_7","title":"Success Criteria","text":"<ul> <li>Can perform comprehensive performance analysis</li> <li>Understands security implications of design decisions</li> <li>Can implement and debug network protocols</li> <li>Successfully integrates knowledge across domains</li> </ul>"},{"location":"ROADMAP/#progress-tracking_1","title":"Progress Tracking","text":""},{"location":"ROADMAP/#completed_1","title":"Completed","text":"<ul> <li>[x] Repository structure</li> <li>[x] Documentation templates</li> </ul>"},{"location":"ROADMAP/#in-progress_1","title":"In Progress","text":"<ul> <li>[x] BeaglePlay lab materials (26 labs)</li> <li>[ ] Initial documentation</li> </ul>"},{"location":"ROADMAP/#planned_1","title":"Planned","text":"<ul> <li>[ ] Domain-specific learning paths</li> <li>[ ] Integration projects</li> </ul>"},{"location":"ROADMAP/#updates_1","title":"Updates","text":"<p>This roadmap will be updated as the project evolves.</p> <p>Last Updated: November 2025</p>"},{"location":"THE-JOURNEY/","title":"The Journey","text":"<p>Date: November 2025 Status: Beginning</p>"},{"location":"THE-JOURNEY/#philosophy-dont-panic","title":"Philosophy: Don't Panic","text":"<p>This repository represents a systematic approach to learning systems engineering. Instead of scattered projects and fragmented knowledge, everything is organized, documented, and interconnected.</p>"},{"location":"THE-JOURNEY/#the-questions","title":"The Questions","text":"<p>Key questions this journey seeks to answer:</p> <ul> <li>How do embedded Linux systems actually work?</li> <li>What happens during the build process?</li> <li>How do you debug kernel-level issues?</li> <li>How do you create custom Linux distributions?</li> <li>How do you automate infrastructure?</li> </ul> <p>The answers come through hands-on experimentation and documentation.</p>"},{"location":"THE-JOURNEY/#hardware-platforms","title":"Hardware Platforms","text":"<p>Available hardware platforms: - Raspberry Pi (multiple models) - Raspberry Pi Pico (RP2040) - BeaglePlay - Arduino boards - ESP32 development boards</p> <p>Detailed inventory will be documented in future hardware documentation.</p>"},{"location":"THE-JOURNEY/#approach","title":"Approach","text":"<p>This repository focuses on:</p> <ul> <li>Accurate, reproducible documentation</li> <li>Systematic learning progression</li> <li>Practical implementation</li> <li>Learning from both successes and failures</li> </ul>"},{"location":"THE-JOURNEY/#repository-organization","title":"Repository Organization","text":"<p>The repository organizes training content into focused tracks and domains, all contained within the main repository for ease of use.</p>"},{"location":"THE-JOURNEY/#documentation-standards","title":"Documentation Standards","text":"<p>All work follows consistent templates and standards:</p> <ul> <li>Standardized templates in <code>docs/templates/</code></li> <li>Documentation standards in <code>docs/standards/</code></li> <li>Scientific methodology for experiments</li> <li>Complete documentation of procedures and results</li> </ul>"},{"location":"THE-JOURNEY/#core-principles","title":"Core Principles","text":"<ol> <li>Don't Panic: When things break, analyze methodically</li> <li>Document Everything: Future you will thank present you</li> <li>Reproducibility: Every procedure should be repeatable</li> <li>Learn from Failures: Document what doesn't work and why</li> </ol>"},{"location":"THE-JOURNEY/#references","title":"References","text":"<p>See BIBLIOGRAPHY.md for a comprehensive list of references and resources.</p>"},{"location":"THE-JOURNEY/#integration-goal","title":"Integration Goal","text":"<p>The DevOps homelab will serve as the integration point, providing:</p> <ul> <li>Automated build and test infrastructure</li> <li>Cross-compilation support</li> <li>Container orchestration</li> <li>Monitoring and metrics</li> <li>Documentation hosting</li> </ul> <p>Detailed plans will be added in future documentation.</p>"},{"location":"THE-JOURNEY/#value-proposition","title":"Value Proposition","text":"<p>This repository's value comes from:</p> <ul> <li>Systematic documentation</li> <li>Reproducible procedures</li> <li>Learning from failures</li> <li>Building interconnected knowledge</li> </ul>"},{"location":"THE-JOURNEY/#status","title":"Status","text":"<p>Date: November 2025 Phase: Initial Setup</p> <p>Completed: - Repository structure - Documentation standards - Template creation - Repository structure planning</p>"},{"location":"THE-JOURNEY/#next-steps","title":"Next Steps","text":"<ol> <li>Expand hardware platform documentation</li> <li>Begin embedded Linux labs</li> <li>Set up initial homelab infrastructure</li> <li>Document first complete system bring-up</li> </ol> <p>Last Updated: November 2025</p>"},{"location":"THE-JOURNEY/#remember","title":"Remember","text":"<p>Don't Panic. Document Everything. Learn Continuously.</p>"},{"location":"TRAINING_ANALYSIS/","title":"Training Materials Analysis Summary","text":"<p>Date: 2025-01-24 Target Platform: BeaglePlay Status: Analysis complete, adaptation in progress</p>"},{"location":"TRAINING_ANALYSIS/#overview","title":"Overview","text":"<p>This document summarizes the analysis of professional embedded Linux training materials and how they've been adapted for the hitchhikers-guide-to-developing repository.</p> <p>Important: All content in this repository is original work. The training materials were analyzed to understand best practices and learning progression, but all labs and documentation are newly created.</p>"},{"location":"TRAINING_ANALYSIS/#source-material-structure","title":"Source Material Structure","text":""},{"location":"TRAINING_ANALYSIS/#1-embedded-linux-training-beagleplay-variant","title":"1. Embedded Linux Training (BeaglePlay variant)","text":"<p>Duration: 7 half-days (28 hours) Level: Beginner to Intermediate</p> <p>Topics Covered: 1. Toolchain - Cross-compilation setup with Crosstool-NG 2. Hardware - Board bring-up, serial console, Device Tree basics 3. Bootloader - U-Boot configuration and usage 4. Kernel - Linux kernel configuration, building, Device Tree 5. Tiny System - Minimal root filesystem with BusyBox 6. Block Filesystems - ext4, partitioning, fstab 7. Flash Filesystems - SquashFS, UBIFS, overlays 8. Buildroot - Automated build system 9. Application Development - Cross-compilation, debugging, hardware access</p> <p>Lab Data Structure: <pre><code>embedded-linux-beagleplay-labs/\n\u251c\u2500\u2500 toolchain/\n\u2502   \u2514\u2500\u2500 hello.c\n\u251c\u2500\u2500 hardware/\n\u2502   \u2514\u2500\u2500 data/\n\u2502       \u2514\u2500\u2500 nunchuk/nunchuk.c\n\u251c\u2500\u2500 bootloader/\n\u2502   \u2514\u2500\u2500 data/\n\u251c\u2500\u2500 tinysystem/\n\u2502   \u2514\u2500\u2500 data/\n\u2502       \u251c\u2500\u2500 hello.c\n\u2502       \u2514\u2500\u2500 www/cgi-bin/upload.c\n\u251c\u2500\u2500 buildroot/\n\u2502   \u2514\u2500\u2500 data/music/\n\u2514\u2500\u2500 appdev/\n    \u251c\u2500\u2500 nunchuk-mpd-client.c\n    \u2514\u2500\u2500 prep-debug.sh\n</code></pre></p> <p>Key Labs: - Custom toolchain for ARM64 (Cortex-A53) - U-Boot customization for network boot - Device Tree modifications for Nunchuk I2C controller - BusyBox-based minimal system (~10 MB) - Buildroot automated builds - Remote debugging with gdbserver</p>"},{"location":"TRAINING_ANALYSIS/#2-yocto-project-training-beagleplay-variant","title":"2. Yocto Project Training (BeaglePlay variant)","text":"<p>Duration: 4 half-days (16 hours) Level: Intermediate (requires Linux experience)</p> <p>Topics Covered: 1. Yocto Introduction - Architecture, BitBake, layers 2. Basic Configuration - Local.conf, machine files, image types 3. Recipes - Writing .bb files, tasks, dependencies 4. Layers - Custom layers, bbappend, layer priorities 5. BSP - Board support packages, kernel recipes 6. SDK - Yocto SDK generation and usage 7. devtool - Recipe development workflow</p> <p>Lab Data: <pre><code>yocto-beagleplay-labs/\n\u2514\u2500\u2500 bootlin-lab-data/\n    \u2514\u2500\u2500 nunchuk/\n        \u251c\u2500\u2500 linux/        # Kernel driver\n        \u2514\u2500\u2500 ninvaders/    # Demo application\n</code></pre></p> <p>Key Labs: - Poky setup and first image build - Custom recipe for Nunchuk driver - Custom layer creation (meta-custom) - SDK usage for application development - devtool workflow</p>"},{"location":"TRAINING_ANALYSIS/#3-linux-debugging-training","title":"3. Linux Debugging Training","text":"<p>Duration: 4 half-days (16 hours) Level: Intermediate to Advanced</p> <p>Topics Covered: 1. System Analysis - Load analysis, CPU/memory profiling 2. GDB - Application debugging, remote debugging, core dumps 3. Tracing - strace, ltrace, function tracing 4. Performance - perf, Callgrind, flame graphs 5. Memory Issues - valgrind, Massif, heap profiling 6. System Tracing - ftrace, trace-cmd, KernelShark 7. eBPF - BCC tools, bpftrace, libbpf 8. Kernel Debugging - KGDB, crash analysis, kmemleak, lockdep</p> <p>Lab Data: <pre><code>debugging-labs/\n\u2514\u2500\u2500 nfsroot/\n    \u2514\u2500\u2500 root/\n        \u251c\u2500\u2500 gdb/\n        \u251c\u2500\u2500 ltrace/\n        \u251c\u2500\u2500 strace/ (implied)\n        \u251c\u2500\u2500 valgrind/\n        \u251c\u2500\u2500 heap_profile/\n        \u251c\u2500\u2500 app_profiling/\n        \u251c\u2500\u2500 system_profiling/\n        \u251c\u2500\u2500 sched_intensive/\n        \u251c\u2500\u2500 compiler_explorer/\n        \u251c\u2500\u2500 ebpf/\n        \u2502   \u251c\u2500\u2500 libbpf/\n        \u2502   \u2514\u2500\u2500 libbpf_advanced/\n        \u251c\u2500\u2500 kgdb/\n        \u251c\u2500\u2500 kmemleak/\n        \u2514\u2500\u2500 locking/\n</code></pre></p> <p>Key Labs: - Remote debugging with GDB and VS Code - Memory leak detection with valgrind - CPU profiling with perf - Custom eBPF programs with bpftrace - Kernel crash analysis - Lock contention debugging</p>"},{"location":"TRAINING_ANALYSIS/#adaptation-strategy","title":"Adaptation Strategy","text":""},{"location":"TRAINING_ANALYSIS/#what-was-kept","title":"What Was Kept","text":"<p>Learning Progression: - Logical flow from basics to advanced topics - Hands-on lab-based approach - Incremental complexity - Real hardware focus</p> <p>Technical Depth: - Professional-level detail - Industry-standard tools - Best practices emphasis - Troubleshooting guidance</p> <p>Platform Focus: - BeaglePlay as primary target (matching source material) - ARM64/AARCH64 architecture - Real embedded use cases</p>"},{"location":"TRAINING_ANALYSIS/#what-was-changed","title":"What Was Changed","text":"<p>Content Creation: - \u274c No copying of lab instructions (all rewritten) - \u274c No use of proprietary slides/PDFs - \u2705 Original documentation and explanations - \u2705 Custom examples and code samples - \u2705 Personal learning journey emphasis</p> <p>Structure: - Added \"Don't Panic\" theme (Hitchhiker's Guide) - Integrated with repository philosophy - Added optional challenges and extensions - Created comprehensive reference documentation - Added troubleshooting based on common issues</p> <p>Scope Expansion: - Added DevOps homelab integration (not in source) - Multiple hardware platforms (Pi, Pico, ESP32) - Long-term research repository vs single course - Community-focused vs commercial training</p>"},{"location":"TRAINING_ANALYSIS/#adapted-lab-structure","title":"Adapted Lab Structure","text":""},{"location":"TRAINING_ANALYSIS/#embedded-linux-track-labs-1-9","title":"Embedded Linux Track (Labs 1-9)","text":"Lab Original Topic Adapted Title Key Changes 1 Toolchain Cross-Compilation Toolchain Expanded troubleshooting, added QEMU testing 2 Hardware Hardware Discovery Added BeaglePlay-specific features, expansion connectors 3 Bootloader U-Boot Added boot mode details, eMMC flashing 4 Kernel Linux Kernel Expanded Device Tree documentation 5 Tiny System Root Filesystem - Tiny System Added init system details 6 Block FS Block Filesystems Added partition scheme planning 7 Flash FS Flash Filesystems Added OverlayFS for read-only rootfs 8 Buildroot Buildroot Added external tree structure 9 AppDev Application Development Added libgpiod, modern tools"},{"location":"TRAINING_ANALYSIS/#yocto-track-labs-10-14","title":"Yocto Track (Labs 10-14)","text":"Lab Original Topic Adapted Title Key Changes 10 Introduction Yocto Introduction Added comparison to Buildroot 11 Recipes Custom Recipes Expanded recipe syntax examples 12 Layers Custom Layers Added layer organization best practices 13 BSP BSP and Kernel Added Device Tree overlay workflow 14 SDK SDK and devtool Added eSDK comparison"},{"location":"TRAINING_ANALYSIS/#debugging-track-labs-15-21","title":"Debugging Track (Labs 15-21)","text":"Lab Original Topic Adapted Title Key Changes 15 System Analysis System Profiling Added modern tools (htop, glances) 16 GDB Application Debugging - GDB Added VS Code integration 17 Tracing Tracing - strace/ltrace Added filtering techniques 18 Perf Performance Analysis - perf Added flame graph generation 19 Valgrind Memory Debugging - Valgrind Added sanitizer alternatives 20 ftrace/eBPF Advanced Tracing Expanded eBPF programming 21 Kernel Debug Kernel Debugging Added crash utility usage"},{"location":"TRAINING_ANALYSIS/#hardware-adaptation","title":"Hardware Adaptation","text":""},{"location":"TRAINING_ANALYSIS/#source-platforms","title":"Source Platforms","text":"<ul> <li>Embedded Linux: BeaglePlay</li> <li>Yocto: BeaglePlay + STM32MP157 Discovery</li> <li>Debugging: STM32MP157 Discovery</li> </ul>"},{"location":"TRAINING_ANALYSIS/#target-platforms","title":"Target Platforms","text":"<p>Our repository focuses on: - Primary: BeaglePlay (matches source, well-supported) - Secondary: Raspberry Pi (popular, community resources) - Additional: Raspberry Pi Pico, Arduino, ESP32 (IoT/MCU)</p> <p>Rationale: BeaglePlay is industrial-focused with excellent documentation and expansion options, making it ideal for serious embedded Linux learning.</p>"},{"location":"TRAINING_ANALYSIS/#technical-differences","title":"Technical Differences","text":""},{"location":"TRAINING_ANALYSIS/#toolchain","title":"Toolchain","text":"<p>Source: Crosstool-NG with musl C library Adapted: Same approach, but documented alternatives: - Linaro pre-built toolchains - Buildroot-generated toolchains - Yocto SDK - Distribution packages (Debian/Ubuntu crossbuild-essential)</p>"},{"location":"TRAINING_ANALYSIS/#build-systems","title":"Build Systems","text":"<p>Source: Buildroot (embedded Linux), Yocto (Yocto course) Adapted: Both covered, plus: - Custom Makefiles (understanding fundamentals) - CMake for applications - Meson (modern alternative)</p>"},{"location":"TRAINING_ANALYSIS/#debugging-tools","title":"Debugging Tools","text":"<p>Source: gdb, perf, ftrace, eBPF, valgrind Adapted: Same tools, plus: - AddressSanitizer (ASAN) - ThreadSanitizer (TSAN) - UndefinedBehaviorSanitizer (UBSAN) - rr (record/replay debugging)</p>"},{"location":"TRAINING_ANALYSIS/#lab-data-requirements","title":"Lab Data Requirements","text":""},{"location":"TRAINING_ANALYSIS/#what-you-need-to-create","title":"What You Need to Create","text":"<p>Per Lab: 1. README.md - Lab instructions (following template) 2. Source Code - Original example programs 3. Scripts - Helper scripts for automation 4. Configuration Files - Device Trees, kernel configs, etc. 5. Test Data - Sample files for testing</p> <p>Example for Lab 1 (Toolchain): <pre><code>labX-toolchain/\n\u251c\u2500\u2500 README.md           # Lab instructions\n\u251c\u2500\u2500 hello.c             # Simple test program\n\u251c\u2500\u2500 Makefile           # Build automation\n\u251c\u2500\u2500 test-toolchain.sh  # Verification script\n\u2514\u2500\u2500 configs/\n    \u2514\u2500\u2500 crosstool-ng-config  # Crosstool-NG configuration\n</code></pre></p>"},{"location":"TRAINING_ANALYSIS/#source-code-samples","title":"Source Code Samples","text":"<p>From analysis: - <code>hello.c</code> - Simple \"Hello World\" (easy to recreate) - <code>nunchuk.c</code> - I2C Nunchuk driver (example hardware interaction) - <code>nunchuk-mpd-client.c</code> - Application using I2C device - <code>upload.c</code> - CGI program for web interface</p> <p>Our approach: - Create our own examples with similar functionality - Document hardware interfacing patterns - Provide multiple variations (simple \u2192 complex)</p>"},{"location":"TRAINING_ANALYSIS/#time-investment-estimates","title":"Time Investment Estimates","text":""},{"location":"TRAINING_ANALYSIS/#course-vs-self-learning","title":"Course vs Self-Learning","text":"Track Course Time Self-Learning Reason for Difference Embedded Linux 28 hours 35-45 hours Troubleshooting, documentation Yocto 16 hours 25-30 hours Long build times, complexity Debugging 16 hours 20-25 hours Tool exploration, practice Total 60 hours 80-100 hours Self-paced, deeper exploration <p>Additional Time: - Hardware setup: 2-4 hours - Reading documentation: 10-15 hours - Optional challenges: Variable - Realistic Total: 100-120 hours</p>"},{"location":"TRAINING_ANALYSIS/#implementation-status","title":"Implementation Status","text":""},{"location":"TRAINING_ANALYSIS/#completed","title":"\u2705 Completed","text":"<ul> <li>[x] Analysis of source materials</li> <li>[x] Lab structure definition (21 labs across 3 tracks)</li> <li>[x] Hardware documentation (BeaglePlay setup guide)</li> <li>[x] Lab template creation</li> <li>[x] MkDocs navigation structure</li> <li>[x] Learning progression planning</li> </ul>"},{"location":"TRAINING_ANALYSIS/#in-progress","title":"\ud83d\udd04 In Progress","text":"<ul> <li>[ ] Lab 1 (Toolchain) - Next to create</li> <li>[ ] Lab 2 (Hardware Discovery)</li> <li>[ ] Lab 3 (U-Boot Bootloader)</li> </ul>"},{"location":"TRAINING_ANALYSIS/#planned","title":"\ud83d\udccb Planned","text":"<ul> <li>[ ] Labs 4-21 (following LAB_STRUCTURE.md)</li> <li>[ ] Create GitHub repo for each lab (optional)</li> <li>[ ] Generate lab data files</li> <li>[ ] Create video tutorials (optional)</li> <li>[ ] Build community contributions</li> </ul>"},{"location":"TRAINING_ANALYSIS/#intellectual-property-notes","title":"Intellectual Property Notes","text":""},{"location":"TRAINING_ANALYSIS/#what-we-cannot-do","title":"What We Cannot Do","text":"<p>\u274c Redistribute their PDF materials \u274c Use their exact lab instructions \u274c Claim affiliation or certification  </p>"},{"location":"TRAINING_ANALYSIS/#what-we-can-do","title":"What We Can Do","text":"<p>\u2705 Learn from their training structure \u2705 Use same open-source tools (U-Boot, Linux, Buildroot, Yocto) \u2705 Target same hardware (BeaglePlay is a public board) \u2705 Create original documentation on same topics \u2705 Reference their free resources (with attribution)  </p> <p>This means we CAN use them with attribution, as long as we: 2. Link to their repository 3. Use the same CC-BY-SA license 4. Note any changes we make</p> <p>However, we're creating original content to learn through doing, not just copying.</p>"},{"location":"TRAINING_ANALYSIS/#next-steps","title":"Next Steps","text":"<ol> <li>Create Lab 1 (Toolchain)</li> <li>Write complete lab instructions</li> <li>Create test programs</li> <li>Document troubleshooting</li> <li> <p>Test on clean Ubuntu 24.04</p> </li> <li> <p>Set Up Lab Infrastructure</p> </li> <li>Create <code>embedded-linux-labs</code> repository</li> <li>Organize within main repository</li> <li> <p>Create directory structure</p> </li> <li> <p>Document as You Go</p> </li> <li>Take screenshots</li> <li>Note issues encountered</li> <li>Document solutions</li> <li> <p>Update main repository</p> </li> <li> <p>Build Learning Community</p> </li> <li>Share progress on GitHub</li> <li>Accept contributions</li> <li>Create issue templates</li> <li>Welcome feedback</li> </ol>"},{"location":"TRAINING_ANALYSIS/#references","title":"References","text":"<ul> <li>BeagleBoard Documentation: https://docs.beagleboard.org/</li> <li>Yocto Project: https://www.yoctoproject.org/docs/</li> <li>Buildroot Manual: https://buildroot.org/downloads/manual/manual.html</li> <li>Linux Kernel Documentation: https://www.kernel.org/doc/html/latest/</li> </ul> <p>Analysis completed: 2025-01-24 Analyst: GitHub Copilot Next action: Begin Lab 1 implementation</p>"},{"location":"labs/debugging/","title":"Linux Debugging Labs - Index","text":"<p>Target Platform: BeaglePlay (TI AM62x Cortex-A53) Total Labs: 7 Estimated Time: 25-30 hours Difficulty: Intermediate to Advanced</p>"},{"location":"labs/debugging/#overview","title":"Overview","text":"<p>This series of labs teaches debugging, profiling, and performance analysis for Linux systems. All labs are adapted for BeaglePlay with original examples.</p>"},{"location":"labs/debugging/#coming-soon","title":"Coming Soon","text":"<p>Linux Debugging labs are currently in development. These labs will cover:</p> <ul> <li>Lab 15: System Profiling</li> <li>Lab 16: GDB Debugging</li> <li>Lab 17: strace/ltrace</li> <li>Lab 18: perf Analysis</li> <li>Lab 19: valgrind</li> <li>Lab 20: ftrace and eBPF</li> <li>Lab 21: Kernel Debugging</li> </ul> <p>Prerequisites: Complete Embedded Linux Labs 1-9 first.</p> <p>Status: In Development Expected completion: Q1 2026</p>"},{"location":"labs/debugging/lab19-system-monitoring/","title":"Lab 19: System Monitoring and Resource Analysis","text":""},{"location":"labs/debugging/lab19-system-monitoring/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/debugging/lab19-system-monitoring/#objectives","title":"Objectives","text":"<p>Master essential Linux system monitoring tools to analyze process behavior, memory usage, I/O performance, and network activity.</p> <p>What You'll Learn: - Monitor running processes with <code>ps</code> and <code>top</code> - Analyze memory allocation using <code>/proc</code> filesystem and <code>pmap</code> - Track I/O performance with <code>iostat</code> and <code>iotop</code> - Monitor virtual memory with <code>vmstat</code> - Analyze network activity with <code>netstat</code> and <code>ss</code> - Understand system resource bottlenecks</p> <p>Time Required: 2-3 hours (or approximately 42 minutes in improbable circumstances)</p>"},{"location":"labs/debugging/lab19-system-monitoring/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board (TI AM62x) - Development workstation - Network connection</p> <p>Software: - Working Linux system on BeaglePlay (from previous labs) - SSH access - Root privileges</p>"},{"location":"labs/debugging/lab19-system-monitoring/#1-process-monitoring-with-ps","title":"1. Process Monitoring with ps","text":""},{"location":"labs/debugging/lab19-system-monitoring/#11-understanding-ps","title":"1.1 Understanding ps","text":"<p><code>ps</code> displays snapshot of current processes.</p> <p>Basic usage: <pre><code># All processes\nps aux\n\n# Process tree\nps auxf\n\n# Specific user\nps -u root\n\n# Custom format\nps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#12-analyze-running-processes","title":"1.2 Analyze Running Processes","text":"<p>On BeaglePlay: <pre><code>ssh root@192.168.0.100\nps aux\n</code></pre></p> <p>Output columns: <pre><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.3   5324  3208 ?        Ss   10:00   0:01 /sbin/init\nroot       123  0.1  1.2  45632 12048 ?        Ssl  10:00   0:05 /usr/bin/systemd\n</code></pre></p> <p>Key columns: - PID: Process ID - %CPU: CPU usage percentage - %MEM: Memory usage percentage - VSZ: Virtual memory size (KB) - RSS: Resident Set Size (physical RAM, KB) - STAT: Process state (R=running, S=sleeping, Z=zombie)</p>"},{"location":"labs/debugging/lab19-system-monitoring/#13-find-resource-heavy-processes","title":"1.3 Find Resource-Heavy Processes","text":"<pre><code># Top 10 CPU consumers\nps aux --sort=-%cpu | head -11\n\n# Top 10 memory consumers\nps aux --sort=-%mem | head -11\n\n# Processes using most threads\nps -eLf | awk '{print $4}' | sort | uniq -c | sort -nr | head -10\n</code></pre>"},{"location":"labs/debugging/lab19-system-monitoring/#2-real-time-monitoring-with-top","title":"2. Real-Time Monitoring with top","text":""},{"location":"labs/debugging/lab19-system-monitoring/#21-interactive-top-usage","title":"2.1 Interactive top Usage","text":"<pre><code>top\n</code></pre> <p>Output: <pre><code>top - 10:30:15 up 2:15,  1 user,  load average: 0.08, 0.12, 0.10\nTasks:  95 total,   1 running,  94 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  2.1 us,  0.8 sy,  0.0 ni, 96.9 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st\nMiB Mem :   1987.2 total,   1234.5 free,    345.2 used,    407.5 buff/cache\nMiB Swap:      0.0 total,      0.0 free,      0.0 used.   1567.8 avail Mem \n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\n  456 root      20   0  123456  45678  12345 S   5.2   2.3   0:12.34 my-app\n  123 root      20   0   98765  23456   8765 S   1.2   1.2   0:05.67 systemd\n</code></pre></p> <p>Interactive commands: - <code>k</code>: Kill process - <code>r</code>: Renice process - <code>M</code>: Sort by memory - <code>P</code>: Sort by CPU - <code>1</code>: Show individual CPU cores - <code>c</code>: Show full command - <code>q</code>: Quit</p>"},{"location":"labs/debugging/lab19-system-monitoring/#22-top-command-line-options","title":"2.2 top Command-Line Options","text":"<pre><code># Update every 2 seconds\ntop -d 2\n\n# Show specific user\ntop -u nginx\n\n# Batch mode (for logging)\ntop -b -n 1 &gt; system-snapshot.txt\n\n# Monitor specific processes\ntop -p 123,456,789\n</code></pre>"},{"location":"labs/debugging/lab19-system-monitoring/#23-understanding-load-average","title":"2.3 Understanding Load Average","text":"<p>Load average: <code>0.08, 0.12, 0.10</code> - Last 1 minute: 0.08 - Last 5 minutes: 0.12 - Last 15 minutes: 0.10</p> <p>BeaglePlay has 4 CPU cores: - Load &lt; 4.0: System handling load well - Load &gt; 4.0: Processes waiting for CPU</p>"},{"location":"labs/debugging/lab19-system-monitoring/#3-memory-analysis-with-proc","title":"3. Memory Analysis with /proc","text":""},{"location":"labs/debugging/lab19-system-monitoring/#31-system-wide-memory-info","title":"3.1 System-Wide Memory Info","text":"<pre><code>cat /proc/meminfo\n</code></pre> <p>Output: <pre><code>MemTotal:        2035456 kB\nMemFree:         1264128 kB\nMemAvailable:    1605632 kB\nBuffers:          56832 kB\nCached:          352256 kB\nSwapCached:           0 kB\nActive:          425984 kB\nInactive:        201728 kB\n</code></pre></p> <p>Key metrics: - MemTotal: Total physical RAM - MemFree: Unused RAM - MemAvailable: RAM available for applications (includes reclaimable cache) - Cached: Page cache (file data) - Buffers: Block device buffers</p>"},{"location":"labs/debugging/lab19-system-monitoring/#32-per-process-memory","title":"3.2 Per-Process Memory","text":"<pre><code># Memory usage of PID 456\ncat /proc/456/status | grep -E \"VmSize|VmRSS|VmData\"\n</code></pre> <p>Output: <pre><code>VmSize:    123456 kB  # Virtual memory\nVmRSS:      45678 kB  # Physical RAM\nVmData:     34567 kB  # Private data\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#33-memory-maps-with-pmap","title":"3.3 Memory Maps with pmap","text":"<pre><code># Show memory map of process\npmap -x 456\n</code></pre> <p>Output: <pre><code>Address           Kbytes     RSS   Dirty Mode  Mapping\n0000aaaab0000000    1024    1024       0 r-x-- my-app\n0000aaaab0100000      64      64      64 rw--- my-app\n0000ffff80000000   1856     128       0 r-x-- libc-2.31.so\n0000ffff801d0000      64      64      64 rw--- libc-2.31.so\n</code></pre></p> <p>Columns: - RSS: Resident memory (in RAM) - Dirty: Modified pages - Mode: Permissions (r=read, w=write, x=execute)</p>"},{"location":"labs/debugging/lab19-system-monitoring/#4-io-performance-with-iostat","title":"4. I/O Performance with iostat","text":""},{"location":"labs/debugging/lab19-system-monitoring/#41-install-sysstat-package","title":"4.1 Install sysstat Package","text":"<pre><code># If not already installed\nopkg install sysstat\n# or in Yocto, add to IMAGE_INSTALL\n</code></pre>"},{"location":"labs/debugging/lab19-system-monitoring/#42-monitor-disk-io","title":"4.2 Monitor Disk I/O","text":"<pre><code>iostat -x 2 5\n</code></pre> <p>Output: <pre><code>Device            r/s     w/s     rkB/s     wkB/s   %util\nmmcblk0          12.5     8.3    256.7     134.2    5.2\nmmcblk0p1         1.2     0.5     15.3       8.1    0.3\nmmcblk0p2        11.3     7.8    241.4     126.1    4.9\n</code></pre></p> <p>Metrics: - r/s, w/s: Reads/writes per second - rkB/s, wkB/s: KB read/written per second - %util: Device utilization (&gt;80% = bottleneck)</p>"},{"location":"labs/debugging/lab19-system-monitoring/#43-cpu-statistics","title":"4.3 CPU Statistics","text":"<pre><code>iostat -c 2 5\n</code></pre> <p>Shows CPU usage breakdown: <pre><code>%user   %nice %system %iowait  %steal   %idle\n  2.3     0.0     0.8     0.2     0.0    96.7\n</code></pre></p> <p>High %iowait indicates processes waiting for I/O.</p>"},{"location":"labs/debugging/lab19-system-monitoring/#5-virtual-memory-with-vmstat","title":"5. Virtual Memory with vmstat","text":""},{"location":"labs/debugging/lab19-system-monitoring/#51-monitor-system-activity","title":"5.1 Monitor System Activity","text":"<pre><code>vmstat 2 10\n</code></pre> <p>Output: <pre><code>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 1264128  56832 352256    0    0    12     8  142  234  2  1 97  0  0\n 0  0      0 1263456  56832 352512    0    0     0    16  156  245  2  1 97  0  0\n</code></pre></p> <p>Key columns: - r: Processes running/waiting for CPU - b: Processes blocked on I/O - swpd: Swap used (should be 0 on BeaglePlay) - free: Free RAM - bi/bo: Blocks in/out (I/O) - us/sy/id/wa: CPU usage (user/system/idle/wait)</p>"},{"location":"labs/debugging/lab19-system-monitoring/#52-memory-statistics","title":"5.2 Memory Statistics","text":"<pre><code>vmstat -s\n</code></pre> <p>Detailed memory breakdown.</p>"},{"location":"labs/debugging/lab19-system-monitoring/#53-disk-statistics","title":"5.3 Disk Statistics","text":"<pre><code>vmstat -d\n</code></pre> <p>Per-disk statistics.</p>"},{"location":"labs/debugging/lab19-system-monitoring/#6-network-monitoring","title":"6. Network Monitoring","text":""},{"location":"labs/debugging/lab19-system-monitoring/#61-active-connections-with-netstat","title":"6.1 Active Connections with netstat","text":"<pre><code>netstat -tunapl\n</code></pre> <p>Output: <pre><code>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      234/sshd\ntcp        0      0 192.168.0.100:22        192.168.0.1:54321       ESTABLISHED 456/sshd\n</code></pre></p> <p>Options: - <code>-t</code>: TCP - <code>-u</code>: UDP - <code>-n</code>: Numeric (no DNS) - <code>-a</code>: All sockets - <code>-p</code>: Show PID/program - <code>-l</code>: Listening sockets</p>"},{"location":"labs/debugging/lab19-system-monitoring/#62-modern-alternative-ss","title":"6.2 Modern Alternative: ss","text":"<pre><code># Faster than netstat\nss -tunapl\n</code></pre>"},{"location":"labs/debugging/lab19-system-monitoring/#63-network-statistics","title":"6.3 Network Statistics","text":"<pre><code>netstat -i\n</code></pre> <p>Output: <pre><code>Iface      MTU    RX-OK RX-ERR RX-DRP TX-OK TX-ERR TX-DRP Flg\neth0      1500   123456      0      0  98765      0      0 BMRU\nlo       65536    45678      0      0  45678      0      0 LRU\n</code></pre></p> <p>Watch for RX-ERR and TX-ERR (packet errors).</p>"},{"location":"labs/debugging/lab19-system-monitoring/#7-practical-exercises","title":"7. Practical Exercises","text":""},{"location":"labs/debugging/lab19-system-monitoring/#71-find-memory-leak","title":"7.1 Find Memory Leak","text":"<p>Scenario: Application slowly consuming memory.</p> <p>Steps: <pre><code># Monitor process memory over time\nwatch -n 5 'ps aux | grep my-app'\n\n# Detailed memory map\npmap -x $(pidof my-app)\n\n# Check /proc for growth\nwatch -n 2 'cat /proc/$(pidof my-app)/status | grep VmRSS'\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#72-identify-io-bottleneck","title":"7.2 Identify I/O Bottleneck","text":"<pre><code># Real-time I/O monitoring\niotop -o\n</code></pre> <p>Shows processes doing I/O.</p> <p>Alternative: <pre><code># Per-process I/O\npidstat -d 2 5\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#73-diagnose-high-cpu-usage","title":"7.3 Diagnose High CPU Usage","text":"<pre><code># Find CPU hog\ntop -b -n 1 | head -20\n\n# Check if single-threaded or multi-threaded\nps -eLf | grep my-app\n\n# CPU affinity (which cores process uses)\ntaskset -cp $(pidof my-app)\n</code></pre>"},{"location":"labs/debugging/lab19-system-monitoring/#8-advanced-monitoring","title":"8. Advanced Monitoring","text":""},{"location":"labs/debugging/lab19-system-monitoring/#81-htop-enhanced-top","title":"8.1 htop (Enhanced top)","text":"<pre><code>htop\n</code></pre> <p>Features: - Color-coded display - Mouse support - Vertical/horizontal scrolling - Tree view - Easy process management</p>"},{"location":"labs/debugging/lab19-system-monitoring/#82-glances-all-in-one","title":"8.2 glances (All-in-One)","text":"<pre><code>glances\n</code></pre> <p>Shows CPU, memory, disk, network in single view.</p>"},{"location":"labs/debugging/lab19-system-monitoring/#83-system-load-graphing","title":"8.3 System Load Graphing","text":"<pre><code># Log metrics for graphing\nsar -u 2 1800 &gt; cpu-load.txt\nsar -r 2 1800 &gt; memory-usage.txt\n</code></pre>"},{"location":"labs/debugging/lab19-system-monitoring/#9-troubleshooting-scenarios","title":"9. Troubleshooting Scenarios","text":""},{"location":"labs/debugging/lab19-system-monitoring/#91-system-running-slow","title":"9.1 System Running Slow","text":"<p>Check: <pre><code># Load average\nuptime\n\n# CPU usage\ntop\n\n# Memory pressure\nfree -h\n\n# I/O wait\niostat -x 2 5\n\n# Swap activity (should be none)\nvmstat 2 5\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#92-out-of-memory","title":"9.2 Out of Memory","text":"<p>Investigate: <pre><code># System memory\ncat /proc/meminfo\n\n# Largest consumers\nps aux --sort=-%mem | head -20\n\n# OOM killer logs\ndmesg | grep -i \"out of memory\"\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#93-network-issues","title":"9.3 Network Issues","text":"<p>Debug: <pre><code># Active connections\nss -tunapl\n\n# Interface statistics\nnetstat -i\n\n# Connection tracking\ncat /proc/net/nf_conntrack\n</code></pre></p>"},{"location":"labs/debugging/lab19-system-monitoring/#10-key-takeaways","title":"10. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Mastered process monitoring with ps and top 2. \u2705 Analyzed memory with /proc and pmap 3. \u2705 Monitored I/O with iostat 4. \u2705 Tracked system resources with vmstat 5. \u2705 Debugged network with netstat/ss</p> <p>Essential Commands: - <code>top</code>: Real-time process viewer - <code>ps aux</code>: Process snapshot - <code>free -h</code>: Memory overview - <code>iostat -x</code>: I/O performance - <code>vmstat</code>: System statistics</p> <p>Next Steps: - Lab 20: Application debugging with GDB - Lab 21: System call tracing</p>"},{"location":"labs/debugging/lab19-system-monitoring/#11-verification-checklist","title":"11. Verification Checklist","text":"<ul> <li>[ ] Can identify top CPU consumers</li> <li>[ ] Can find memory leaks with pmap</li> <li>[ ] Understand load average interpretation</li> <li>[ ] Can diagnose I/O bottlenecks</li> <li>[ ] Know when system is memory-constrained</li> <li>[ ] Can monitor network connections</li> </ul> <p>End of Lab 19</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>System monitoring is the foundation of performance analysis and debugging. These tools provide the visibility needed to identify bottlenecks and resource constraints before they become critical issues.</p>"},{"location":"labs/debugging/lab20-gdb-debugging/","title":"Lab 20: Application Debugging with GDB","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about GDB:</p> <p>\"GDB is a debugger that allows you to peek inside your program while it's running, much like looking inside a Somebody Else's Problem field. Unlike SEP fields, however, GDB actually shows you what's there rather than making you ignore it.\"</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#objectives","title":"Objectives","text":"<p>Master the GNU Debugger (GDB) for diagnosing crashes, analyzing coredumps, remote debugging, and automating debug tasks with Python scripting.</p> <p>What You'll Learn: - Compile with debug symbols (<code>-g</code>) - Use GDB interactively to debug applications - Analyze coredumps from crashed programs - Remote debugging from workstation to BeaglePlay - Automate debugging with GDB Python API - Use Compiler Explorer for assembly analysis</p> <p>Time Required: 3-4 hours</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board with working Linux - Development workstation - Network connection</p> <p>Software: - Cross-compilation toolchain (from Lab 1) - GDB and gdbserver - Root access on BeaglePlay</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#1-compiling-with-debug-symbols","title":"1. Compiling with Debug Symbols","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#11-debug-vs-release-builds","title":"1.1 Debug vs Release Builds","text":"<p>Without debug symbols (-O2 optimized): <pre><code>aarch64-linux-gnu-gcc -O2 -o app app.c\nfile app\n# app: ELF 64-bit LSB executable, stripped\n</code></pre></p> <p>With debug symbols (-g): <pre><code>aarch64-linux-gnu-gcc -g -O0 -o app app.c\nfile app\n# app: ELF 64-bit LSB executable, not stripped\n</code></pre></p> <p>Options: - -g: Include debug info - -O0: No optimization (easier debugging) - -ggdb: GDB-specific debug info</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#12-check-debug-info","title":"1.2 Check Debug Info","text":"<pre><code># Verify debug symbols present\nreadelf -S app | grep debug\n\n# Should see sections like:\n# .debug_info\n# .debug_line\n# .debug_str\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#13-create-test-program","title":"1.3 Create Test Program","text":"<p>Create <code>buggy.c</code>: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint divide(int a, int b) {\n    return a / b;  // Bug: no check for b == 0\n}\n\nvoid leak_memory() {\n    char *ptr = malloc(1024);\n    strcpy(ptr, \"This memory will leak\");\n    // Bug: forgot to free(ptr)\n}\n\nvoid buffer_overflow() {\n    char buffer[10];\n    strcpy(buffer, \"This string is way too long!\");  // Bug: overflow\n}\n\nint main(int argc, char *argv[]) {\n    printf(\"Starting buggy program...\\n\");\n\n    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], \"crash\") == 0) {\n        printf(\"Triggering divide by zero...\\n\");\n        int result = divide(10, 0);\n        printf(\"Result: %d\\n\", result);\n    }\n\n    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], \"overflow\") == 0) {\n        printf(\"Triggering buffer overflow...\\n\");\n        buffer_overflow();\n    }\n\n    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], \"leak\") == 0) {\n        printf(\"Leaking memory...\\n\");\n        leak_memory();\n    }\n\n    printf(\"Program finished\\n\");\n    return 0;\n}\n</code></pre></p> <p>Compile: <pre><code>aarch64-linux-gnu-gcc -g -O0 -o buggy buggy.c\nscp buggy root@192.168.0.100:/tmp/\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#2-interactive-gdb-debugging","title":"2. Interactive GDB Debugging","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#21-starting-gdb","title":"2.1 Starting GDB","text":"<p>On BeaglePlay: <pre><code>ssh root@192.168.0.100\ncd /tmp\ngdb ./buggy\n</code></pre></p> <p>GDB prompt: <pre><code>(gdb) \n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#22-basic-gdb-commands","title":"2.2 Basic GDB Commands","text":"<p>Set breakpoint: <pre><code>(gdb) break main\nBreakpoint 1 at 0xaaaaaaaa0750: file buggy.c, line 20.\n\n(gdb) break divide\nBreakpoint 2 at 0xaaaaaaaa0680: file buggy.c, line 5.\n\n(gdb) break buggy.c:25\nBreakpoint 3 at 0xaaaaaaaa0780: file buggy.c, line 25.\n</code></pre></p> <p>Run program: <pre><code>(gdb) run crash\nStarting program: /tmp/buggy crash\n\nBreakpoint 1, main (argc=2, argv=0xfffffffff8) at buggy.c:20\n20      printf(\"Starting buggy program...\\n\");\n</code></pre></p> <p>Step through code: <pre><code>(gdb) next          # Execute one line (step over)\n(gdb) step          # Execute one line (step into functions)\n(gdb) continue      # Continue to next breakpoint\n(gdb) finish        # Execute until current function returns\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#23-inspecting-variables","title":"2.3 Inspecting Variables","text":"<pre><code>(gdb) print argc\n$1 = 2\n\n(gdb) print argv[1]\n$2 = 0xffffffffef \"crash\"\n\n(gdb) print result\n$3 = 0  # Uninitialized before assignment\n\n(gdb) display result  # Auto-display on every step\n(gdb) info locals     # Show all local variables\n(gdb) info args       # Show function arguments\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#24-examining-memory","title":"2.4 Examining Memory","text":"<pre><code>(gdb) x/s argv[1]     # Examine as string\n0xffffffffef:   \"crash\"\n\n(gdb) x/10x buffer    # Examine 10 hex words\n0xfffffffff0:   0x00000000  0x00000000  ...\n\n(gdb) x/10i main      # Disassemble 10 instructions\n0xaaaaaaaa0750 &lt;main&gt;:  stp x29, x30, [sp, #-32]!\n0xaaaaaaaa0754 &lt;main+4&gt;:    mov x29, sp\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#25-backtrace-call-stack","title":"2.5 Backtrace (Call Stack)","text":"<pre><code>(gdb) backtrace\n#0  divide (a=10, b=0) at buggy.c:5\n#1  0xaaaaaaaa0790 in main (argc=2, argv=0xfffffffff8) at buggy.c:25\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#3-coredump-analysis","title":"3. Coredump Analysis","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#31-enable-coredumps","title":"3.1 Enable Coredumps","text":"<p>On BeaglePlay: <pre><code># Check current limit\nulimit -c\n# 0 means coredumps disabled\n\n# Enable unlimited coredumps\nulimit -c unlimited\n\n# Verify\nulimit -c\n# unlimited\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#32-trigger-crash-and-generate-coredump","title":"3.2 Trigger Crash and Generate Coredump","text":"<pre><code>./buggy crash\n</code></pre> <p>Output: <pre><code>Starting buggy program...\nTriggering divide by zero...\nFloating point exception (core dumped)\n</code></pre></p> <p>Coredump created: <pre><code>ls -lh core\n# -rw------- 1 root root 128K Jan 15 10:30 core\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#33-analyze-coredump","title":"3.3 Analyze Coredump","text":"<pre><code>gdb ./buggy core\n</code></pre> <p>GDB output: <pre><code>Core was generated by `./buggy crash'.\nProgram terminated with signal SIGFPE, Arithmetic exception.\n#0  divide (a=10, b=0) at buggy.c:5\n5       return a / b;\n</code></pre></p> <p>Inspect state at crash: <pre><code>(gdb) backtrace\n#0  divide (a=10, b=0) at buggy.c:5\n#1  0xaaaaaaaa0790 in main (argc=2, argv=0xfffffffff8) at buggy.c:25\n\n(gdb) frame 0\n#0  divide (a=10, b=0) at buggy.c:5\n5       return a / b;\n\n(gdb) print a\n$1 = 10\n\n(gdb) print b\n$2 = 0  # There's the bug!\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#34-coredump-location-configuration","title":"3.4 Coredump Location Configuration","text":"<p>Configure systemd coredump handler: <pre><code>cat /etc/systemd/coredump.conf\n</code></pre></p> <p>Or use kernel core pattern: <pre><code>echo \"/tmp/core.%e.%p\" &gt; /proc/sys/kernel/core_pattern\n# %e = executable name\n# %p = PID\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#4-remote-debugging","title":"4. Remote Debugging","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#41-setup-gdbserver-on-beagleplay","title":"4.1 Setup gdbserver on BeaglePlay","text":"<p>On BeaglePlay: <pre><code>gdbserver :2345 ./buggy crash\n</code></pre></p> <p>Output: <pre><code>Process ./buggy created; pid = 567\nListening on port 2345\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#42-connect-from-workstation","title":"4.2 Connect from Workstation","text":"<p>On workstation: <pre><code>cd ~/beagleplay-labs/toolchain\ngdb-multiarch ./buggy\n</code></pre></p> <p>In GDB: <pre><code>(gdb) target remote 192.168.0.100:2345\nRemote debugging using 192.168.0.100:2345\nReading symbols from /lib/ld-linux-aarch64.so.1...\n\n(gdb) break divide\nBreakpoint 1 at 0xaaaaaaaa0680: file buggy.c, line 5.\n\n(gdb) continue\n</code></pre></p> <p>Advantages: - Debug from comfortable workstation - Access full source code locally - Use graphical GDB frontends</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#43-attach-to-running-process","title":"4.3 Attach to Running Process","text":"<p>Find PID on BeaglePlay: <pre><code>ps aux | grep my-app\n# root  789  0.5  1.2  ...  my-app\n</code></pre></p> <p>Start gdbserver attached: <pre><code>gdbserver :2345 --attach 789\n</code></pre></p> <p>Connect from workstation: <pre><code>(gdb) target remote 192.168.0.100:2345\n(gdb) continue\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#5-gdb-python-scripting","title":"5. GDB Python Scripting","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#51-check-python-support","title":"5.1 Check Python Support","text":"<pre><code>(gdb) python print(\"GDB Python is working!\")\nGDB Python is working!\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#52-simple-python-commands","title":"5.2 Simple Python Commands","text":"<p>Print all local variables: <pre><code>(gdb) python\n&gt;frame = gdb.selected_frame()\n&gt;block = frame.block()\n&gt;for symbol in block:\n&gt;    if symbol.is_argument or symbol.is_variable:\n&gt;        print(f\"{symbol.name} = {symbol.value(frame)}\")\n&gt;end\nargc = 2\nargv = 0xfffffffff8\nresult = &lt;optimized out&gt;\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#53-custom-gdb-command-in-python","title":"5.3 Custom GDB Command in Python","text":"<p>Create <code>debug_helpers.py</code>: <pre><code>import gdb\n\nclass PrintStructCommand(gdb.Command):\n    \"\"\"Print all fields of a struct\"\"\"\n\n    def __init__(self):\n        super(PrintStructCommand, self).__init__(\n            \"print-struct\", gdb.COMMAND_DATA\n        )\n\n    def invoke(self, arg, from_tty):\n        try:\n            val = gdb.parse_and_eval(arg)\n            struct_type = val.type\n\n            if struct_type.code != gdb.TYPE_CODE_STRUCT:\n                print(\"Error: Not a struct\")\n                return\n\n            print(f\"Struct {struct_type.tag}:\")\n            for field in struct_type.fields():\n                field_val = val[field.name]\n                print(f\"  {field.name} = {field_val}\")\n        except gdb.error as e:\n            print(f\"Error: {e}\")\n\nPrintStructCommand()\n</code></pre></p> <p>Load in GDB: <pre><code>(gdb) source debug_helpers.py\n(gdb) print-struct my_struct_var\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#54-automated-debugging-script","title":"5.4 Automated Debugging Script","text":"<p>Create <code>auto_debug.py</code>: <pre><code>import gdb\n\n# Set breakpoints\ngdb.execute(\"break main\")\ngdb.execute(\"break divide\")\n\n# Run program\ngdb.execute(\"run crash\")\n\n# Collect stack traces at each breakpoint\ntraces = []\n\nclass BreakpointHandler(gdb.Breakpoint):\n    def stop(self):\n        frame = gdb.selected_frame()\n        bt = gdb.execute(\"backtrace\", to_string=True)\n        traces.append({\n            'location': frame.name(),\n            'backtrace': bt\n        })\n        return False  # Continue execution\n\n# Set up handlers\nfor bp in gdb.breakpoints():\n    bp.__class__ = BreakpointHandler\n\nprint(\"Automated debugging complete\")\nprint(f\"Collected {len(traces)} stack traces\")\n</code></pre></p> <p>Run script: <pre><code>gdb -batch -x auto_debug.py ./buggy\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#6-advanced-gdb-features","title":"6. Advanced GDB Features","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#61-conditional-breakpoints","title":"6.1 Conditional Breakpoints","text":"<pre><code>(gdb) break divide if b == 0\nBreakpoint 1 at 0xaaaaaaaa0680: file buggy.c, line 5.\n\n# Break only when condition is true\n(gdb) run crash\nBreakpoint 1, divide (a=10, b=0) at buggy.c:5\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#62-watchpoints-break-on-variable-change","title":"6.2 Watchpoints (Break on Variable Change)","text":"<pre><code>(gdb) watch result\nHardware watchpoint 2: result\n\n(gdb) continue\nHardware watchpoint 2: result\nOld value = 0\nNew value = -1234567\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#63-reverse-debugging","title":"6.3 Reverse Debugging","text":"<p>Record execution: <pre><code>(gdb) record\n(gdb) continue\n# Program crashes\n\n(gdb) reverse-step\n# Step backwards!\n\n(gdb) reverse-continue\n# Run backwards to previous breakpoint\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#7-compiler-explorer-integration","title":"7. Compiler Explorer Integration","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#71-understanding-assembly","title":"7.1 Understanding Assembly","text":"<p>Use Compiler Explorer (https://godbolt.org) to see assembly:</p> <p>C code: <pre><code>int divide(int a, int b) {\n    return a / b;\n}\n</code></pre></p> <p>ARM64 assembly output: <pre><code>divide:\n    sdiv    w0, w0, w1    ; Signed divide\n    ret\n</code></pre></p> <p>Compare with optimized version: <pre><code># -O2 optimization\naarch64-linux-gnu-gcc -O2 -S divide.c -o divide.s\ncat divide.s\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#72-debug-assembly-in-gdb","title":"7.2 Debug Assembly in GDB","text":"<pre><code>(gdb) disassemble divide\nDump of assembler code for function divide:\n   0x0000aaaaaaaa0680 &lt;+0&gt;:     sdiv    w0, w0, w1\n   0x0000aaaaaaaa0684 &lt;+4&gt;:     ret\n\n(gdb) break *0x0000aaaaaaaa0680\n(gdb) stepi  # Step one instruction\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#8-practical-debugging-scenarios","title":"8. Practical Debugging Scenarios","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#81-null-pointer-dereference","title":"8.1 Null Pointer Dereference","text":"<p>Create <code>nullptr.c</code>: <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char *ptr = NULL;\n    printf(\"%s\\n\", ptr);  // Crash!\n    return 0;\n}\n</code></pre></p> <p>Debug: <pre><code>aarch64-linux-gnu-gcc -g -o nullptr nullptr.c\ngdb ./nullptr\n</code></pre></p> <pre><code>(gdb) run\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000fffff7e12345 in strlen () from /lib/aarch64-linux-gnu/libc.so.6\n\n(gdb) backtrace\n#0  0x0000fffff7e12345 in strlen () from /lib/libc.so.6\n#1  0x0000aaaaaaaa0750 in main () at nullptr.c:5\n\n(gdb) frame 1\n#1  0x0000aaaaaaaa0750 in main () at nullptr.c:5\n5       printf(\"%s\\n\", ptr);\n\n(gdb) print ptr\n$1 = 0x0 &lt;-- NULL pointer\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#82-use-after-free","title":"8.2 Use-After-Free","text":"<p>Create <code>use_after_free.c</code>: <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    int *ptr = malloc(sizeof(int));\n    *ptr = 42;\n    free(ptr);\n    printf(\"%d\\n\", *ptr);  // Use after free!\n    return 0;\n}\n</code></pre></p> <p>Debug with watchpoint: <pre><code>(gdb) watch *ptr\n(gdb) run\n# Watchpoint triggers when ptr is freed and accessed\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#9-gdb-frontends","title":"9. GDB Frontends","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#91-tui-mode-text-ui","title":"9.1 TUI Mode (Text UI)","text":"<pre><code>gdb -tui ./buggy\n</code></pre> <p>Or enable in session: <pre><code>(gdb) tui enable\n</code></pre></p> <p>Shows source code and assembly in split view.</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#92-gdb-dashboard","title":"9.2 GDB Dashboard","text":"<p>Install: <pre><code>wget -P ~ https://git.io/.gdbinit\n</code></pre></p> <p>Enhanced GDB interface with: - Source code - Assembly - Registers - Stack - Threads</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#93-ide-integration","title":"9.3 IDE Integration","text":"<p>VS Code with GDB: - Install \"C/C++\" extension - Configure <code>.vscode/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Remote Debug\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/buggy\",\n            \"miDebuggerServerAddress\": \"192.168.0.100:2345\",\n            \"miDebuggerPath\": \"/usr/bin/gdb-multiarch\"\n        }\n    ]\n}\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#10-troubleshooting-gdb-issues","title":"10. Troubleshooting GDB Issues","text":""},{"location":"labs/debugging/lab20-gdb-debugging/#101-missing-debug-symbols","title":"10.1 Missing Debug Symbols","text":"<p>Error: <pre><code>Reading symbols from ./app...(no debugging symbols found)\n</code></pre></p> <p>Solution: <pre><code># Recompile with -g\naarch64-linux-gnu-gcc -g -O0 -o app app.c\n</code></pre></p>"},{"location":"labs/debugging/lab20-gdb-debugging/#102-optimized-code-debugging","title":"10.2 Optimized Code Debugging","text":"<p>Variables show as <code>&lt;optimized out&gt;</code>:</p> <p>Solution: Compile with <code>-O0</code> or use <code>-Og</code> (optimize for debugging).</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#103-source-path-issues","title":"10.3 Source Path Issues","text":"<p>GDB can't find source files:</p> <pre><code>(gdb) directory /path/to/source\n(gdb) set substitute-path /old/path /new/path\n</code></pre>"},{"location":"labs/debugging/lab20-gdb-debugging/#11-key-takeaways","title":"11. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Compiled with debug symbols 2. \u2705 Used GDB interactively 3. \u2705 Analyzed coredumps 4. \u2705 Remote debugging with gdbserver 5. \u2705 Automated debugging with Python 6. \u2705 Understood assembly with Compiler Explorer</p> <p>Essential GDB Commands: - <code>break</code>: Set breakpoint - <code>run</code>: Start program - <code>next/step</code>: Execute code - <code>print</code>: Inspect variables - <code>backtrace</code>: Show call stack - <code>continue</code>: Resume execution</p> <p>Next Steps: - Lab 21: System call tracing with strace/ltrace - Lab 22: Memory debugging with valgrind</p>"},{"location":"labs/debugging/lab20-gdb-debugging/#12-verification-checklist","title":"12. Verification Checklist","text":"<ul> <li>[ ] Can compile with debug symbols</li> <li>[ ] Can set breakpoints and step through code</li> <li>[ ] Can analyze coredumps to find crash cause</li> <li>[ ] Can debug remotely with gdbserver</li> <li>[ ] Understand basic GDB Python scripting</li> <li>[ ] Can read assembly output</li> </ul> <p>End of Lab 20</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>GDB is the cornerstone of low-level debugging on Linux. Mastering it enables you to diagnose the most challenging bugs, from crashes to subtle memory corruption issues.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/","title":"Lab 21: System Call and Library Tracing","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#objectives","title":"Objectives","text":"<p>Master <code>strace</code> and <code>ltrace</code> to understand how programs interact with the kernel and libraries, essential for diagnosing system-level issues and performance problems.</p> <p>What You'll Learn: - Trace system calls with <code>strace</code> - Analyze library function calls with <code>ltrace</code> - Filter and format trace output - Identify performance bottlenecks - Debug file access and permission issues - Understand process behavior</p> <p>Time Required: 2-3 hours (or approximately 42 minutes in improbable circumstances)</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board - Development workstation - Network connection</p> <p>Software: - strace and ltrace installed - Sample applications to trace</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#1-introduction-to-strace","title":"1. Introduction to strace","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#11-what-is-strace","title":"1.1 What is strace?","text":"<p><code>strace</code> intercepts and records system calls made by a process.</p> <p>System calls are the interface between user programs and the kernel: - <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code> - File I/O - <code>fork()</code>, <code>execve()</code>, <code>wait()</code> - Process management - <code>socket()</code>, <code>connect()</code>, <code>send()</code> - Networking - <code>mmap()</code>, <code>brk()</code> - Memory management</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#12-basic-usage","title":"1.2 Basic Usage","text":"<p>Trace simple command: <pre><code>strace ls /tmp\n</code></pre></p> <p>Output: <pre><code>execve(\"/usr/bin/ls\", [\"ls\", \"/tmp\"], 0xfffffffff8 /* 12 vars */) = 0\nbrk(NULL)                               = 0xaaaaaaaa8000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffff7ff0000\nopenat(AT_FDCWD, \"/tmp\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3\ngetdents64(3, /* 5 entries */, 32768)   = 160\nwrite(1, \"file1\\nfile2\\nfile3\\n\", 18)   = 18\nclose(3)                                = 0\nexit_group(0)                           = ?\n</code></pre></p> <p>Format: <code>syscall(args) = return_value</code></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#13-install-strace","title":"1.3 Install strace","text":"<p>On BeaglePlay: <pre><code># Using opkg (Buildroot)\nopkg install strace\n\n# Using apt (Debian-based)\napt-get install strace\n\n# Using Yocto, add to image:\nIMAGE_INSTALL:append = \" strace\"\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#2-strace-command-options","title":"2. strace Command Options","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#21-filter-specific-system-calls","title":"2.1 Filter Specific System Calls","text":"<p>Trace only file operations: <pre><code>strace -e trace=open,openat,read,write,close cat /etc/hostname\n</code></pre></p> <p>Output: <pre><code>openat(AT_FDCWD, \"/etc/hostname\", O_RDONLY) = 3\nread(3, \"beagleplay\\n\", 131072)         = 11\nwrite(1, \"beagleplay\\n\", 11)            = 11\nclose(3)                                = 0\n</code></pre></p> <p>Trace only network calls: <pre><code>strace -e trace=network nc -l 8080\n</code></pre></p> <p>Categories: - <code>file</code>: File operations - <code>process</code>: fork, exec, wait - <code>network</code>: socket, connect, send, recv - <code>signal</code>: kill, sigaction - <code>memory</code>: mmap, brk, mprotect</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#22-output-formatting","title":"2.2 Output Formatting","text":"<p>Show timestamps: <pre><code>strace -t ls\n# -t: Time of day\n# -tt: Time with microseconds\n# -ttt: Unix timestamp\n</code></pre></p> <p>Show time spent in each syscall: <pre><code>strace -T ls\n</code></pre></p> <p>Output: <pre><code>openat(AT_FDCWD, \"/tmp\", O_RDONLY) = 3 &lt;0.000045&gt;\n# &lt;0.000045&gt; = 45 microseconds\n</code></pre></p> <p>Count syscall statistics: <pre><code>strace -c ls /tmp\n</code></pre></p> <p>Output: <pre><code>% time     seconds  usecs/call     calls    errors syscall\n------ ----------- ----------- --------- --------- ----------------\n 45.23    0.000543          54        10           mmap\n 21.34    0.000256          64         4           openat\n 12.45    0.000149          37         4           read\n ...\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#23-attach-to-running-process","title":"2.3 Attach to Running Process","text":"<p>Find PID: <pre><code>ps aux | grep my-app\n# root  567  0.5  1.2  ...  my-app\n</code></pre></p> <p>Attach strace: <pre><code>strace -p 567\n</code></pre></p> <p>Detach: Press <code>Ctrl+C</code></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#24-follow-child-processes","title":"2.4 Follow Child Processes","text":"<pre><code>strace -f -e trace=process ./parent-app\n</code></pre> <p><code>-f</code>: Follow forks and child processes</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#3-practical-strace-examples","title":"3. Practical strace Examples","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#31-debug-file-not-found","title":"3.1 Debug File Not Found","text":"<p>Program fails to open file: <pre><code>strace -e trace=open,openat,stat ./my-app\n</code></pre></p> <p>Output: <pre><code>openat(AT_FDCWD, \"/etc/config.conf\", O_RDONLY) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/usr/local/etc/config.conf\", O_RDONLY) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/home/root/.config.conf\", O_RDONLY) = 3\n</code></pre></p> <p>Shows search path until file found.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#32-diagnose-permission-issues","title":"3.2 Diagnose Permission Issues","text":"<pre><code>strace -e trace=open,access ./my-app 2&gt;&amp;1 | grep EACCES\n</code></pre> <p>Output: <pre><code>openat(AT_FDCWD, \"/dev/i2c-1\", O_RDWR) = -1 EACCES (Permission denied)\n</code></pre></p> <p>Solution: Add user to <code>i2c</code> group or run as root.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#33-identify-slow-operations","title":"3.3 Identify Slow Operations","text":"<p>Trace with timing: <pre><code>strace -T -e trace=read,write ./slow-app\n</code></pre></p> <p>Output: <pre><code>read(3, \"...\", 4096) = 4096 &lt;0.000023&gt;\nread(3, \"...\", 4096) = 4096 &lt;2.345678&gt;  # Slow read!\n</code></pre></p> <p>2.3 seconds = likely waiting for network/disk.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#34-trace-network-activity","title":"3.4 Trace Network Activity","text":"<p>Create test client: <pre><code>strace -e trace=network curl http://192.168.0.1\n</code></pre></p> <p>Output: <pre><code>socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3\nconnect(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr(\"192.168.0.1\")}, 16) = 0\nsendto(3, \"GET / HTTP/1.1\\r\\nHost: 192.168.0.1\\r\\n...\", 78, MSG_NOSIGNAL, NULL, 0) = 78\nrecvfrom(3, \"HTTP/1.1 200 OK\\r\\n...\", 16384, 0, NULL, NULL) = 512\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#4-introduction-to-ltrace","title":"4. Introduction to ltrace","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#41-what-is-ltrace","title":"4.1 What is ltrace?","text":"<p><code>ltrace</code> intercepts library function calls (libc, etc.).</p> <p>Difference from strace: - strace: System calls (kernel interface) - ltrace: Library calls (user-space functions)</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#42-basic-usage","title":"4.2 Basic Usage","text":"<pre><code>ltrace ls /tmp\n</code></pre> <p>Output: <pre><code>__libc_start_main(0xaaaaaaaa1234, 2, 0xfffffffff8, ...\nstrcmp(\"ls\", \"ls\")                      = 0\nmalloc(1024)                            = 0xaaaaaaaa8000\nopendir(\"/tmp\")                         = 0xaaaaaaaa8100\nreaddir(0xaaaaaaaa8100)                 = { d_name = \"file1\" }\nprintf(\"%s\\n\", \"file1\")                 = 6\nfree(0xaaaaaaaa8000)                    = &lt;void&gt;\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#43-filter-library-calls","title":"4.3 Filter Library Calls","text":"<p>Trace only malloc/free: <pre><code>ltrace -e malloc,free ./my-app\n</code></pre></p> <p>Trace only string functions: <pre><code>ltrace -e 'strcmp*' ./my-app\n# Matches strcmp, strcpy, strlen, etc.\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#5-practical-ltrace-examples","title":"5. Practical ltrace Examples","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#51-find-memory-leaks","title":"5.1 Find Memory Leaks","text":"<p>Create <code>leak.c</code>: <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    for (int i = 0; i &lt; 100; i++) {\n        char *ptr = malloc(1024);\n        strcpy(ptr, \"Leaked memory\");\n        // Missing free(ptr)!\n    }\n    return 0;\n}\n</code></pre></p> <p>Compile and trace: <pre><code>aarch64-linux-gnu-gcc -o leak leak.c\nltrace -e malloc,free ./leak\n</code></pre></p> <p>Output: <pre><code>malloc(1024) = 0xaaaaaaaa8000\nmalloc(1024) = 0xaaaaaaaa8400\nmalloc(1024) = 0xaaaaaaaa8800\n...\n# 100 malloc() calls, 0 free() calls!\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#52-trace-string-operations","title":"5.2 Trace String Operations","text":"<pre><code>ltrace -e 'str*' ./my-app\n</code></pre> <p>Output: <pre><code>strlen(\"Hello World\") = 11\nstrcmp(\"user\", \"root\") = 1\nstrcpy(0xfffffffff0, \"config.txt\") = 0xfffffffff0\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#53-debug-library-loading","title":"5.3 Debug Library Loading","text":"<pre><code>ltrace -e 'dlopen*' ./my-app\n</code></pre> <p>Shows dynamic library loading.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#6-combining-strace-and-ltrace","title":"6. Combining strace and ltrace","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#61-trace-both-system-and-library-calls","title":"6.1 Trace Both System and Library Calls","text":"<p>Terminal 1 - strace: <pre><code>strace -o strace.log -tt ./my-app\n</code></pre></p> <p>Terminal 2 - ltrace: <pre><code>ltrace -o ltrace.log -tt ./my-app\n</code></pre></p> <p>Analyze together: <pre><code># System calls\ngrep \"open\\|read\\|write\" strace.log\n\n# Library calls\ngrep \"malloc\\|free\\|strcmp\" ltrace.log\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#62-correlate-by-timestamp","title":"6.2 Correlate by Timestamp","text":"<p>Both logs have timestamps (<code>-tt</code>), can merge chronologically.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#7-advanced-usage","title":"7. Advanced Usage","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#71-save-trace-to-file","title":"7.1 Save Trace to File","text":"<pre><code>strace -o trace.log -ff -tt ./my-app\n</code></pre> <p>Options: - <code>-o file</code>: Output to file - <code>-ff</code>: Separate file per process (trace.log.PID) - <code>-tt</code>: Microsecond timestamps</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#72-trace-specific-file-operations","title":"7.2 Trace Specific File Operations","text":"<p>Track all accesses to specific file: <pre><code>strace -e trace=file -e open --trace=/etc/passwd ./my-app\n</code></pre></p> <p>Only shows operations on <code>/etc/passwd</code>.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#73-decode-socket-addresses","title":"7.3 Decode Socket Addresses","text":"<pre><code>strace -yy -e trace=network ./network-app\n</code></pre> <p><code>-yy</code>: Show file descriptor paths and IP addresses</p> <p>Output: <pre><code>socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3&lt;TCP:[192.168.0.100:54321-&gt;192.168.0.1:80]&gt;\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#8-performance-profiling-with-strace","title":"8. Performance Profiling with strace","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#81-identify-slow-system-calls","title":"8.1 Identify Slow System Calls","text":"<pre><code>strace -c -S time ./my-app\n</code></pre> <p>Output: <pre><code>% time     seconds  usecs/call     calls    errors syscall\n------ ----------- ----------- --------- --------- ----------------\n 85.23    2.345678      234567        10           read\n  8.45    0.232145       11607        20           write\n  3.12    0.085632        4281        20           mmap\n</code></pre></p> <p>85% of time spent in <code>read()</code> syscalls.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#82-find-excessive-syscalls","title":"8.2 Find Excessive Syscalls","text":"<pre><code>strace -c ./my-app\n</code></pre> <p>Look for: - High call count: Inefficient loops - High error count: Repeated failures</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#9-real-world-debugging-scenarios","title":"9. Real-World Debugging Scenarios","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#91-application-hangs","title":"9.1 Application Hangs","text":"<p>Symptoms: Program stops responding.</p> <p>Debug: <pre><code># Find PID\nps aux | grep my-app\n\n# Attach strace\nstrace -p 567\n</code></pre></p> <p>Possible outputs: <pre><code># Stuck in read() - waiting for input\nread(3, \n\n# Stuck in futex - deadlock\nfutex(0xaaaaaaaa8000, FUTEX_WAIT_PRIVATE, 0, NULL\n\n# Stuck in nanosleep - sleeping\nnanosleep({tv_sec=1000000, tv_nsec=0},\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#92-high-cpu-usage","title":"9.2 High CPU Usage","text":"<pre><code>strace -c -p 567\n</code></pre> <p>Check for: - Tight loops with millions of syscalls - Repeated failed syscalls (e.g., <code>ENOENT</code>)</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#93-file-access-patterns","title":"9.3 File Access Patterns","text":"<p>Find all files accessed: <pre><code>strace -e trace=open,openat ./my-app 2&gt;&amp;1 | grep -o '\"/[^\"]*\"' | sort -u\n</code></pre></p> <p>Output: <pre><code>\"/dev/null\"\n\"/etc/ld.so.cache\"\n\"/etc/passwd\"\n\"/lib/libc.so.6\"\n\"/tmp/config.conf\"\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#10-troubleshooting-tips","title":"10. Troubleshooting Tips","text":""},{"location":"labs/debugging/lab21-strace-ltrace/#101-permission-denied","title":"10.1 Permission Denied","text":"<p>strace needs permissions: <pre><code># Run as root\nsudo strace -p 567\n\n# Or allow ptrace for your user\necho 0 &gt; /proc/sys/kernel/yama/ptrace_scope\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#102-too-much-output","title":"10.2 Too Much Output","text":"<p>Limit output: <pre><code># Only first 1000 lines\nstrace ./my-app 2&gt;&amp;1 | head -1000\n\n# Only errors\nstrace -e trace=open ./my-app 2&gt;&amp;1 | grep -v \"= 3\"\n</code></pre></p>"},{"location":"labs/debugging/lab21-strace-ltrace/#103-decode-binary-data","title":"10.3 Decode Binary Data","text":"<pre><code># Show hex and ASCII for read/write\nstrace -s 1024 -x ./my-app\n</code></pre>"},{"location":"labs/debugging/lab21-strace-ltrace/#11-example-debug-failed-service-start","title":"11. Example: Debug Failed Service Start","text":"<p>Scenario: Service fails to start, no error logs.</p> <pre><code>strace -f -e trace=file,process systemctl start my-service\n</code></pre> <p>Output reveals: <pre><code>openat(AT_FDCWD, \"/etc/my-service/config\", O_RDONLY) = -1 ENOENT (No such file or directory)\n</code></pre></p> <p>Solution: Create missing config file.</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#12-key-takeaways","title":"12. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Traced system calls with strace 2. \u2705 Traced library calls with ltrace 3. \u2705 Filtered and analyzed trace output 4. \u2705 Identified performance bottlenecks 5. \u2705 Debugged file access and permission issues</p> <p>Essential Commands: - <code>strace -e trace=file ./app</code>: File operations - <code>strace -c ./app</code>: Call statistics - <code>strace -p PID</code>: Attach to process - <code>ltrace -e malloc,free ./app</code>: Memory allocation</p> <p>Next Steps: - Lab 22: Memory debugging with valgrind - Lab 23: Performance profiling</p>"},{"location":"labs/debugging/lab21-strace-ltrace/#13-verification-checklist","title":"13. Verification Checklist","text":"<ul> <li>[ ] Can trace system calls of a program</li> <li>[ ] Can filter specific syscall categories</li> <li>[ ] Can attach to running processes</li> <li>[ ] Can identify slow syscalls with timing</li> <li>[ ] Understand difference between strace and ltrace</li> <li>[ ] Can debug file access issues</li> </ul> <p>End of Lab 21</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p><code>strace</code> and <code>ltrace</code> are invaluable for understanding program behavior at the system level. They reveal exactly how applications interact with the kernel and libraries, making seemingly mysterious bugs transparent.</p>"},{"location":"labs/debugging/lab22-valgrind/","title":"Lab 22: Memory Debugging with Valgrind","text":""},{"location":"labs/debugging/lab22-valgrind/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/debugging/lab22-valgrind/#objectives","title":"Objectives","text":"<p>Master Valgrind for detecting memory leaks, buffer overflows, use-after-free bugs, and other memory errors that cause crashes and security vulnerabilities.</p> <p>What You'll Learn: - Detect memory leaks with Memcheck - Find buffer overflows and underruns - Identify use-after-free errors - Debug with vgdb (Valgrind + GDB) - Profile heap usage with Massif - Optimize cache performance with Cachegrind</p> <p>Time Required: 3-4 hours</p>"},{"location":"labs/debugging/lab22-valgrind/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board - Development workstation - 2GB+ RAM recommended</p> <p>Software: - Valgrind installed - Programs compiled with <code>-g</code> debug symbols</p>"},{"location":"labs/debugging/lab22-valgrind/#1-introduction-to-valgrind","title":"1. Introduction to Valgrind","text":""},{"location":"labs/debugging/lab22-valgrind/#11-what-is-valgrind","title":"1.1 What is Valgrind?","text":"<p>Valgrind is a dynamic analysis framework with multiple tools: - Memcheck: Memory error detector (default) - Massif: Heap profiler - Cachegrind: Cache profiler - Helgrind: Thread error detector - Callgrind: Call-graph profiler</p>"},{"location":"labs/debugging/lab22-valgrind/#12-install-valgrind","title":"1.2 Install Valgrind","text":"<p>On BeaglePlay: <pre><code># Buildroot\nopkg install valgrind\n\n# Debian/Ubuntu\napt-get install valgrind\n\n# Yocto: Add to image\nIMAGE_INSTALL:append = \" valgrind\"\n</code></pre></p> <p>Verify: <pre><code>valgrind --version\n# valgrind-3.21.0\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#2-memory-leak-detection","title":"2. Memory Leak Detection","text":""},{"location":"labs/debugging/lab22-valgrind/#21-simple-memory-leak","title":"2.1 Simple Memory Leak","text":"<p>Create <code>leak_simple.c</code>: <pre><code>#include &lt;stdlib.h&gt;\n\nint main() {\n    int *array = malloc(100 * sizeof(int));\n    array[0] = 42;\n    // Forgot to free(array)!\n    return 0;\n}\n</code></pre></p> <p>Compile: <pre><code>aarch64-linux-gnu-gcc -g -o leak_simple leak_simple.c\n</code></pre></p> <p>Run with Valgrind: <pre><code>valgrind --leak-check=full ./leak_simple\n</code></pre></p> <p>Output: <pre><code>==567== Memcheck, a memory error detector\n==567== Command: ./leak_simple\n==567== \n==567== HEAP SUMMARY:\n==567==     in use at exit: 400 bytes in 1 blocks\n==567==   total heap usage: 1 allocs, 0 frees, 400 bytes allocated\n==567== \n==567== 400 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==567==    at 0x4839D8C: malloc (vg_replace_malloc.c:381)\n==567==    by 0x1086B7: main (leak_simple.c:4)\n==567== \n==567== LEAK SUMMARY:\n==567==    definitely lost: 400 bytes in 1 blocks\n==567==    indirectly lost: 0 bytes in 0 blocks\n==567==      possibly lost: 0 bytes in 0 blocks\n==567==    still reachable: 0 bytes in 0 blocks\n==567== \n==567== ERROR SUMMARY: 1 errors from 1 contexts\n</code></pre></p> <p>Analysis: - 400 bytes lost at line 4 (<code>malloc</code>) - 0 frees vs 1 allocs</p> <p>Fix: <pre><code>free(array);\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#22-leak-types","title":"2.2 Leak Types","text":"<p>Definitely lost: <pre><code>int *p = malloc(100);\np = NULL;  // Lost reference!\n</code></pre></p> <p>Indirectly lost: <pre><code>struct node {\n    int data;\n    struct node *next;\n};\n\nstruct node *head = malloc(sizeof(struct node));\nhead-&gt;next = malloc(sizeof(struct node));\nfree(head);  // Lost head-&gt;next!\n</code></pre></p> <p>Still reachable: <pre><code>int *p = malloc(100);\n// Program exits, pointer still valid\n// Not a \"leak\" but not freed\n</code></pre></p> <p>Possibly lost: <pre><code>int *p = malloc(100);\np++;  // Interior pointer\n// Valgrind unsure if this is intentional\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#23-complex-leak-example","title":"2.3 Complex Leak Example","text":"<p>Create <code>leak_complex.c</code>: <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    char *name;\n    int *data;\n} Record;\n\nRecord* create_record(const char *n) {\n    Record *r = malloc(sizeof(Record));\n    r-&gt;name = strdup(n);  // Allocates memory\n    r-&gt;data = malloc(100 * sizeof(int));\n    return r;\n}\n\nvoid free_record_buggy(Record *r) {\n    free(r-&gt;name);\n    // Forgot to free r-&gt;data!\n    free(r);\n}\n\nint main() {\n    Record *rec = create_record(\"test\");\n    free_record_buggy(rec);\n    return 0;\n}\n</code></pre></p> <p>Run Valgrind: <pre><code>valgrind --leak-check=full ./leak_complex\n</code></pre></p> <p>Output: <pre><code>==567== 400 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==567==    at 0x4839D8C: malloc (vg_replace_malloc.c:381)\n==567==    by 0x108723: create_record (leak_complex.c:11)\n==567==    by 0x108789: main (leak_complex.c:20)\n</code></pre></p> <p>Shows <code>r-&gt;data</code> allocation never freed.</p>"},{"location":"labs/debugging/lab22-valgrind/#3-invalid-memory-access","title":"3. Invalid Memory Access","text":""},{"location":"labs/debugging/lab22-valgrind/#31-buffer-overflow","title":"3.1 Buffer Overflow","text":"<p>Create <code>overflow.c</code>: <pre><code>#include &lt;string.h&gt;\n\nint main() {\n    char buffer[10];\n    strcpy(buffer, \"This string is way too long!\");  // Overflow!\n    return 0;\n}\n</code></pre></p> <p>Run Valgrind: <pre><code>valgrind ./overflow\n</code></pre></p> <p>Output: <pre><code>==567== Invalid write of size 1\n==567==    at 0x483970C: strcpy (vg_replace_strmem.c:523)\n==567==    by 0x1086C7: main (overflow.c:5)\n==567==  Address 0x4a3f04a is 0 bytes after a block of size 10 alloc'd\n==567==    at 0x483977F: malloc (vg_replace_malloc.c:381)\n==567==    by 0x1086B3: main (overflow.c:4)\n</code></pre></p> <p>Detected write beyond allocated buffer.</p>"},{"location":"labs/debugging/lab22-valgrind/#32-use-after-free","title":"3.2 Use-After-Free","text":"<p>Create <code>use_after_free.c</code>: <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    int *ptr = malloc(sizeof(int));\n    *ptr = 42;\n    free(ptr);\n    printf(\"%d\\n\", *ptr);  // Use after free!\n    return 0;\n}\n</code></pre></p> <p>Run Valgrind: <pre><code>valgrind ./use_after_free\n</code></pre></p> <p>Output: <pre><code>==567== Invalid read of size 4\n==567==    at 0x1086D7: main (use_after_free.c:8)\n==567==  Address 0x4a3f040 is 0 bytes inside a block of size 4 free'd\n==567==    at 0x48399AB: free (vg_replace_malloc.c:755)\n==567==    by 0x1086C3: main (use_after_free.c:7)\n</code></pre></p> <p>Detected read from freed memory.</p>"},{"location":"labs/debugging/lab22-valgrind/#33-uninitialized-memory","title":"3.3 Uninitialized Memory","text":"<p>Create <code>uninit.c</code>: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *ptr = malloc(sizeof(int));\n    if (*ptr == 42) {  // Reading uninitialized!\n        printf(\"Magic number!\\n\");\n    }\n    free(ptr);\n    return 0;\n}\n</code></pre></p> <p>Run Valgrind: <pre><code>valgrind ./uninit\n</code></pre></p> <p>Output: <pre><code>==567== Conditional jump or move depends on uninitialised value(s)\n==567==    at 0x1086C7: main (uninit.c:6)\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#4-debugging-with-vgdb","title":"4. Debugging with vgdb","text":""},{"location":"labs/debugging/lab22-valgrind/#41-combine-valgrind-and-gdb","title":"4.1 Combine Valgrind and GDB","text":"<p>Start program under Valgrind: <pre><code>valgrind --vgdb=yes --vgdb-error=0 ./my-app\n</code></pre></p> <p>Output: <pre><code>==567== TO CONTROL THIS PROCESS USING vgdb:\n==567==   target remote | /usr/lib/valgrind/vgdb --pid=567\n</code></pre></p> <p>In another terminal, start GDB: <pre><code>gdb ./my-app\n</code></pre></p> <p>In GDB, connect to vgdb: <pre><code>(gdb) target remote | vgdb --pid=567\n</code></pre></p> <p>Now GDB controls program running under Valgrind!</p>"},{"location":"labs/debugging/lab22-valgrind/#42-debug-memory-error-with-vgdb","title":"4.2 Debug Memory Error with vgdb","text":"<p>When Valgrind detects error, it pauses:</p> <pre><code>(gdb) continue\n# Valgrind detects invalid write\n\n(gdb) backtrace\n#0  strcpy () at vg_replace_strmem.c:523\n#1  0x1086c7 in main () at overflow.c:5\n\n(gdb) print buffer\n$1 = \"This strin\"  # Truncated due to overflow\n\n(gdb) x/20c buffer\n# Examine memory to see corruption\n</code></pre>"},{"location":"labs/debugging/lab22-valgrind/#43-monitor-specific-allocation","title":"4.3 Monitor Specific Allocation","text":"<pre><code>(gdb) monitor leak_check full reachable any\n# Request leak check via vgdb\n</code></pre>"},{"location":"labs/debugging/lab22-valgrind/#5-heap-profiling-with-massif","title":"5. Heap Profiling with Massif","text":""},{"location":"labs/debugging/lab22-valgrind/#51-profile-heap-usage","title":"5.1 Profile Heap Usage","text":"<p>Create <code>heap_growth.c</code>: <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    for (int i = 0; i &lt; 100; i++) {\n        malloc(1024 * 1024);  // 1MB allocations\n        sleep(1);\n    }\n    return 0;\n}\n</code></pre></p> <p>Run Massif: <pre><code>valgrind --tool=massif ./heap_growth\n</code></pre></p> <p>Massif creates <code>massif.out.&lt;pid&gt;</code> file.</p>"},{"location":"labs/debugging/lab22-valgrind/#52-visualize-heap-profile","title":"5.2 Visualize Heap Profile","text":"<pre><code>ms_print massif.out.567\n</code></pre> <p>Output: <pre><code>    MB\n100.0^                                               #\n     |                                             :#:\n     |                                           ::#::\n     |                                         :::#:::\n 50.0+                                       ::::#::::\n     |                                     :::::#:::::\n     |                                   ::::::#::::::\n     |                                 :::::::#:::::::\n     |                               ::::::::#::::::::\n  0.0+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@\n    +------------------------------------------------------\n       0                  Time                         100s\n\nNumber of snapshots: 50\n Detailed snapshots: [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n</code></pre></p> <p>ASCII graph shows heap growth over time.</p>"},{"location":"labs/debugging/lab22-valgrind/#53-identify-allocation-hotspots","title":"5.3 Identify Allocation Hotspots","text":"<p>At peak (snapshot 50): <pre><code>Snapshot 50\n================================================================================\n  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)\n--------------------------------------------------------------------------------\n 50     50,000,000      100,000,000      100,000,000             0            0\n\n99.8% (100,000,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.\n-&gt;99.8% (100,000,000B) 0x1086C7: main (heap_growth.c:5)\n</code></pre></p> <p>Shows 99.8% allocated at line 5 (<code>malloc</code>).</p>"},{"location":"labs/debugging/lab22-valgrind/#6-cache-profiling-with-cachegrind","title":"6. Cache Profiling with Cachegrind","text":""},{"location":"labs/debugging/lab22-valgrind/#61-profile-cache-misses","title":"6.1 Profile Cache Misses","text":"<pre><code>valgrind --tool=cachegrind ./my-app\n</code></pre> <p>Creates <code>cachegrind.out.&lt;pid&gt;</code>.</p>"},{"location":"labs/debugging/lab22-valgrind/#62-analyze-cache-performance","title":"6.2 Analyze Cache Performance","text":"<pre><code>cg_annotate cachegrind.out.567\n</code></pre> <p>Output: <pre><code>I1 cache:         16384 B, 64 B, 4-way associative\nD1 cache:         16384 B, 64 B, 4-way associative\nLL cache:       2097152 B, 64 B, 16-way associative\n\nIr           I1mr  ILmr          Dr        D1mr  DLmr          Dw        D1mw  DLmw \n================================================================================\n1,245,678      123    45     456,789      1,234    567     234,567         89    34  PROGRAM TOTALS\n\nIr           I1mr  ILmr          Dr        D1mr  DLmr          Dw        D1mw  DLmw  file:function\n--------------------------------------------------------------------------------\n  456,789       45    12     123,456        567    234      98,765         34    12  heap_growth.c:main\n</code></pre></p> <p>Metrics: - Ir: Instruction reads - Dr/Dw: Data reads/writes - I1mr/D1mr: L1 cache misses - ILmr/DLmr: Last-level cache misses</p>"},{"location":"labs/debugging/lab22-valgrind/#7-suppression-files","title":"7. Suppression Files","text":""},{"location":"labs/debugging/lab22-valgrind/#71-ignore-known-issues","title":"7.1 Ignore Known Issues","text":"<p>Create <code>valgrind.supp</code>: <pre><code>{\n   known_libc_leak\n   Memcheck:Leak\n   fun:malloc\n   fun:*libc*\n}\n</code></pre></p> <p>Use suppression: <pre><code>valgrind --suppressions=valgrind.supp ./my-app\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#72-generate-suppressions","title":"7.2 Generate Suppressions","text":"<pre><code>valgrind --gen-suppressions=all ./my-app\n</code></pre> <p>Prints suppression entries for each error.</p>"},{"location":"labs/debugging/lab22-valgrind/#8-performance-considerations","title":"8. Performance Considerations","text":""},{"location":"labs/debugging/lab22-valgrind/#81-valgrind-slowdown","title":"8.1 Valgrind Slowdown","text":"<p>Valgrind makes programs ~10-30x slower.</p> <p>Techniques: - Test with smaller datasets - Profile specific parts - Use on development builds only</p>"},{"location":"labs/debugging/lab22-valgrind/#82-optimize-valgrind-usage","title":"8.2 Optimize Valgrind Usage","text":"<p>Reduce overhead: <pre><code># Basic leak check (faster)\nvalgrind --leak-check=summary ./my-app\n\n# No leak check (even faster, just memory errors)\nvalgrind --leak-check=no ./my-app\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#9-real-world-examples","title":"9. Real-World Examples","text":""},{"location":"labs/debugging/lab22-valgrind/#91-find-leak-in-long-running-daemon","title":"9.1 Find Leak in Long-Running Daemon","text":"<pre><code># Start daemon under Valgrind\nvalgrind --leak-check=full --log-file=valgrind.log ./my-daemon &amp;\n\n# Let run for hours/days\n# ...\n\n# Request leak check\nkillall -USR1 my-daemon\n# Valgrind outputs leak report\n</code></pre>"},{"location":"labs/debugging/lab22-valgrind/#92-debug-embedded-memory-constraints","title":"9.2 Debug Embedded Memory Constraints","text":"<p>BeaglePlay has limited RAM:</p> <pre><code># Monitor heap usage\nvalgrind --tool=massif --massif-out-file=massif.out ./embedded-app\n\n# Analyze\nms_print massif.out\n# Find peak memory usage and allocation sites\n</code></pre>"},{"location":"labs/debugging/lab22-valgrind/#10-advanced-valgrind-options","title":"10. Advanced Valgrind Options","text":""},{"location":"labs/debugging/lab22-valgrind/#101-track-file-descriptors","title":"10.1 Track File Descriptors","text":"<pre><code>valgrind --track-fds=yes ./my-app\n</code></pre> <p>Reports unclosed file descriptors at exit.</p>"},{"location":"labs/debugging/lab22-valgrind/#102-detailed-leak-info","title":"10.2 Detailed Leak Info","text":"<pre><code>valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./my-app\n</code></pre> <p>Options: - <code>--show-leak-kinds=all</code>: Show all leak types - <code>--track-origins=yes</code>: Track origin of uninitialized values (slower)</p>"},{"location":"labs/debugging/lab22-valgrind/#11-troubleshooting","title":"11. Troubleshooting","text":""},{"location":"labs/debugging/lab22-valgrind/#111-valgrind-errors","title":"11.1 Valgrind Errors","text":"<p>\"Cannot execute binary file\": - Cross-compiled binary needs Valgrind on target</p> <p>\"vgpreload libraries not found\": <pre><code>export LD_LIBRARY_PATH=/usr/lib/valgrind\n</code></pre></p>"},{"location":"labs/debugging/lab22-valgrind/#112-false-positives","title":"11.2 False Positives","text":"<p>System libraries may show \"leaks\": - Use suppression files - Focus on your code's allocations</p>"},{"location":"labs/debugging/lab22-valgrind/#12-key-takeaways","title":"12. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Detected memory leaks with Memcheck 2. \u2705 Found buffer overflows and use-after-free 3. \u2705 Used vgdb for interactive debugging 4. \u2705 Profiled heap with Massif 5. \u2705 Analyzed cache performance with Cachegrind</p> <p>Essential Commands: - <code>valgrind --leak-check=full ./app</code>: Full leak check - <code>valgrind --tool=massif ./app</code>: Heap profiling - <code>valgrind --vgdb=yes ./app</code>: GDB integration - <code>ms_print massif.out.PID</code>: View heap profile</p> <p>Next Steps: - Lab 23: System-wide profiling with perf and ftrace - Lab 24: eBPF tracing</p>"},{"location":"labs/debugging/lab22-valgrind/#13-verification-checklist","title":"13. Verification Checklist","text":"<ul> <li>[ ] Can detect memory leaks</li> <li>[ ] Can identify buffer overflows</li> <li>[ ] Can debug with vgdb</li> <li>[ ] Understand heap profiling</li> <li>[ ] Can suppress known false positives</li> <li>[ ] Know when to use each Valgrind tool</li> </ul> <p>End of Lab 22</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>Valgrind is essential for producing robust, memory-safe software. The time invested in fixing memory errors pays dividends in stability, security, and easier maintenance.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/","title":"Lab 23: Performance Profiling and System Tracing","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about performance profiling:</p> <p>\"Performance profiling reveals where your program spends its time. Often, you'll discover it's spending most of its time in the last place you'd expect - rather like finding that Slartibartfast spent more time on Norway's fjords than on the award-winning coastline of Africa.\"</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#objectives","title":"Objectives","text":"<p>Master system-wide performance profiling with <code>perf</code>, function tracing with <code>ftrace</code>, and advanced visualization tools to identify CPU hotspots and optimize performance.</p> <p>What You'll Learn: - Profile CPU usage with <code>perf</code> - Generate flame graphs for visualization - Use ftrace for function-level kernel tracing - Trace with trace-cmd and visualize with KernelShark - Profile userspace with uprobes - Analyze lock contention and context switches</p> <p>Time Required: 4-5 hours</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board - Development workstation - Network connection</p> <p>Software: - Linux kernel with perf and ftrace support - perf-tools package - Python for flame graph generation</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#1-introduction-to-perf","title":"1. Introduction to perf","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#11-what-is-perf","title":"1.1 What is perf?","text":"<p><code>perf</code> is Linux's performance profiling tool using hardware performance counters and software events.</p> <p>Capabilities: - CPU profiling (sampling) - Hardware counter access (cache misses, branch mispredictions) - Kernel and userspace profiling - Flamegraph generation</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#12-install-perf","title":"1.2 Install perf","text":"<p>On BeaglePlay: <pre><code># Buildroot: Enable in kernel config\nBR2_LINUX_KERNEL_TOOL_PERF=y\n\n# Yocto: Add to image\nIMAGE_INSTALL:append = \" perf\"\n\n# Check installation\nperf --version\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#13-kernel-configuration","title":"1.3 Kernel Configuration","text":"<p>Required kernel configs: <pre><code>CONFIG_PERF_EVENTS=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_KALLSYMS=y\nCONFIG_KALLSYMS_ALL=y\nCONFIG_DEBUG_INFO=y\n</code></pre></p> <p>Verify: <pre><code>cat /boot/config-$(uname -r) | grep CONFIG_PERF_EVENTS\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#2-basic-perf-usage","title":"2. Basic perf Usage","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#21-record-performance-data","title":"2.1 Record Performance Data","text":"<p>Profile entire system: <pre><code>perf record -a sleep 10\n</code></pre></p> <p>Options: - <code>-a</code>: All CPUs - <code>-g</code>: Capture call graphs - <code>-F 999</code>: Sample at 999 Hz</p> <p>Profile specific command: <pre><code>perf record -g ./my-app\n</code></pre></p> <p>Outputs <code>perf.data</code> file.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#22-analyze-recorded-data","title":"2.2 Analyze Recorded Data","text":"<pre><code>perf report\n</code></pre> <p>Output: <pre><code>Samples: 45K of event 'cpu-clock:pppH', Event count (approx.): 11250000000\nOverhead  Command    Shared Object       Symbol\n  45.23%  my-app     my-app              [.] compute_heavy_function\n  12.34%  my-app     libc-2.31.so        [.] memcpy\n   8.45%  my-app     my-app              [.] process_data\n   5.67%  my-app     [kernel.kallsyms]   [k] copy_user_enhanced_fast_string\n</code></pre></p> <p>Columns: - Overhead: % of CPU time - Symbol: Function name - <code>[.]</code> = userspace, <code>[k]</code> = kernel</p> <p>Interactive navigation: - <code>Enter</code>: Drill into function - <code>a</code>: Annotate (show assembly) - <code>q</code>: Quit</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#23-create-test-program","title":"2.3 Create Test Program","text":"<p>Create <code>cpu_hog.c</code>: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid inefficient_sort(int *arr, int n) {\n    // O(n\u00b2) bubble sort\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n - 1; j++) {\n            if (arr[j] &gt; arr[j+1]) {\n                int tmp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = tmp;\n            }\n        }\n    }\n}\n\nvoid fast_memset(char *buf, int size) {\n    memset(buf, 0, size);\n}\n\nvoid slow_memset(char *buf, int size) {\n    for (int i = 0; i &lt; size; i++) {\n        buf[i] = 0;\n    }\n}\n\nint main() {\n    printf(\"CPU profiling test\\n\");\n\n    // Spend time in inefficient_sort\n    int *arr = malloc(5000 * sizeof(int));\n    for (int i = 0; i &lt; 5000; i++) arr[i] = rand();\n    inefficient_sort(arr, 5000);\n\n    // Spend time in memset functions\n    char *buf = malloc(100 * 1024 * 1024);\n    for (int i = 0; i &lt; 100; i++) {\n        fast_memset(buf, 100 * 1024 * 1024);\n    }\n    for (int i = 0; i &lt; 100; i++) {\n        slow_memset(buf, 1024 * 1024);\n    }\n\n    free(arr);\n    free(buf);\n    return 0;\n}\n</code></pre></p> <p>Compile: <pre><code>aarch64-linux-gnu-gcc -g -O2 -o cpu_hog cpu_hog.c\n</code></pre></p> <p>Profile: <pre><code>perf record -g ./cpu_hog\nperf report\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#3-advanced-perf-features","title":"3. Advanced perf Features","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#31-call-graph-profiling","title":"3.1 Call Graph Profiling","text":"<pre><code>perf record -g --call-graph dwarf ./cpu_hog\n</code></pre> <p>View call graph in report: <pre><code>- 45.23% inefficient_sort\n   - main\n      - __libc_start_main\n         - _start\n</code></pre></p> <p>Shows complete call chain.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#32-hardware-performance-counters","title":"3.2 Hardware Performance Counters","text":"<p>List available events: <pre><code>perf list\n</code></pre></p> <p>Output: <pre><code>Hardware event:\n  cycles                     [Hardware event]\n  instructions               [Hardware event]\n  cache-references           [Hardware event]\n  cache-misses               [Hardware event]\n  branch-instructions        [Hardware event]\n  branch-misses              [Hardware event]\n</code></pre></p> <p>Profile cache misses: <pre><code>perf stat -e cache-references,cache-misses ./cpu_hog\n</code></pre></p> <p>Output: <pre><code> Performance counter stats for './cpu_hog':\n\n        45,678,901      cache-references\n         5,678,012      cache-misses      #   12.43% of all cache refs\n\n       2.345678901 seconds time elapsed\n</code></pre></p> <p>12% cache miss rate indicates poor cache locality.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#33-top-like-monitoring","title":"3.3 Top-like Monitoring","text":"<pre><code>perf top\n</code></pre> <p>Real-time CPU hotspot display: <pre><code>Samples: 12K of event 'cpu-clock:pppH', 4000 Hz, Event count (approx.): 3056250000\nOverhead  Shared Object       Symbol\n  45.23%  cpu_hog             [.] inefficient_sort\n  12.34%  libc-2.31.so        [.] memset\n   5.67%  [kernel]            [k] finish_task_switch\n</code></pre></p> <p>Updated live as program runs.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#4-flame-graphs","title":"4. Flame Graphs","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#41-install-flamegraph-tools","title":"4.1 Install FlameGraph Tools","text":"<p>On workstation: <pre><code>git clone https://github.com/brendangregg/FlameGraph\ncd FlameGraph\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#42-generate-flame-graph","title":"4.2 Generate Flame Graph","text":"<p>Capture perf data: <pre><code>perf record -F 99 -a -g -- sleep 30\n</code></pre></p> <p>Convert to flame graph: <pre><code>perf script | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl &gt; flame.svg\n</code></pre></p> <p>View in browser: <pre><code>firefox flame.svg\n</code></pre></p> <p>Flame graph visualization: - X-axis: Alphabetical order (not time!) - Y-axis: Stack depth - Width: Time spent in function - Color: Random (for differentiation)</p> <p>Click to zoom into specific call stacks.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#43-interpret-flame-graph","title":"4.3 Interpret Flame Graph","text":"<p>Wide plateaus = CPU hotspots (optimization targets)</p> <p>Example: <pre><code>|----------------------- main() -----------------------|\n|         |------ inefficient_sort() ------|\n|         |   |---- many recursive calls ---|\n</code></pre></p> <p><code>inefficient_sort()</code> occupies large width = high CPU usage.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#5-introduction-to-ftrace","title":"5. Introduction to ftrace","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#51-what-is-ftrace","title":"5.1 What is ftrace?","text":"<p>ftrace is the kernel's built-in function tracer.</p> <p>Features: - Trace kernel functions - Measure function latency - Create custom trace events - Zero overhead when disabled</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#52-enable-ftrace","title":"5.2 Enable ftrace","text":"<p>Check if available: <pre><code>mount | grep tracefs\n# tracefs on /sys/kernel/tracing type tracefs (rw,relatime)\n</code></pre></p> <p>Or mount manually: <pre><code>mount -t tracefs nodev /sys/kernel/tracing\ncd /sys/kernel/tracing\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#53-basic-ftrace-usage","title":"5.3 Basic ftrace Usage","text":"<p>List available tracers: <pre><code>cat /sys/kernel/tracing/available_tracers\n</code></pre></p> <p>Output: <pre><code>function_graph function nop\n</code></pre></p> <p>Enable function tracer: <pre><code>echo function &gt; /sys/kernel/tracing/current_tracer\necho 1 &gt; /sys/kernel/tracing/tracing_on\n</code></pre></p> <p>View trace: <pre><code>cat /sys/kernel/tracing/trace | head -20\n</code></pre></p> <p>Output: <pre><code># tracer: function\n#\n# entries-in-buffer/entries-written: 45678/2345678   #P:4\n#\n#           TASK-PID   CPU#  TIMESTAMP  FUNCTION\n#              | |       |      |         |\n          &lt;idle&gt;-0     [000] 123.456789: rcu_idle_exit &lt;-cpu_startup_entry\n          &lt;idle&gt;-0     [000] 123.456790: arch_cpu_idle_exit &lt;-cpu_startup_entry\n          &lt;idle&gt;-0     [000] 123.456791: tick_nohz_idle_exit &lt;-cpu_startup_entry\n</code></pre></p> <p>Disable tracing: <pre><code>echo 0 &gt; /sys/kernel/tracing/tracing_on\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#6-function-graph-tracer","title":"6. Function Graph Tracer","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#61-trace-function-calls","title":"6.1 Trace Function Calls","text":"<pre><code>echo function_graph &gt; /sys/kernel/tracing/current_tracer\necho 1 &gt; /sys/kernel/tracing/tracing_on\nsleep 1\necho 0 &gt; /sys/kernel/tracing/tracing_on\ncat /sys/kernel/tracing/trace | head -50\n</code></pre> <p>Output: <pre><code> 0)               |  sys_read() {\n 0)               |    vfs_read() {\n 0)               |      rw_verify_area() {\n 0)   0.234 us    |        security_file_permission();\n 0)   1.234 us    |      }\n 0)               |      __vfs_read() {\n 0)  12.345 us    |        ext4_file_read_iter();\n 0)  13.567 us    |      }\n 0)  16.789 us    |    }\n 0)  18.012 us    |  }\n</code></pre></p> <p>Shows call hierarchy and duration.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#62-filter-specific-functions","title":"6.2 Filter Specific Functions","text":"<p>Trace only a specific function: <pre><code>echo schedule &gt; /sys/kernel/tracing/set_ftrace_filter\necho function &gt; /sys/kernel/tracing/current_tracer\necho 1 &gt; /sys/kernel/tracing/tracing_on\n</code></pre></p> <p>Clear filter: <pre><code>echo &gt; /sys/kernel/tracing/set_ftrace_filter\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#7-trace-cmd-ftrace-frontend","title":"7. trace-cmd (ftrace Frontend)","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#71-install-trace-cmd","title":"7.1 Install trace-cmd","text":"<pre><code># Yocto\nIMAGE_INSTALL:append = \" trace-cmd kernelshark\"\n\n# Buildroot\nmake menuconfig\n# Target packages -&gt; Debugging -&gt; trace-cmd\n\n# Verify\ntrace-cmd --version\n</code></pre>"},{"location":"labs/debugging/lab23-perf-ftrace/#72-record-trace","title":"7.2 Record Trace","text":"<p>System-wide trace: <pre><code>trace-cmd record -e sched -e syscalls -a sleep 5\n</code></pre></p> <p>Options: - <code>-e sched</code>: Scheduler events - <code>-e syscalls</code>: System calls - <code>-a</code>: All CPUs</p> <p>Creates <code>trace.dat</code> file.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#73-report-trace","title":"7.3 Report Trace","text":"<pre><code>trace-cmd report trace.dat | head -50\n</code></pre> <p>Output: <pre><code>cpus=4\n     sleep-567   [000] 123.456789: sys_nanosleep: \n     sleep-567   [000] 123.456790: sched_switch: prev_comm=sleep prev_pid=567 ==&gt; next_comm=swapper/0\n     &lt;idle&gt;-0     [000] 128.456789: sched_switch: prev_comm=swapper/0 ==&gt; next_comm=sleep next_pid=567\n     sleep-567   [000] 128.456790: sys_exit: ret=0\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#8-kernelshark-visualization","title":"8. KernelShark Visualization","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#81-install-kernelshark","title":"8.1 Install KernelShark","text":"<p>On workstation: <pre><code>sudo apt-get install kernelshark\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#82-view-trace","title":"8.2 View Trace","text":"<p>Transfer trace.dat from BeaglePlay: <pre><code>scp root@192.168.0.100:/root/trace.dat .\n</code></pre></p> <p>Open in KernelShark: <pre><code>kernelshark trace.dat\n</code></pre></p> <p>GUI shows: - Timeline view of events - CPU utilization graphs - Task scheduling visualization - Filterable by event type</p> <p>Interactive features: - Zoom in/out - Search events - Filter by task/CPU - Measure time intervals</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#9-userspace-probing-uprobes","title":"9. Userspace Probing (uprobes)","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#91-trace-userspace-functions","title":"9.1 Trace Userspace Functions","text":"<p>Add uprobe for function in binary: <pre><code># Find function address\nnm cpu_hog | grep inefficient_sort\n# 0000000000001234 T inefficient_sort\n\n# Add uprobe\necho 'p:my_probe /tmp/cpu_hog:0x1234' &gt; /sys/kernel/tracing/uprobe_events\n\n# Enable\necho 1 &gt; /sys/kernel/tracing/events/uprobes/my_probe/enable\n\n# Run program\n./cpu_hog\n\n# View trace\ncat /sys/kernel/tracing/trace\n</code></pre></p> <p>Output: <pre><code>cpu_hog-567   [001] 123.456789: my_probe: (0x1234)\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#92-trace-with-arguments","title":"9.2 Trace with Arguments","text":"<pre><code>echo 'p:my_probe /tmp/cpu_hog:0x1234 arg1=%di arg2=%si' &gt; /sys/kernel/tracing/uprobe_events\n</code></pre> <p>Captures function arguments (x86_64 calling convention: rdi, rsi, etc.).</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#10-performance-analysis-workflow","title":"10. Performance Analysis Workflow","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#101-identify-bottleneck","title":"10.1 Identify Bottleneck","text":"<p>Step 1: System-wide profiling <pre><code>perf top\n</code></pre></p> <p>Identify hot functions.</p> <p>Step 2: Detailed profiling <pre><code>perf record -g ./my-app\nperf report\n</code></pre></p> <p>Find call chains leading to hotspot.</p> <p>Step 3: Annotate assembly <pre><code>(gdb) disassemble inefficient_sort\n</code></pre></p> <p>Or in perf report, press <code>a</code> on function.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#102-fix-and-verify","title":"10.2 Fix and Verify","text":"<p>Optimize code, then re-profile: <pre><code>perf stat -e cycles,instructions ./my-app-optimized\n</code></pre></p> <p>Compare: - Cycles reduced? - Instructions per cycle (IPC) improved? - Cache misses decreased?</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#11-advanced-perf-recipes","title":"11. Advanced perf Recipes","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#111-off-cpu-analysis","title":"11.1 Off-CPU Analysis","text":"<p>Find where tasks are blocked: <pre><code>perf record -e sched:sched_switch -a -g -- sleep 10\nperf script | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl --color=io --title=\"Off-CPU Time\" &gt; offcpu.svg\n</code></pre></p> <p>Shows time waiting for I/O, locks, etc.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#112-lock-contention","title":"11.2 Lock Contention","text":"<pre><code>perf lock record -a -- sleep 10\nperf lock report\n</code></pre> <p>Output: <pre><code>Name                   acquired  contended avg wait (ns)   total wait (ns)\n&amp;mm-&gt;mmap_sem              1234         45        123456          5555520\n&amp;sb-&gt;s_type-&gt;i_mutex       5678        123         98765         12160095\n</code></pre></p> <p>High contention = lock optimization needed.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#113-context-switch-analysis","title":"11.3 Context Switch Analysis","text":"<pre><code>perf record -e context-switches -a -g -- sleep 10\nperf report\n</code></pre> <p>High context switch rate = scheduler thrashing.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#12-kernel-configuration-for-tracing","title":"12. Kernel Configuration for Tracing","text":""},{"location":"labs/debugging/lab23-perf-ftrace/#121-required-kernel-configs","title":"12.1 Required Kernel Configs","text":"<pre><code>CONFIG_FTRACE=y\nCONFIG_FUNCTION_TRACER=y\nCONFIG_FUNCTION_GRAPH_TRACER=y\nCONFIG_DYNAMIC_FTRACE=y\nCONFIG_KPROBES=y\nCONFIG_UPROBES=y\nCONFIG_TRACING=y\n</code></pre>"},{"location":"labs/debugging/lab23-perf-ftrace/#122-enable-in-yocto","title":"12.2 Enable in Yocto","text":"<p>In <code>local.conf</code> or machine config: <pre><code>KERNEL_FEATURES:append = \" cfg/ftrace.cfg\"\n</code></pre></p>"},{"location":"labs/debugging/lab23-perf-ftrace/#13-real-world-example-optimize-http-server","title":"13. Real-World Example: Optimize HTTP Server","text":"<p>Scenario: HTTP server using too much CPU.</p> <p>Step 1: Identify hotspot <pre><code>perf top\n# Shows 60% in parse_http_request()\n</code></pre></p> <p>Step 2: Profile in detail <pre><code>perf record -g -p $(pidof http-server)\n# Let run for 60 seconds\nperf report\n</code></pre></p> <p>Step 3: Flame graph <pre><code>perf script | stackcollapse-perf.pl | flamegraph.pl &gt; http.svg\n</code></pre></p> <p>Analysis: Wide plateau in <code>strcmp()</code> calls.</p> <p>Step 4: Optimize - Replace repeated <code>strcmp()</code> with hash table - Use <code>memcmp()</code> for fixed-length fields</p> <p>Step 5: Verify <pre><code>perf stat -p $(pidof http-server) sleep 60\n</code></pre></p> <p>Result: 40% CPU reduction.</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#14-key-takeaways","title":"14. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Profiled CPU usage with perf 2. \u2705 Generated and analyzed flame graphs 3. \u2705 Traced kernel functions with ftrace 4. \u2705 Visualized traces with KernelShark 5. \u2705 Used uprobes for userspace tracing 6. \u2705 Analyzed lock contention and context switches</p> <p>Essential Commands: - <code>perf record -g ./app</code>: Profile with call graphs - <code>perf top</code>: Real-time CPU monitoring - <code>trace-cmd record -e sched</code>: Trace scheduler - <code>perf script | flamegraph.pl</code>: Generate flame graph</p> <p>Next Steps: - Lab 24: eBPF and BCC tracing - Lab 25: Kernel debugging</p>"},{"location":"labs/debugging/lab23-perf-ftrace/#15-verification-checklist","title":"15. Verification Checklist","text":"<ul> <li>[ ] Can profile applications with perf</li> <li>[ ] Can generate flame graphs</li> <li>[ ] Understand ftrace function tracing</li> <li>[ ] Can use trace-cmd and KernelShark</li> <li>[ ] Can trace userspace with uprobes</li> <li>[ ] Can identify performance bottlenecks</li> </ul> <p>End of Lab 23</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>Performance profiling is essential for building efficient systems. The combination of perf, ftrace, and visualization tools provides complete visibility into system behavior, from userspace applications to kernel internals.</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/","title":"Lab 24: eBPF and BCC Tracing","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#objectives","title":"Objectives","text":"<p>Master eBPF (extended Berkeley Packet Filter) and BCC (BPF Compiler Collection) for creating custom, low-overhead tracing tools that run safely in the kernel.</p> <p>What You'll Learn: - Understand eBPF architecture and capabilities - Use BCC tools for system analysis - Write custom BCC tracing scripts in Python - Port BCC tools to embedded systems with libbpf - Trace network packets, disk I/O, and system calls - Create production-ready eBPF programs</p> <p>Time Required: 4-5 hours</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board - Development workstation - 2GB+ RAM</p> <p>Software: - Linux kernel 4.9+ with eBPF support - BCC tools installed - Python 3.x - LLVM/Clang compiler</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#1-introduction-to-ebpf","title":"1. Introduction to eBPF","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#11-what-is-ebpf","title":"1.1 What is eBPF?","text":"<p>eBPF enables running sandboxed programs in the kernel without changing kernel source code or loading kernel modules.</p> <p>Use cases: - Performance monitoring and profiling - Network packet filtering and manipulation - Security policy enforcement - System call filtering (seccomp-bpf)</p> <p>Advantages: - Safe: Verified by kernel to prevent crashes - Fast: JIT-compiled to native code - No kernel recompilation: Dynamic loading - Low overhead: Minimal performance impact</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#12-ebpf-architecture","title":"1.2 eBPF Architecture","text":"<pre><code>User Space:\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 BCC/libbpf  \u2502 \u2190 Python/C program\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 syscall(bpf)\nKernel Space:\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 BPF Verifier\u2502 \u2190 Ensures program safety\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  JIT Compiler\u2502 \u2190 Compile to ARM64 code\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 BPF Program \u2502 \u2190 Runs on events (kprobes, tracepoints, etc.)\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  BPF Maps   \u2502 \u2190 Shared data structures\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"labs/debugging/lab24-ebpf-bcc/#13-kernel-configuration","title":"1.3 Kernel Configuration","text":"<p>Required configs: <pre><code>CONFIG_BPF=y\nCONFIG_BPF_SYSCALL=y\nCONFIG_BPF_JIT=y\nCONFIG_HAVE_EBPF_JIT=y\nCONFIG_BPF_EVENTS=y\nCONFIG_KPROBES=y\nCONFIG_UPROBES=y\nCONFIG_TRACEPOINTS=y\n</code></pre></p> <p>Verify: <pre><code>cat /boot/config-$(uname -r) | grep CONFIG_BPF\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#2-install-bcc","title":"2. Install BCC","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#21-bcc-on-workstation","title":"2.1 BCC on Workstation","text":"<p>Ubuntu/Debian: <pre><code>sudo apt-get install bpfcc-tools python3-bpfcc libbpfcc-dev linux-headers-$(uname -r)\n</code></pre></p> <p>Verify: <pre><code>ls /usr/share/bcc/tools/\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#22-bcc-on-beagleplay-cross-compile","title":"2.2 BCC on BeaglePlay (Cross-Compile)","text":"<p>Yocto setup: <pre><code># In local.conf\nIMAGE_INSTALL:append = \" bcc python3-bcc kernel-dev\"\n\n# May need to build BCC from source for ARM64\n</code></pre></p> <p>Buildroot: <pre><code>make menuconfig\n# Target packages \u2192 Debugging \u2192 bcc\n</code></pre></p> <p>The Guide notes: BCC has heavy dependencies (LLVM, Python). For embedded, consider libbpf (Lab 24.7).</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#3-pre-built-bcc-tools","title":"3. Pre-Built BCC Tools","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#31-explore-available-tools","title":"3.1 Explore Available Tools","text":"<p>List tools: <pre><code>ls /usr/share/bcc/tools/\n</code></pre></p> <p>Categories: - File I/O: <code>opensnoop</code>, <code>statsnoop</code>, <code>filetop</code> - Disk I/O: <code>biotop</code>, <code>biolatency</code>, <code>biosnoop</code> - Network: <code>tcpconnect</code>, <code>tcpaccept</code>, <code>tcptop</code> - Process: <code>execsnoop</code>, <code>exitsnoop</code>, <code>pidstat</code> - Performance: <code>profile</code>, <code>offcputime</code>, <code>funccount</code></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#32-execsnoop-trace-process-execution","title":"3.2 execsnoop - Trace Process Execution","text":"<p>Monitor all new processes: <pre><code>sudo /usr/share/bcc/tools/execsnoop\n</code></pre></p> <p>Output: <pre><code>PCOMM            PID    PPID   RET ARGS\nbash             567    456      0 /usr/bin/ls -la\ngrep             568    567      0 /usr/bin/grep hello\n</code></pre></p> <p>Shows: - Parent process (PPID) - Return code (RET) - Full command arguments</p> <p>Use case: Detect unwanted process spawning.</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#33-opensnoop-trace-file-opens","title":"3.3 opensnoop - Trace File Opens","text":"<p>Monitor file opens: <pre><code>sudo /usr/share/bcc/tools/opensnoop\n</code></pre></p> <p>Output: <pre><code>PID    COMM               FD ERR PATH\n567    cat                 3   0 /etc/hostname\n568    vim                 3   0 /home/root/.vimrc\n569    systemd             4   2 /var/log/messages\n</code></pre></p> <p>ERR column: 0 = success, non-zero = error code.</p> <p>Use case: Debug \"file not found\" errors.</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#34-biotop-top-like-disk-io","title":"3.4 biotop - Top-Like Disk I/O","text":"<p>Monitor disk I/O by process: <pre><code>sudo /usr/share/bcc/tools/biotop\n</code></pre></p> <p>Output: <pre><code>PID    COMM             D MAJ MIN  DISK       I/O  Kbytes     AVGms\n567    tar              R 179   0  mmcblk0   1234  123456     12.34\n568    dd               W 179   0  mmcblk0    567   56789     23.45\n</code></pre></p> <p>Columns: - D: Direction (R=read, W=write) - I/O: Number of I/O operations - AVGms: Average latency</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#35-tcpconnect-trace-tcp-connections","title":"3.5 tcpconnect - Trace TCP Connections","text":"<p>Monitor outbound TCP connections: <pre><code>sudo /usr/share/bcc/tools/tcpconnect\n</code></pre></p> <p>Output: <pre><code>PID    COMM         IP SADDR            DADDR            DPORT\n567    curl         4  192.168.0.100    93.184.216.34    80\n568    ssh          4  192.168.0.100    192.168.0.1      22\n</code></pre></p> <p>Use case: Detect unexpected network connections.</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#4-write-custom-bcc-scripts","title":"4. Write Custom BCC Scripts","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#41-hello-world-bcc-program","title":"4.1 Hello World BCC Program","text":"<p>Create <code>hello_bcc.py</code>: <pre><code>#!/usr/bin/env python3\nfrom bcc import BPF\n\n# BPF program (C code)\nprog = \"\"\"\nint hello(void *ctx) {\n    bpf_trace_printk(\"Hello, eBPF!\\\\n\");\n    return 0;\n}\n\"\"\"\n\n# Load BPF program\nb = BPF(text=prog)\n\n# Attach to system call (execve)\nb.attach_kprobe(event=\"__arm64_sys_execve\", fn_name=\"hello\")\n\n# Print trace messages\nprint(\"Tracing execve... Hit Ctrl-C to stop.\")\ntry:\n    b.trace_print()\nexcept KeyboardInterrupt:\n    pass\n</code></pre></p> <p>Run: <pre><code>sudo python3 hello_bcc.py\n</code></pre></p> <p>In another terminal, run commands: <pre><code>ls\necho test\n</code></pre></p> <p>Output: <pre><code>Tracing execve... Hit Ctrl-C to stop.\n            bash-567   [000] d... 123.456789: hello: Hello, eBPF!\n            bash-568   [001] d... 123.567890: hello: Hello, eBPF!\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#42-count-system-calls","title":"4.2 Count System Calls","text":"<p>Create <code>syscall_count.py</code>: <pre><code>#!/usr/bin/env python3\nfrom bcc import BPF\nfrom time import sleep\n\nprog = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nBPF_HASH(syscall_count, u64);\n\nint count_syscalls(struct pt_regs *ctx) {\n    u64 syscall_nr = ctx-&gt;regs[8];  // ARM64: x8 register holds syscall number\n    u64 *count = syscall_count.lookup(&amp;syscall_nr);\n    if (count) {\n        (*count)++;\n    } else {\n        u64 initial = 1;\n        syscall_count.update(&amp;syscall_nr, &amp;initial);\n    }\n    return 0;\n}\n\"\"\"\n\nb = BPF(text=prog)\nb.attach_kprobe(event=\"__arm64_sys_call\", fn_name=\"count_syscalls\")\n\nprint(\"Counting syscalls for 10 seconds...\")\nsleep(10)\n\n# Print syscall counts\nprint(\"\\nTop 10 syscalls:\")\ncounts = b[\"syscall_count\"]\nfor k, v in sorted(counts.items(), key=lambda x: x[1].value, reverse=True)[:10]:\n    print(f\"Syscall {k.value:3d}: {v.value:6d} calls\")\n</code></pre></p> <p>Output: <pre><code>Top 10 syscalls:\nSyscall  63:  12345 calls  # read()\nSyscall  64:   9876 calls  # write()\nSyscall  57:   5432 calls  # close()\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#43-trace-function-arguments","title":"4.3 Trace Function Arguments","text":"<p>Create <code>trace_open.py</code>: <pre><code>#!/usr/bin/env python3\nfrom bcc import BPF\n\nprog = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n\nint trace_open(struct pt_regs *ctx, const char *filename) {\n    char fn[256];\n    bpf_probe_read_user(&amp;fn, sizeof(fn), (void *)filename);\n    bpf_trace_printk(\"open(%s)\\\\n\", fn);\n    return 0;\n}\n\"\"\"\n\nb = BPF(text=prog)\nb.attach_kprobe(event=\"do_sys_open\", fn_name=\"trace_open\")\n\nprint(\"Tracing open() syscalls... Ctrl-C to stop.\")\ntry:\n    b.trace_print()\nexcept KeyboardInterrupt:\n    pass\n</code></pre></p> <p>Output: <pre><code>cat-567   [000] d... 123.456789: trace_open: open(/etc/hostname)\nvim-568   [001] d... 123.567890: trace_open: open(/home/root/.vimrc)\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#5-bpf-maps-for-data-collection","title":"5. BPF Maps for Data Collection","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#51-bpf-map-types","title":"5.1 BPF Map Types","text":"<p>Common map types: - BPF_HASH: Hash table - BPF_ARRAY: Fixed-size array - BPF_PERF_ARRAY: Performance event array - BPF_RINGBUF: Ring buffer (kernel 5.8+)</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#52-use-hash-map-for-aggregation","title":"5.2 Use Hash Map for Aggregation","text":"<p>Create <code>io_latency.py</code>: <pre><code>#!/usr/bin/env python3\nfrom bcc import BPF\nfrom time import sleep\n\nprog = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blkdev.h&gt;\n\nBPF_HASH(start, struct request *);\nBPF_HISTOGRAM(latency_us);\n\nint trace_req_start(struct pt_regs *ctx, struct request *req) {\n    u64 ts = bpf_ktime_get_ns();\n    start.update(&amp;req, &amp;ts);\n    return 0;\n}\n\nint trace_req_done(struct pt_regs *ctx, struct request *req) {\n    u64 *tsp = start.lookup(&amp;req);\n    if (tsp) {\n        u64 delta = bpf_ktime_get_ns() - *tsp;\n        latency_us.increment(bpf_log2l(delta / 1000));\n        start.delete(&amp;req);\n    }\n    return 0;\n}\n\"\"\"\n\nb = BPF(text=prog)\nb.attach_kprobe(event=\"blk_account_io_start\", fn_name=\"trace_req_start\")\nb.attach_kprobe(event=\"blk_account_io_done\", fn_name=\"trace_req_done\")\n\nprint(\"Tracing block I/O latency... Hit Ctrl-C to stop.\")\ntry:\n    sleep(30)\nexcept KeyboardInterrupt:\n    pass\n\nprint(\"\\nI/O Latency Distribution (microseconds):\")\nb[\"latency_us\"].print_log2_hist(\"latency (us)\")\n</code></pre></p> <p>Output: <pre><code>I/O Latency Distribution (microseconds):\n     latency (us)    : count     distribution\n         0 -&gt; 1      : 0        |                                        |\n         2 -&gt; 3      : 5        |*                                       |\n         4 -&gt; 7      : 123      |***********                             |\n         8 -&gt; 15     : 456      |******************************************|\n        16 -&gt; 31     : 234      |*********************                   |\n        32 -&gt; 63     : 89       |********                                |\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#6-network-packet-tracing","title":"6. Network Packet Tracing","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#61-trace-tcp-packets","title":"6.1 Trace TCP Packets","text":"<p>Create <code>tcp_trace.py</code>: <pre><code>#!/usr/bin/env python3\nfrom bcc import BPF\n\nprog = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;net/sock.h&gt;\n#include &lt;bcc/proto.h&gt;\n\nint trace_tcp_sendmsg(struct pt_regs *ctx, struct sock *sk) {\n    u32 saddr = sk-&gt;__sk_common.skc_rcv_saddr;\n    u32 daddr = sk-&gt;__sk_common.skc_daddr;\n    u16 sport = sk-&gt;__sk_common.skc_num;\n    u16 dport = sk-&gt;__sk_common.skc_dport;\n\n    bpf_trace_printk(\"TCP %pI4:%d -&gt; %pI4:%d\\\\n\", &amp;saddr, sport, &amp;daddr, ntohs(dport));\n    return 0;\n}\n\"\"\"\n\nb = BPF(text=prog)\nb.attach_kprobe(event=\"tcp_sendmsg\", fn_name=\"trace_tcp_sendmsg\")\n\nprint(\"Tracing TCP sends... Ctrl-C to stop.\")\ntry:\n    b.trace_print()\nexcept KeyboardInterrupt:\n    pass\n</code></pre></p> <p>Output: <pre><code>curl-567   [000] d... 123.456789: trace_tcp_sendmsg: TCP 192.168.0.100:54321 -&gt; 93.184.216.34:80\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#7-porting-to-libbpf-embedded","title":"7. Porting to libbpf (Embedded)","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#71-why-libbpf","title":"7.1 Why libbpf?","text":"<p>BCC challenges on embedded: - Large dependencies (Python, LLVM) - Compiles BPF at runtime (slow, high memory)</p> <p>libbpf advantages: - Minimal dependencies (single C library) - Pre-compiled BPF bytecode - CO-RE (Compile Once, Run Everywhere)</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#72-write-libbpf-program","title":"7.2 Write libbpf Program","text":"<p>Create <code>hello_libbpf.bpf.c</code>: <pre><code>#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\nSEC(\"kprobe/__arm64_sys_execve\")\nint hello_bpf(void *ctx) {\n    char msg[] = \"Hello from libbpf!\\n\";\n    bpf_trace_printk(msg, sizeof(msg));\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre></p> <p>Compile to BPF bytecode: <pre><code>clang -O2 -target bpf -c hello_libbpf.bpf.c -o hello_libbpf.bpf.o\n</code></pre></p> <p>Loader program <code>hello_libbpf.c</code>: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;bpf/libbpf.h&gt;\n#include &lt;bpf/bpf.h&gt;\n\nint main() {\n    struct bpf_object *obj;\n    struct bpf_program *prog;\n    struct bpf_link *link;\n\n    // Load BPF object\n    obj = bpf_object__open_file(\"hello_libbpf.bpf.o\", NULL);\n    if (!obj) return 1;\n\n    bpf_object__load(obj);\n\n    // Attach to kprobe\n    prog = bpf_object__find_program_by_name(obj, \"hello_bpf\");\n    link = bpf_program__attach(prog);\n\n    printf(\"Attached. Check /sys/kernel/debug/tracing/trace_pipe\\n\");\n    getchar();  // Wait for Ctrl-C\n\n    bpf_link__destroy(link);\n    bpf_object__close(obj);\n    return 0;\n}\n</code></pre></p> <p>Compile loader: <pre><code>gcc -o hello_libbpf hello_libbpf.c -lbpf\n</code></pre></p> <p>Run: <pre><code>sudo ./hello_libbpf &amp;\nsudo cat /sys/kernel/debug/tracing/trace_pipe\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#8-real-world-use-cases","title":"8. Real-World Use Cases","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#81-detect-unauthorized-file-access","title":"8.1 Detect Unauthorized File Access","text":"<p>Monitor sensitive files: <pre><code>from bcc import BPF\n\nprog = \"\"\"\nint trace_open(struct pt_regs *ctx, const char *filename) {\n    char fn[256];\n    bpf_probe_read_user(&amp;fn, sizeof(fn), (void *)filename);\n\n    // Check for /etc/shadow access\n    char target[] = \"/etc/shadow\";\n    for (int i = 0; i &lt; sizeof(target); i++) {\n        if (fn[i] != target[i]) return 0;\n    }\n\n    bpf_trace_printk(\"ALERT: /etc/shadow accessed!\\\\n\");\n    return 0;\n}\n\"\"\"\n\nb = BPF(text=prog)\nb.attach_kprobe(event=\"do_sys_open\", fn_name=\"trace_open\")\nb.trace_print()\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#82-network-monitoring","title":"8.2 Network Monitoring","text":"<p>Track bandwidth per process: <pre><code># Use tcptop BCC tool\nsudo /usr/share/bcc/tools/tcptop\n</code></pre></p> <p>Output: <pre><code>PID    COMM         LADDR                 RADDR                  RX_KB  TX_KB\n567    curl         192.168.0.100:54321   93.184.216.34:80         128     12\n568    sshd         192.168.0.100:22      192.168.0.1:12345        456    234\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#9-performance-considerations","title":"9. Performance Considerations","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#91-overhead-measurement","title":"9.1 Overhead Measurement","text":"<p>eBPF has minimal overhead (~1-5%):</p> <pre><code># Baseline\ntime ./benchmark\n\n# With eBPF tracing\nsudo python3 trace_open.py &amp;\ntime ./benchmark\n</code></pre> <p>Compare execution times.</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#92-optimization-tips","title":"9.2 Optimization Tips","text":"<ul> <li>Use maps instead of <code>bpf_trace_printk()</code> for production</li> <li>Filter in kernel to reduce data transfer</li> <li>Use tail calls for complex logic</li> <li>Minimize map lookups</li> </ul>"},{"location":"labs/debugging/lab24-ebpf-bcc/#10-troubleshooting","title":"10. Troubleshooting","text":""},{"location":"labs/debugging/lab24-ebpf-bcc/#101-bpf-verifier-errors","title":"10.1 BPF Verifier Errors","text":"<p>Error: \"back-edge in program\" - Cause: Loop detected - Fix: Unroll loops or use bounded iteration</p> <p>Error: \"invalid access to map value\" - Cause: Unvalidated pointer - Fix: Check pointer before dereferencing</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#102-missing-kernel-symbols","title":"10.2 Missing Kernel Symbols","text":"<p>Error: \"could not open kprobe event\" <pre><code># Check available kprobes\ncat /sys/kernel/debug/tracing/available_filter_functions | grep do_sys_open\n</code></pre></p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#11-key-takeaways","title":"11. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Understood eBPF architecture 2. \u2705 Used pre-built BCC tools 3. \u2705 Wrote custom BCC Python scripts 4. \u2705 Used BPF maps for data collection 5. \u2705 Ported to libbpf for embedded 6. \u2705 Traced network and file I/O</p> <p>Essential Tools: - <code>execsnoop</code>: Monitor process execution - <code>opensnoop</code>: Trace file opens - <code>tcpconnect</code>: Track TCP connections - <code>biotop</code>: Disk I/O monitoring</p> <p>Next Steps: - Lab 25: Kernel debugging (KGDB, OOPS) - Lab 26: Crash dump analysis</p>"},{"location":"labs/debugging/lab24-ebpf-bcc/#12-verification-checklist","title":"12. Verification Checklist","text":"<ul> <li>[ ] Can run BCC pre-built tools</li> <li>[ ] Can write custom BCC scripts</li> <li>[ ] Understand BPF maps</li> <li>[ ] Can trace kernel and userspace events</li> <li>[ ] Know when to use BCC vs libbpf</li> <li>[ ] Can debug BPF verifier errors</li> </ul> <p>End of Lab 24</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>eBPF is revolutionizing Linux observability and security. It enables powerful, production-safe tracing without kernel modifications, making it ideal for debugging complex systems and enforcing security policies.</p>"},{"location":"labs/debugging/lab25-kernel-debugging/","title":"Lab 25: Kernel Debugging and OOPS Analysis","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about the Linux kernel:</p> <p>\"The Linux kernel is the brain of your embedded system. Unlike certain galactic presidents, it's actually quite good at multitasking, managing hardware, and not generally causing chaos. Though both occasionally crash when faced with infinite improbability.\"</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#objectives","title":"Objectives","text":"<p>Master kernel debugging techniques including KGDB for interactive debugging, analyzing kernel OOPS messages, using kernel debugging configs, and detecting kernel bugs with sanitizers.</p> <p>What You'll Learn: - Analyze kernel OOPS and panic messages - Use KGDB for interactive kernel debugging - Enable kernel debugging options (PROVE_LOCKING, DEBUG_ATOMIC_SLEEP) - Detect memory leaks with kmemleak - Debug deadlocks and race conditions - Understand kernel stack traces</p> <p>Time Required: 4-5 hours</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board - USB-to-Serial adapter (for KGDB) - Development workstation</p> <p>Software: - Kernel compiled with debugging symbols - GDB with ARM64 support - Serial console access</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#1-understanding-kernel-oops","title":"1. Understanding Kernel OOPS","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#11-what-is-a-kernel-oops","title":"1.1 What is a Kernel OOPS?","text":"<p>OOPS = kernel detected internal error but can continue running. Panic = fatal error, kernel halts.</p> <p>Common causes: - NULL pointer dereference - Invalid memory access - Stack corruption - Division by zero in kernel code</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#12-example-oops-message","title":"1.2 Example OOPS Message","text":"<p>Trigger OOPS with buggy module:</p> <p>Create <code>oops_module.c</code>: <pre><code>#include &lt;linux/module.h&gt;\n#include &lt;linux/kernel.h&gt;\n\nstatic int __init oops_init(void) {\n    int *ptr = NULL;\n    printk(KERN_INFO \"About to OOPS...\\n\");\n    *ptr = 42;  // NULL pointer dereference!\n    return 0;\n}\n\nstatic void __exit oops_exit(void) {\n    printk(KERN_INFO \"Exiting (never reached)\\n\");\n}\n\nmodule_init(oops_init);\nmodule_exit(oops_exit);\nMODULE_LICENSE(\"GPL\");\n</code></pre></p> <p>Makefile: <pre><code>obj-m += oops_module.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre></p> <p>Build and load: <pre><code>make\nsudo insmod oops_module.ko\n</code></pre></p> <p>OOPS output: <pre><code>Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\nMem abort info:\n  ESR = 0x96000045\n  EC = 0x25: DABT (current EL), IL = 32 bits\n  SET = 0, FnV = 0\n  EA = 0, S1PTW = 0\nData abort info:\n  ISV = 0, ISS = 0x00000045\n  CM = 0, WnR = 1\nuser pgtable: 4k pages, 48-bit VAs, pgdp=000000008a123000\n[0000000000000000] pgd=0000000000000000, p4d=0000000000000000\nInternal error: Oops: 96000045 [#1] SMP\nModules linked in: oops_module(O+) [last unloaded: oops_module]\nCPU: 0 PID: 567 Comm: insmod Tainted: G           O      5.10.0 #1\nHardware name: BeaglePlay (DT)\npstate: 60000005 (nZCv daif -PAN -UAO -TCO BTYPE=--)\npc : oops_init+0x14/0x1000 [oops_module]\nlr : do_one_initcall+0x50/0x230\nsp : ffff800012a3bd10\nx29: ffff800012a3bd10 x28: 0000000000000000 \nx27: ffff0000c1234000 x26: ffff800011234000\n...\nCall trace:\n oops_init+0x14/0x1000 [oops_module]\n do_one_initcall+0x50/0x230\n do_init_module+0x60/0x240\n load_module+0x1abc/0x1d00\n __do_sys_finit_module+0xac/0x100\n __arm64_sys_finit_module+0x20/0x30\n el0_svc_common.constprop.0+0x78/0x1c0\n do_el0_svc+0x24/0x90\n el0_svc+0x14/0x20\n el0_sync_handler+0xb0/0xc0\n el0_sync+0x180/0x1c0\nCode: d2800000 d503201f 910003fd f9001fe0 (b9000000)\n---[ end trace 123456789abcdef ]---\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#13-decode-oops","title":"1.3 Decode OOPS","text":"<p>Key information: 1. Fault address: <code>0000000000000000</code> (NULL) 2. PC (Program Counter): <code>oops_init+0x14</code> (crash location) 3. Call trace: Shows function call chain 4. Tainted: <code>O</code> = out-of-tree module 5. Code: Bytes at crash site</p> <p>Decode with addr2line: <pre><code>addr2line -e oops_module.ko oops_init+0x14\n# oops_module.c:7\n</code></pre></p> <p>Shows line 7: <code>*ptr = 42;</code></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#2-kernel-debugging-configuration","title":"2. Kernel Debugging Configuration","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#21-essential-debug-configs","title":"2.1 Essential Debug Configs","text":"<p>In kernel <code>.config</code>: <pre><code># Basic debugging\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_INFO=y\nCONFIG_DEBUG_INFO_DWARF4=y\n\n# Stack traces\nCONFIG_STACKTRACE=y\nCONFIG_FRAME_POINTER=y\n\n# Memory debugging\nCONFIG_SLUB_DEBUG=y\nCONFIG_DEBUG_KMEMLEAK=y\n\n# Lock debugging\nCONFIG_PROVE_LOCKING=y\nCONFIG_DEBUG_ATOMIC_SLEEP=y\nCONFIG_DEBUG_MUTEXES=y\nCONFIG_DEBUG_SPINLOCK=y\n\n# Additional checks\nCONFIG_DEBUG_LIST=y\nCONFIG_DEBUG_OBJECTS=y\nCONFIG_DEBUG_VM=y\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#22-enable-in-yocto","title":"2.2 Enable in Yocto","text":"<p>In <code>local.conf</code> or machine config: <pre><code>KERNEL_DEBUG_ENABLE = \"1\"\nKERNEL_FEATURES:append = \" features/debug/printk.scc features/debug/debug-kernel.scc\"\n</code></pre></p> <p>Or manually: <pre><code>bitbake -c menuconfig virtual/kernel\n# Kernel hacking \u2192 [*] Kernel debugging\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#23-enable-in-buildroot","title":"2.3 Enable in Buildroot","text":"<pre><code>make linux-menuconfig\n# Kernel hacking \u2192 [*] Kernel debugging\n</code></pre>"},{"location":"labs/debugging/lab25-kernel-debugging/#3-lock-debugging","title":"3. Lock Debugging","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#31-prove_locking-lockdep","title":"3.1 PROVE_LOCKING (Lockdep)","text":"<p>Detects: - Lock inversion (AB-BA deadlock) - Lock held too long - Incorrect lock usage</p> <p>Example deadlock: <pre><code>// Thread 1:\nmutex_lock(&amp;lock_a);\nmutex_lock(&amp;lock_b);  // AB order\nmutex_unlock(&amp;lock_b);\nmutex_unlock(&amp;lock_a);\n\n// Thread 2:\nmutex_lock(&amp;lock_b);\nmutex_lock(&amp;lock_a);  // BA order - DEADLOCK!\nmutex_unlock(&amp;lock_a);\nmutex_unlock(&amp;lock_b);\n</code></pre></p> <p>Lockdep output: <pre><code>======================================================\nWARNING: possible circular locking dependency detected\n======================================================\ntask_a/567 is trying to acquire lock:\nffff0000c1234000 (lock_b){+.+.}, at: thread_func+0x34/0x100\n\nbut task is already holding lock:\nffff0000c5678000 (lock_a){+.+.}, at: thread_func+0x24/0x100\n\nwhich lock already depends on the new lock:\n\nthe existing dependency chain (in reverse order) is:\n-&gt; #1 (lock_a){+.+.}:\n       lock_acquire+0xd0/0x200\n       _mutex_lock+0x80/0x100\n       thread_func+0x24/0x100\n\n-&gt; #0 (lock_b){+.+.}:\n       lock_acquire+0xd0/0x200\n       _mutex_lock+0x80/0x100\n       thread_func+0x34/0x100\n</code></pre></p> <p>Fix: Always acquire locks in same order.</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#32-debug_atomic_sleep","title":"3.2 DEBUG_ATOMIC_SLEEP","text":"<p>Detects sleeping in atomic context: <pre><code>spinlock_lock(&amp;my_lock);  // Atomic context\nmsleep(100);              // BUG: Sleep in atomic!\nspinlock_unlock(&amp;my_lock);\n</code></pre></p> <p>Error message: <pre><code>BUG: sleeping function called from invalid context at kernel/time/timer.c:1234\nin_atomic(): 1, irqs_disabled(): 0, pid: 567, name: my_task\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#4-memory-leak-detection-with-kmemleak","title":"4. Memory Leak Detection with kmemleak","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#41-enable-kmemleak","title":"4.1 Enable kmemleak","text":"<p>Kernel config: <pre><code>CONFIG_DEBUG_KMEMLEAK=y\n</code></pre></p> <p>Boot parameter: <pre><code># In bootargs\nkmemleak=on\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#42-trigger-scan","title":"4.2 Trigger Scan","text":"<p>Create leaky module: <pre><code>#include &lt;linux/module.h&gt;\n#include &lt;linux/slab.h&gt;\n\nstatic int __init leak_init(void) {\n    void *ptr = kmalloc(1024, GFP_KERNEL);\n    printk(\"Allocated but not freed: %p\\n\", ptr);\n    // Missing kfree(ptr)!\n    return 0;\n}\n\nmodule_init(leak_init);\nMODULE_LICENSE(\"GPL\");\n</code></pre></p> <p>Load module: <pre><code>insmod leak_module.ko\n</code></pre></p> <p>Scan for leaks: <pre><code>echo scan &gt; /sys/kernel/debug/kmemleak\ncat /sys/kernel/debug/kmemleak\n</code></pre></p> <p>Output: <pre><code>unreferenced object 0xffff0000c1234000 (size 1024):\n  comm \"insmod\", pid 567, jiffies 4294937296 (age 123.456s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [&lt;ffff800010123456&gt;] kmalloc_trace+0x80/0x100\n    [&lt;ffff800011234567&gt;] leak_init+0x20/0x1000 [leak_module]\n    [&lt;ffff800010345678&gt;] do_one_initcall+0x50/0x230\n</code></pre></p> <p>Shows allocation backtrace to find leak source.</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#5-interactive-kernel-debugging-with-kgdb","title":"5. Interactive Kernel Debugging with KGDB","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#51-configure-kgdb","title":"5.1 Configure KGDB","text":"<p>Kernel config: <pre><code>CONFIG_KGDB=y\nCONFIG_KGDB_SERIAL_CONSOLE=y\nCONFIG_MAGIC_SYSRQ=y\n</code></pre></p> <p>Boot parameters: <pre><code>kgdboc=ttyS0,115200 kgdbwait\n</code></pre></p> <p>Options: - <code>kgdboc</code>: KGDB over console (serial port) - <code>kgdbwait</code>: Wait for debugger at boot</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#52-connect-gdb","title":"5.2 Connect GDB","text":"<p>On BeaglePlay (boots and waits): <pre><code>KGDB: Waiting for connection from remote gdb...\n</code></pre></p> <p>On workstation: <pre><code>gdb vmlinux\n</code></pre></p> <p>In GDB: <pre><code>(gdb) target remote /dev/ttyUSB0\nRemote debugging using /dev/ttyUSB0\n0xffff800010123456 in default_idle ()\n\n(gdb) bt\n#0  0xffff800010123456 in default_idle ()\n#1  0xffff800010234567 in arch_cpu_idle ()\n#2  0xffff800010345678 in do_idle ()\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#53-set-breakpoints","title":"5.3 Set Breakpoints","text":"<pre><code>(gdb) break sys_read\nBreakpoint 1 at 0xffff800010456789: file fs/read.c, line 123.\n\n(gdb) continue\n</code></pre> <p>On BeaglePlay, trigger syscall: <pre><code>cat /etc/hostname\n</code></pre></p> <p>GDB hits breakpoint: <pre><code>Breakpoint 1, sys_read (fd=3, buf=0xfffffffff8, count=1024) at fs/read.c:123\n123     if (fd &lt; 0) return -EBADF;\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#54-examine-kernel-state","title":"5.4 Examine Kernel State","text":"<pre><code>(gdb) print current-&gt;comm\n$1 = \"cat\"\n\n(gdb) print current-&gt;pid\n$2 = 567\n\n(gdb) x/20i $pc\n# Disassemble current location\n</code></pre>"},{"location":"labs/debugging/lab25-kernel-debugging/#6-magic-sysrq-for-debugging","title":"6. Magic SysRq for Debugging","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#61-enable-magic-sysrq","title":"6.1 Enable Magic SysRq","text":"<p>Boot parameter: <pre><code>sysrq_always_enabled=1\n</code></pre></p> <p>Or at runtime: <pre><code>echo 1 &gt; /proc/sys/kernel/sysrq\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#62-useful-sysrq-commands","title":"6.2 Useful SysRq Commands","text":"<p>Via serial console: <pre><code>Alt+SysRq+&lt;key&gt;\n</code></pre></p> <p>Or via /proc: <pre><code>echo &lt;key&gt; &gt; /proc/sysrq-trigger\n</code></pre></p> <p>Common keys: - t: Dump task states (all processes) - m: Dump memory info - w: Dump blocked (waiting) tasks - l: Dump all CPUs' backtraces - p: Dump registers - s: Sync filesystems - u: Remount read-only - b: Reboot immediately</p> <p>Example - show all tasks: <pre><code>echo t &gt; /proc/sysrq-trigger\ndmesg | tail -100\n</code></pre></p> <p>Output: <pre><code>bash            S 567     1  0x00000000\nCall trace:\n __switch_to+0x80/0x100\n schedule+0x50/0x100\n schedule_timeout+0x80/0x150\n wait_for_completion+0x90/0x120\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#7-crash-dump-analysis","title":"7. Crash Dump Analysis","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#71-decode-code-bytes","title":"7.1 Decode Code Bytes","text":"<p>From OOPS: <pre><code>Code: d2800000 d503201f 910003fd f9001fe0 (b9000000)\n</code></pre></p> <p>Disassemble: <pre><code>echo \"d2800000 d503201f 910003fd f9001fe0 b9000000\" | \\\n  xxd -r -p | \\\n  aarch64-linux-gnu-objdump -D -b binary -m aarch64 -\n</code></pre></p> <p>Output: <pre><code>   0:   d2800000    mov x0, #0x0\n   4:   d503201f    nop\n   8:   910003fd    mov x29, sp\n   c:   f9001fe0    str x0, [sp, #56]\n  10:   b9000000    str w0, [x0]  \u2190 Crash here (store to x0=NULL)\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#72-analyze-with-crash-utility","title":"7.2 Analyze with crash Utility","text":"<p>Install crash: <pre><code>sudo apt-get install crash\n</code></pre></p> <p>Analyze vmcore: <pre><code>crash vmlinux vmcore\n</code></pre></p> <p>Commands: <pre><code>crash&gt; bt       # Backtrace\ncrash&gt; ps       # Process list\ncrash&gt; log      # Kernel log\ncrash&gt; files    # Open files\ncrash&gt; vm       # Virtual memory\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#8-debugging-kernel-modules","title":"8. Debugging Kernel Modules","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#81-load-module-with-debug-symbols","title":"8.1 Load Module with Debug Symbols","text":"<p>Build module with debug: <pre><code>EXTRA_CFLAGS := -g -O0\n</code></pre></p> <p>Load module: <pre><code>insmod my_module.ko\n</code></pre></p> <p>Find module load address: <pre><code>cat /sys/module/my_module/sections/.text\n# 0xffff800012340000\n</code></pre></p> <p>In GDB: <pre><code>(gdb) add-symbol-file my_module.ko 0xffff800012340000\n(gdb) break my_module_function\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#82-printk-debugging","title":"8.2 printk Debugging","text":"<p>Traditional but effective: <pre><code>printk(KERN_DEBUG \"my_func: value=%d\\n\", value);\n</code></pre></p> <p>View output: <pre><code>dmesg | grep my_func\n</code></pre></p> <p>Dynamic debug (preferred): <pre><code>pr_debug(\"my_func: value=%d\\n\", value);\n</code></pre></p> <p>Enable at runtime: <pre><code>echo 'module my_module +p' &gt; /sys/kernel/debug/dynamic_debug/control\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#9-real-world-debugging-example","title":"9. Real-World Debugging Example","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#91-scenario-system-hangs","title":"9.1 Scenario: System Hangs","text":"<p>Symptoms: System becomes unresponsive.</p> <p>Step 1: Check if kernel is alive <pre><code># Via SysRq\necho l &gt; /proc/sysrq-trigger\n# If this works, kernel is running\n</code></pre></p> <p>Step 2: Dump all tasks <pre><code>echo t &gt; /proc/sysrq-trigger\ndmesg &gt; /tmp/tasks.log\n</code></pre></p> <p>Step 3: Find blocked tasks <pre><code>echo w &gt; /proc/sysrq-trigger\n</code></pre></p> <p>Output: <pre><code>task                PC      stack   pid father\nmy_daemon       D    0   567    1 0x00000000\nCall trace:\n __switch_to+0x80/0x100\n schedule+0x50/0x100\n mutex_lock+0x40/0x80        \u2190 Waiting for mutex\n my_driver_ioctl+0x30/0x100\n ksys_ioctl+0x80/0x120\n</code></pre></p> <p>Analysis: <code>my_daemon</code> stuck waiting for mutex in driver.</p> <p>Step 4: Check lock holder <pre><code># If PROVE_LOCKING enabled\ncat /proc/lockdep\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#92-fix-and-verify","title":"9.2 Fix and Verify","text":"<p>Add debug output to driver: <pre><code>pr_debug(\"Acquiring lock...\\n\");\nmutex_lock(&amp;driver_lock);\npr_debug(\"Lock acquired\\n\");\n</code></pre></p> <p>Enable dynamic debug and reproduce.</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#10-kernel-sanitizers","title":"10. Kernel Sanitizers","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#101-kasan-kernel-address-sanitizer","title":"10.1 KASAN (Kernel Address Sanitizer)","text":"<p>Detects: - Use-after-free - Out-of-bounds access - Double-free</p> <p>Enable: <pre><code>CONFIG_KASAN=y\n</code></pre></p> <p>Example detection: <pre><code>BUG: KASAN: use-after-free in my_func+0x80/0x100\nWrite of size 4 at addr ffff0000c1234000 by task my_task/567\n\nAllocated by task 567:\n kasan_save_stack+0x20/0x40\n __kasan_kmalloc+0x80/0xa0\n my_func+0x20/0x100\n\nFreed by task 567:\n kasan_save_stack+0x20/0x40\n kasan_set_free_info+0x20/0x30\n __kasan_slab_free+0x100/0x130\n kfree+0x80/0x200\n my_func+0x60/0x100\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#102-ubsan-undefined-behavior-sanitizer","title":"10.2 UBSAN (Undefined Behavior Sanitizer)","text":"<p>Detects: - Integer overflow - Null pointer arithmetic - Out-of-bounds array access</p> <p>Enable: <pre><code>CONFIG_UBSAN=y\n</code></pre></p>"},{"location":"labs/debugging/lab25-kernel-debugging/#11-troubleshooting-tips","title":"11. Troubleshooting Tips","text":""},{"location":"labs/debugging/lab25-kernel-debugging/#111-system-wont-boot","title":"11.1 System Won't Boot","text":"<p>Serial console shows panic: 1. Note panic message and call trace 2. Check if related to recent kernel/driver change 3. Revert change or add debug output 4. Use <code>initcall_debug</code> boot param to see init sequence</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#112-intermittent-crashes","title":"11.2 Intermittent Crashes","text":"<p>Hard to reproduce: 1. Enable all debug options 2. Add extensive logging 3. Use stress testing tools 4. Consider race condition (add locking debug)</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#12-key-takeaways","title":"12. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Decoded kernel OOPS messages 2. \u2705 Enabled kernel debug configs 3. \u2705 Used KGDB for interactive debugging 4. \u2705 Detected memory leaks with kmemleak 5. \u2705 Debugged deadlocks with lockdep 6. \u2705 Analyzed crashes with Magic SysRq</p> <p>Essential Skills: - Read and understand kernel stack traces - Use addr2line to find crash source - Enable appropriate debug configs - Use Magic SysRq for hung systems</p> <p>Next Steps: - Lab 26: kdump and kexec for crash dumps</p>"},{"location":"labs/debugging/lab25-kernel-debugging/#13-verification-checklist","title":"13. Verification Checklist","text":"<ul> <li>[ ] Can decode kernel OOPS messages</li> <li>[ ] Understand kernel debug configs</li> <li>[ ] Can use KGDB for debugging</li> <li>[ ] Can detect memory leaks</li> <li>[ ] Can debug deadlocks</li> <li>[ ] Can use Magic SysRq commands</li> </ul> <p>End of Lab 25</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>Kernel debugging is essential for developing robust drivers and system software. Understanding OOPS messages, using debug configs, and leveraging KGDB enables you to diagnose even the most challenging kernel issues.</p>"},{"location":"labs/debugging/lab26-kdump-kexec/","title":"Lab 26: Crash Dump Analysis with kdump and kexec","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#objectives","title":"Objectives","text":"<p>Master crash dump collection with kdump/kexec for post-mortem analysis of kernel panics and system crashes, enabling root cause analysis even when systems are unresponsive.</p> <p>What You'll Learn: - Configure kexec for fast kernel reboots - Set up kdump for crash dump collection - Analyze crash dumps with the crash utility - Extract useful information from vmcore files - Automate crash dump collection - Debug production system failures</p> <p>Time Required: 3-4 hours</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board - 2GB+ RAM (kdump reserves memory) - Development workstation - Network/USB storage for dumps</p> <p>Software: - Kernel with kdump/kexec support - crash utility - kexec-tools package</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#1-understanding-kdump-and-kexec","title":"1. Understanding kdump and kexec","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#11-what-is-kexec","title":"1.1 What is kexec?","text":"<p>kexec allows booting a new kernel from currently running kernel without BIOS/bootloader.</p> <p>Use cases: - Fast reboots (skip firmware) - Crash dump collection - System recovery</p> <p>How it works: 1. Load new kernel into memory 2. When triggered, jump to new kernel 3. New kernel boots (no firmware reset)</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#12-what-is-kdump","title":"1.2 What is kdump?","text":"<p>kdump uses kexec to boot a crash kernel when primary kernel panics.</p> <p>Workflow: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Production      \u2502\n\u2502 Kernel Running  \u2502\n\u2502 (Reserve memory \u2502\n\u2502  for crash)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u2502 PANIC!\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 kexec Triggered \u2502\n\u2502 Boot Crash      \u2502\n\u2502 Kernel          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Crash Kernel    \u2502\n\u2502 - Minimal env   \u2502\n\u2502 - Save vmcore   \u2502\n\u2502 - Reboot        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#13-memory-reservation","title":"1.3 Memory Reservation","text":"<p>BeaglePlay has 2GB RAM: - Production kernel: 1.75GB - Crash kernel: 256MB (reserved at boot)</p> <p>Reserved region cannot be used by production kernel.</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#2-kernel-configuration","title":"2. Kernel Configuration","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#21-required-configs","title":"2.1 Required Configs","text":"<p>For kexec: <pre><code>CONFIG_KEXEC=y\nCONFIG_KEXEC_FILE=y\n</code></pre></p> <p>For kdump: <pre><code>CONFIG_CRASH_DUMP=y\nCONFIG_PROC_VMCORE=y\nCONFIG_SYSFS=y\nCONFIG_DEBUG_INFO=y\n</code></pre></p> <p>Additional useful: <pre><code>CONFIG_RELOCATABLE=y      # Kernel can run at different addresses\nCONFIG_RANDOMIZE_BASE=n   # Disable KASLR for easier debugging\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#22-enable-in-yocto","title":"2.2 Enable in Yocto","text":"<p>In <code>local.conf</code>: <pre><code>KERNEL_FEATURES:append = \" features/kexec/kexec-enable.scc\"\n\n# Or manually\nKERNEL_CONFIG_FRAGMENTS:append = \" ${THISDIR}/files/kdump.cfg\"\n</code></pre></p> <p>Create <code>kdump.cfg</code>: <pre><code>CONFIG_KEXEC=y\nCONFIG_KEXEC_FILE=y\nCONFIG_CRASH_DUMP=y\nCONFIG_PROC_VMCORE=y\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#23-verify-configuration","title":"2.3 Verify Configuration","text":"<pre><code>cat /boot/config-$(uname -r) | grep -E \"KEXEC|CRASH|VMCORE\"\n</code></pre> <p>Should show: <pre><code>CONFIG_KEXEC=y\nCONFIG_KEXEC_FILE=y\nCONFIG_CRASH_DUMP=y\nCONFIG_PROC_VMCORE=y\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#3-install-kdump-tools","title":"3. Install kdump Tools","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#31-install-kexec-tools","title":"3.1 Install kexec-tools","text":"<p>On BeaglePlay: <pre><code># Buildroot\nmake menuconfig\n# Target packages \u2192 System tools \u2192 kexec\n\n# Yocto\nIMAGE_INSTALL:append = \" kexec-tools\"\n\n# Debian/Ubuntu\napt-get install kexec-tools makedumpfile crash\n</code></pre></p> <p>Verify: <pre><code>kexec --version\n# kexec-tools 2.0.23\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#32-install-crash-utility","title":"3.2 Install crash Utility","text":"<p>On workstation (for analysis): <pre><code>sudo apt-get install crash linux-image-$(uname -r)-dbgsym\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#4-configure-crash-kernel","title":"4. Configure Crash Kernel","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#41-reserve-memory","title":"4.1 Reserve Memory","text":"<p>Boot parameter method:</p> <p>In U-Boot, edit bootargs: <pre><code>setenv bootargs \"console=ttyS0,115200 root=/dev/mmcblk0p2 crashkernel=256M\"\nsaveenv\n</code></pre></p> <p>Or in device tree: <pre><code>/ {\n    reserved-memory {\n        crash_dump@80000000 {\n            compatible = \"shared-dma-pool\";\n            reg = &lt;0x0 0x80000000 0x0 0x10000000&gt;; // 256MB at 2GB\n            no-map;\n        };\n    };\n};\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#42-verify-reservation","title":"4.2 Verify Reservation","text":"<pre><code>dmesg | grep crashkernel\n</code></pre> <p>Output: <pre><code>[    0.000000] Reserving 256MB of memory at 2048MB for crashkernel (System RAM: 2048MB)\n</code></pre></p> <p>Check reserved memory: <pre><code>cat /proc/iomem | grep Crash\n</code></pre></p> <p>Output: <pre><code>80000000-8fffffff : Crash kernel\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#5-load-crash-kernel","title":"5. Load Crash Kernel","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#51-load-kernel-and-initrd","title":"5.1 Load Kernel and Initrd","text":"<p>Prepare crash kernel: <pre><code>kexec -p /boot/vmlinuz-$(uname -r) \\\n      --initrd=/boot/initrd.img-$(uname -r) \\\n      --append=\"root=/dev/mmcblk0p2 console=ttyS0,115200 irqpoll maxcpus=1 reset_devices\"\n</code></pre></p> <p>Options: - <code>-p</code>: Load panic kernel - <code>--append</code>: Kernel command line for crash kernel - <code>irqpoll</code>: Poll for interrupts (useful after crash) - <code>maxcpus=1</code>: Use single CPU - <code>reset_devices</code>: Reset devices before crash kernel boots</p> <p>Verify loaded: <pre><code>cat /sys/kernel/kexec_crash_loaded\n# 1 (loaded), 0 (not loaded)\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#52-automatic-loading","title":"5.2 Automatic Loading","text":"<p>Create systemd service <code>/etc/systemd/system/kdump.service</code>: <pre><code>[Unit]\nDescription=Crash recovery kernel loader\nAfter=local-fs.target\n\n[Service]\nType=oneshot\nExecStart=/usr/sbin/kexec -p /boot/vmlinuz-$(uname -r) \\\n          --initrd=/boot/initrd.img-$(uname -r) \\\n          --append=\"root=/dev/mmcblk0p2 console=ttyS0,115200 irqpoll maxcpus=1 reset_devices\"\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n</code></pre></p> <p>Enable: <pre><code>systemctl enable kdump\nsystemctl start kdump\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#6-trigger-test-crash","title":"6. Trigger Test Crash","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#61-trigger-kernel-panic","title":"6.1 Trigger Kernel Panic","text":"<p>Method 1: SysRq trigger <pre><code>echo 1 &gt; /proc/sys/kernel/sysrq\necho c &gt; /proc/sysrq-trigger\n</code></pre></p> <p>Method 2: Kernel module <pre><code>#include &lt;linux/module.h&gt;\n#include &lt;linux/kernel.h&gt;\n\nstatic int __init panic_init(void) {\n    panic(\"Test panic for kdump!\");\n    return 0;\n}\n\nmodule_init(panic_init);\nMODULE_LICENSE(\"GPL\");\n</code></pre></p> <p>Load: <pre><code>insmod panic_module.ko\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#62-observe-crash-kernel-boot","title":"6.2 Observe Crash Kernel Boot","text":"<p>Serial console output: <pre><code>Kernel panic - not syncing: Test panic for kdump!\nCPU: 0 PID: 567 Comm: insmod Not tainted 5.10.0 #1\nHardware name: BeaglePlay (DT)\nCall trace:\n dump_backtrace+0x0/0x1a0\n show_stack+0x18/0x70\n dump_stack+0xb0/0xfc\n panic+0x140/0x320\n panic_init+0x14/0x1000 [panic_module]\n...\n---[ end Kernel panic - not syncing: Test panic for kdump! ]---\n</code></pre></p> <p>Then: <pre><code>kexec: Starting new kernel\nLinux version 5.10.0 (crash kernel)\n...\n</code></pre></p> <p>Crash kernel boots and saves dump.</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#7-save-crash-dump","title":"7. Save Crash Dump","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#71-configure-dump-location","title":"7.1 Configure Dump Location","text":"<p>In crash kernel's initramfs, create script:</p> <p><code>/etc/kdump.conf</code> or init script: <pre><code>#!/bin/sh\n# Save vmcore to USB drive\n\nmount /dev/sda1 /mnt\nmakedumpfile -c -d 31 /proc/vmcore /mnt/vmcore-$(date +%Y%m%d-%H%M%S)\numount /mnt\nreboot -f\n</code></pre></p> <p>makedumpfile options: - <code>-c</code>: Compress dump - <code>-d 31</code>: Filter pages (exclude free pages, cache, etc.) - Reduces dump size significantly (e.g., 2GB \u2192 200MB)</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#72-dump-filtering","title":"7.2 Dump Filtering","text":"<p>Filter levels (<code>-d</code> flag): - <code>1</code>: Exclude zero pages - <code>2</code>: Exclude cache pages - <code>4</code>: Exclude user pages - <code>8</code>: Exclude free pages - <code>31</code>: Exclude all above (minimal dump)</p> <p>Full dump (no filtering): <pre><code>cp /proc/vmcore /mnt/vmcore\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#8-analyze-crash-dump","title":"8. Analyze Crash Dump","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#81-transfer-dump-to-workstation","title":"8.1 Transfer Dump to Workstation","text":"<pre><code>scp beagleplay:/mnt/vmcore-20250115-123456 .\n</code></pre>"},{"location":"labs/debugging/lab26-kdump-kexec/#82-launch-crash-utility","title":"8.2 Launch crash Utility","text":"<pre><code>crash vmlinux vmcore-20250115-123456\n</code></pre> <p>Output: <pre><code>crash 7.3.0\nCopyright (C) 2002-2021  Red Hat, Inc.\n\n      KERNEL: vmlinux\n    DUMPFILE: vmcore-20250115-123456\n        CPUS: 4\n        DATE: Wed Jan 15 12:34:56 2025\n      UPTIME: 00:12:34\nLOAD AVERAGE: 0.15, 0.08, 0.03\n       TASKS: 95\n    NODENAME: beagleplay\n     RELEASE: 5.10.0\n     VERSION: #1 SMP PREEMPT Wed Jan 15 10:00:00 UTC 2025\n     MACHINE: aarch64  (2000 Mhz)\n      MEMORY: 2 GB\n       PANIC: \"Test panic for kdump!\"\n\ncrash&gt;\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#83-examine-crash-state","title":"8.3 Examine Crash State","text":"<p>Show panic message: <pre><code>crash&gt; log | tail -50\n</code></pre></p> <p>Backtrace of crashing task: <pre><code>crash&gt; bt\nPID: 567    TASK: ffff0000c1234000  CPU: 0   COMMAND: \"insmod\"\n #0 [ffff800012a3bd00] crash_kexec at ffff800010123456\n #1 [ffff800012a3bd20] __crash_kexec at ffff800010234567\n #2 [ffff800012a3bd40] panic at ffff800010345678\n #3 [ffff800012a3bd80] panic_init at ffff800011456789 [panic_module]\n #4 [ffff800012a3bda0] do_one_initcall at ffff800010567890\n #5 [ffff800012a3bdc0] do_init_module at ffff800010678901\n</code></pre></p> <p>Show process list: <pre><code>crash&gt; ps\n   PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM\n&gt;    0      0   0  ffff800012345000  RU   0.0       0      0  [swapper/0]\n     1      0   1  ffff0000c0001000  IN   0.1    5324   3208  systemd\n   567      1   0  ffff0000c1234000  PA   0.2   45632  12048  insmod\n</code></pre></p> <p><code>&gt;</code> marks crashing task.</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#84-examine-variables","title":"8.4 Examine Variables","text":"<p>Show global variables: <pre><code>crash&gt; p jiffies\njiffies = $1 = 750000\n</code></pre></p> <p>Show struct members: <pre><code>crash&gt; struct task_struct.comm ffff0000c1234000\n  comm = \"insmod\"\n</code></pre></p> <p>Examine memory: <pre><code>crash&gt; rd 0xffff800012a3bd00 20\nffff800012a3bd00:  ffff800010123456 ffff800012a3bd20   V.......  ......\nffff800012a3bd10:  0000000000000000 ffff0000c1234000   ........@.#.....\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#85-disassemble-code","title":"8.5 Disassemble Code","text":"<p>At crash location: <pre><code>crash&gt; dis panic_init\n0xffff800011456789 &lt;panic_init&gt;:        stp     x29, x30, [sp,#-16]!\n0xffff80001145678d &lt;panic_init+4&gt;:      mov     x29, sp\n0xffff800011456791 &lt;panic_init+8&gt;:      adrp    x0, 0xffff800011457000\n0xffff800011456795 &lt;panic_init+12&gt;:     add     x0, x0, #0x123\n0xffff800011456799 &lt;panic_init+16&gt;:     bl      0xffff800010345678 &lt;panic&gt;\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#9-advanced-crash-commands","title":"9. Advanced crash Commands","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#91-analyze-locks","title":"9.1 Analyze Locks","text":"<p>Show held locks: <pre><code>crash&gt; lock_stat\n</code></pre></p> <p>Blocked tasks: <pre><code>crash&gt; ps -m\n# Shows tasks in uninterruptible sleep (blocked on locks/I/O)\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#92-network-state","title":"9.2 Network State","text":"<p>Show network connections: <pre><code>crash&gt; net\n</code></pre></p> <p>Socket buffers: <pre><code>crash&gt; net -s\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#93-file-system-state","title":"9.3 File System State","text":"<p>Open files: <pre><code>crash&gt; files 567\n</code></pre></p> <p>Mounted filesystems: <pre><code>crash&gt; mount\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#10-automate-crash-analysis","title":"10. Automate Crash Analysis","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#101-crash-script","title":"10.1 crash Script","text":"<p>Create <code>analyze.crash</code>: <pre><code>log | tail -100\nbt\nps\nfiles\nsys\nquit\n</code></pre></p> <p>Run: <pre><code>crash -i analyze.crash vmlinux vmcore &gt; crash-report.txt\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#102-python-script-for-multiple-dumps","title":"10.2 Python Script for Multiple Dumps","text":"<p>Create <code>batch_analyze.sh</code>: <pre><code>#!/bin/bash\n\nfor vmcore in vmcore-*; do\n    echo \"=== Analyzing $vmcore ===\" &gt;&gt; analysis.log\n    crash -i analyze.crash vmlinux \"$vmcore\" &gt;&gt; analysis.log 2&gt;&amp;1\ndone\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#11-production-deployment","title":"11. Production Deployment","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#111-automated-dump-collection","title":"11.1 Automated Dump Collection","text":"<p>Create <code>/etc/init.d/kdump-save</code> (initramfs): <pre><code>#!/bin/sh\n\nDUMP_PATH=\"/var/crash\"\nDUMP_FILE=\"vmcore-$(cat /proc/sys/kernel/hostname)-$(date +%Y%m%d-%H%M%S)\"\n\n# Mount persistent storage\nmount /dev/sda1 /mnt || {\n    echo \"Failed to mount dump storage\"\n    exit 1\n}\n\n# Save dump\nmakedumpfile -c -d 31 /proc/vmcore \"/mnt/$DUMP_FILE\" || {\n    echo \"makedumpfile failed\"\n    umount /mnt\n    exit 1\n}\n\n# Save kernel log\ndmesg &gt; \"/mnt/$DUMP_FILE.log\"\n\numount /mnt\nreboot -f\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#112-remote-dump-upload","title":"11.2 Remote Dump Upload","text":"<p>Upload to server: <pre><code># In crash kernel\nnc dump-server.local 9999 &lt; /proc/vmcore\n\n# On server\nnc -l 9999 &gt; vmcore-$(date +%Y%m%d-%H%M%S)\n</code></pre></p>"},{"location":"labs/debugging/lab26-kdump-kexec/#12-troubleshooting","title":"12. Troubleshooting","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#121-crash-kernel-fails-to-load","title":"12.1 Crash Kernel Fails to Load","text":"<p>Error: \"Cannot allocate memory\"</p> <p>Solution: - Increase <code>crashkernel=</code> reservation - Check physical memory availability</p> <p>Error: \"Invalid argument\"</p> <p>Solution: - Verify kernel has <code>CONFIG_KEXEC=y</code> - Check kernel/initrd paths</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#122-no-vmcore-generated","title":"12.2 No vmcore Generated","text":"<p>Check: 1. <code>/proc/vmcore</code> exists in crash kernel? 2. Crash kernel has write access to dump location? 3. Sufficient disk space?</p> <p>Debug crash kernel: - Add <code>debug</code> to crash kernel command line - View serial console output</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#13-performance-considerations","title":"13. Performance Considerations","text":""},{"location":"labs/debugging/lab26-kdump-kexec/#131-memory-overhead","title":"13.1 Memory Overhead","text":"<p>BeaglePlay with 2GB RAM: - <code>crashkernel=256M</code>: 12.5% overhead - Consider smaller dump (128M) if memory-constrained - Use <code>makedumpfile -d 31</code> to minimize required space</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#132-dump-time","title":"13.2 Dump Time","text":"<p>Factors: - Dump size (compressed: faster) - Storage speed (USB 2.0 vs SD card) - Filter level (higher = faster)</p> <p>Typical times: - Full 2GB dump: 5-10 minutes - Filtered to 200MB: 1-2 minutes</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#14-key-takeaways","title":"14. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Configured kdump and kexec 2. \u2705 Reserved memory for crash kernel 3. \u2705 Triggered test crashes 4. \u2705 Collected and analyzed crash dumps 5. \u2705 Used crash utility for post-mortem analysis 6. \u2705 Automated dump collection</p> <p>Essential Commands: - <code>kexec -p vmlinuz</code>: Load crash kernel - <code>echo c &gt; /proc/sysrq-trigger</code>: Trigger test crash - <code>makedumpfile -c -d 31</code>: Create compressed dump - <code>crash vmlinux vmcore</code>: Analyze dump</p> <p>Workflow: 1. Configure and load crash kernel at boot 2. When panic occurs, kexec boots crash kernel 3. Crash kernel saves vmcore and reboots 4. Analyze vmcore with crash utility</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#15-verification-checklist","title":"15. Verification Checklist","text":"<ul> <li>[ ] Can reserve memory for crash kernel</li> <li>[ ] Can load crash kernel with kexec</li> <li>[ ] Can trigger test panic</li> <li>[ ] Crash kernel boots and saves dump</li> <li>[ ] Can analyze dump with crash utility</li> <li>[ ] Understand crash commands (bt, ps, log)</li> </ul> <p>End of Lab 26</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>kdump and kexec provide the ultimate safety net for production systems. Even when a kernel panic makes the system unresponsive, kdump ensures you can collect a complete crash dump for root cause analysis, turning mysterious failures into debuggable problems.</p>"},{"location":"labs/debugging/lab26-kdump-kexec/#congratulations","title":"\ud83c\udf89 Congratulations! \ud83c\udf89","text":"<p>You have completed the entire Linux Debugging track!</p> <p>26 Labs Completed: - Labs 1-9: Embedded Linux Fundamentals - Labs 10-18: Yocto Project Development - Labs 19-26: Advanced Debugging and Performance Analysis</p> <p>Skills Acquired: - \u2705 System monitoring and resource analysis - \u2705 Application debugging with GDB - \u2705 System call and library tracing - \u2705 Memory debugging with Valgrind - \u2705 Performance profiling (perf, ftrace, flame graphs) - \u2705 eBPF and BCC for custom tracing - \u2705 Kernel debugging (KGDB, OOPS analysis, lockdep) - \u2705 Crash dump analysis (kdump, crash utility)</p> <p>You are now equipped to: - Debug the most challenging embedded Linux issues - Optimize system and application performance - Analyze production crashes and kernel panics - Build robust, high-performance embedded systems</p> <p>Thank you for completing this comprehensive training! \ud83d\ude80</p>"},{"location":"labs/embedded-linux/","title":"Embedded Linux Labs - Index","text":"<p>Target Platform: BeaglePlay (TI AM62x Cortex-A53) Total Labs: 9 Estimated Time: 35-45 hours Difficulty: Beginner to Intermediate</p>"},{"location":"labs/embedded-linux/#lab-overview","title":"Lab Overview","text":"<p>This series of labs provides hands-on experience with embedded Linux development, from building a custom toolchain to creating complete embedded systems. All labs are adapted for the BeaglePlay platform using original examples and content.</p>"},{"location":"labs/embedded-linux/#prerequisites","title":"Prerequisites","text":"<p>Before starting these labs, ensure you have:</p> <ul> <li>Hardware: BeaglePlay board, USB-C cable, microSD card (32GB+)</li> <li>Software: Ubuntu 24.04 LTS (or similar Linux distribution)</li> <li>Skills: Linux command line, basic C programming, Git basics</li> <li>Time: Allocate 3-5 hours per lab for learning and experimentation</li> </ul> <p>See Quick Start Guide for initial setup.</p>"},{"location":"labs/embedded-linux/#lab-progression","title":"Lab Progression","text":""},{"location":"labs/embedded-linux/#lab-1-cross-compilation-toolchain","title":"Lab 1: Cross-Compilation Toolchain","text":"<p>Duration: 2-3 hours | Status: \u2705 Complete</p> <p>Build a custom ARM64 toolchain using Crosstool-NG for the BeaglePlay's Cortex-A53 processor.</p> <p>What you'll learn: - Cross-compilation fundamentals - Toolchain components (GCC, binutils, C library) - Crosstool-NG configuration - musl vs glibc vs uclibc - QEMU user-mode testing</p> <p>Deliverables: - Working <code>aarch64-linux-gcc</code> toolchain - Cross-compiled test programs - Understanding of sysroot and linking</p>"},{"location":"labs/embedded-linux/#lab-2-beagleplay-hardware-discovery","title":"Lab 2: BeaglePlay Hardware Discovery","text":"<p>Duration: 2-3 hours | Status: \ud83d\udd04 In Development</p> <p>Explore BeaglePlay hardware architecture and establish serial communication.</p> <p>What you'll learn: - TI AM62x SoC architecture - Serial console (UART) configuration - GPIO basics and LED control - Device Tree introduction - Expansion connectors (mikroBUS, Grove, QWIIC)</p> <p>Deliverables: - Working serial console connection - GPIO LED blink program - Hardware documentation</p>"},{"location":"labs/embedded-linux/#lab-3-u-boot-bootloader","title":"Lab 3: U-Boot Bootloader","text":"<p>Duration: 3-4 hours | Status: \ud83d\udccb Planned</p> <p>Build and configure U-Boot bootloader for BeaglePlay.</p> <p>What you'll learn: - Boot sequence and boot ROM - U-Boot compilation and configuration - Boot sources (SD card, eMMC) - U-Boot environment variables - Network boot (TFTP/NFS)</p> <p>Deliverables: - Custom U-Boot binary - Automated boot scripts - Network boot configuration</p>"},{"location":"labs/embedded-linux/#lab-4-linux-kernel","title":"Lab 4: Linux Kernel","text":"<p>Duration: 4-5 hours | Status: \ud83d\udccb Planned</p> <p>Configure, compile, and boot a custom Linux kernel.</p> <p>What you'll learn: - Kernel source organization - Kernel configuration (menuconfig) - Device Tree compilation - Cross-compiling the kernel - Kernel modules vs built-in drivers</p> <p>Deliverables: - Bootable Linux kernel - Custom Device Tree - Working peripherals (UART, GPIO)</p>"},{"location":"labs/embedded-linux/#lab-5-tiny-root-filesystem-busybox","title":"Lab 5: Tiny Root Filesystem (BusyBox)","text":"<p>Duration: 3-4 hours | Status: \ud83d\udccb Planned</p> <p>Create a minimal root filesystem from scratch.</p> <p>What you'll learn: - Essential filesystem hierarchy - BusyBox configuration and compilation - Static vs dynamic linking - Init system basics - Device nodes creation</p> <p>Deliverables: - Bootable minimal system (&lt;10 MB) - Custom init scripts - Understanding of \"what makes Linux work\"</p>"},{"location":"labs/embedded-linux/#lab-6-block-filesystems","title":"Lab 6: Block Filesystems","text":"<p>Duration: 2-3 hours | Status: \ud83d\udccb Planned</p> <p>Implement persistent storage with ext4 filesystems.</p> <p>What you'll learn: - ext4 filesystem basics - Partition schemes (GPT, MBR) - fstab configuration - Mounting filesystems - Read-only vs read-write rootfs</p> <p>Deliverables: - Multi-partition SD card - Proper filesystem mounting - Persistent data storage</p>"},{"location":"labs/embedded-linux/#lab-7-flash-filesystems","title":"Lab 7: Flash Filesystems","text":"<p>Duration: 2-3 hours | Status: \ud83d\udccb Planned</p> <p>Work with flash-optimized filesystems.</p> <p>What you'll learn: - SquashFS (compressed read-only) - OverlayFS (writable overlay) - MTD subsystem basics - Flash wear leveling - Update strategies</p> <p>Deliverables: - Compressed read-only rootfs - Writable overlay for config - Understanding flash constraints</p>"},{"location":"labs/embedded-linux/#lab-8-buildroot","title":"Lab 8: Buildroot","text":"<p>Duration: 4-5 hours | Status: \ud83d\udccb Planned</p> <p>Automate complete system builds with Buildroot.</p> <p>What you'll learn: - Buildroot architecture - Package selection and configuration - Custom board support (defconfig) - External trees - SDK generation</p> <p>Deliverables: - Automated complete system build - Custom Buildroot configuration - Application SDK</p>"},{"location":"labs/embedded-linux/#lab-9-application-development","title":"Lab 9: Application Development","text":"<p>Duration: 3-4 hours | Status: \ud83d\udccb Planned</p> <p>Develop and debug applications on BeaglePlay.</p> <p>What you'll learn: - Application cross-compilation - Remote debugging (gdbserver) - Hardware interfacing (I2C, GPIO) - Library dependencies (pkg-config) - Example: Nunchuk I2C driver</p> <p>Deliverables: - Custom application for BeaglePlay - Remote debugging session - Hardware interaction demo</p>"},{"location":"labs/embedded-linux/#learning-path-recommendations","title":"Learning Path Recommendations","text":""},{"location":"labs/embedded-linux/#sequential-path-recommended-for-beginners","title":"Sequential Path (Recommended for Beginners)","text":"<p>Follow labs 1-9 in order. Each lab builds on previous knowledge.</p> <pre><code>Lab 1 \u2192 Lab 2 \u2192 Lab 3 \u2192 Lab 4 \u2192 Lab 5 \u2192 Lab 6 \u2192 Lab 7 \u2192 Lab 8 \u2192 Lab 9\n</code></pre>"},{"location":"labs/embedded-linux/#fast-track-for-experienced-developers","title":"Fast Track (For Experienced Developers)","text":"<p>If you're comfortable with Linux and cross-compilation:</p> <pre><code>Lab 1 (skim) \u2192 Lab 4 \u2192 Lab 8 \u2192 Lab 9\n</code></pre>"},{"location":"labs/embedded-linux/#hardware-focus-for-hardware-engineers","title":"Hardware Focus (For Hardware Engineers)","text":"<p>Emphasis on hardware interfacing:</p> <pre><code>Lab 1 \u2192 Lab 2 \u2192 Lab 4 \u2192 Lab 9\n</code></pre>"},{"location":"labs/embedded-linux/#build-systems-focus-for-system-integrators","title":"Build Systems Focus (For System Integrators)","text":"<p>Focus on automated builds:</p> <pre><code>Lab 1 \u2192 Lab 5 \u2192 Lab 8\n</code></pre>"},{"location":"labs/embedded-linux/#lab-format","title":"Lab Format","text":"<p>Each lab follows a consistent structure:</p> <ol> <li>Objectives: What you'll achieve</li> <li>Background: Theory and concepts</li> <li>Prerequisites: What you need before starting</li> <li>Setup: Workspace preparation</li> <li>Step-by-Step Instructions: Detailed hands-on tasks</li> <li>Verification: How to test your work</li> <li>Troubleshooting: Common issues and solutions</li> <li>Going Further: Optional advanced challenges</li> <li>Key Takeaways: Summary of learning</li> <li>References: Additional resources</li> </ol>"},{"location":"labs/embedded-linux/#hardware-requirements","title":"Hardware Requirements","text":""},{"location":"labs/embedded-linux/#essential","title":"Essential","text":"<ul> <li>BeaglePlay board (~$99)</li> <li>USB-C cable (data + power)</li> <li>microSD card (32GB+, Class 10/UHS-I)</li> <li>Development PC (Ubuntu 24.04, 16GB RAM, 100GB storage)</li> </ul>"},{"location":"labs/embedded-linux/#recommended","title":"Recommended","text":"<ul> <li>Ethernet cable (for network boot)</li> <li>USB hub (for multiple devices)</li> <li>mikroBUS Click boards (for hardware experiments)</li> </ul>"},{"location":"labs/embedded-linux/#optional","title":"Optional","text":"<ul> <li>JTAG debugger (for kernel debugging)</li> <li>Logic analyzer (for protocol debugging)</li> <li>Oscilloscope (for hardware signals)</li> </ul>"},{"location":"labs/embedded-linux/#software-requirements","title":"Software Requirements","text":""},{"location":"labs/embedded-linux/#development-tools","title":"Development Tools","text":"<pre><code># Essential packages (installed in Lab 1)\nsudo apt install build-essential git\nsudo apt install gcc-aarch64-linux-gnu\nsudo apt install qemu-user\n\n# Additional tools (as needed per lab)\nsudo apt install device-tree-compiler\nsudo apt install u-boot-tools\nsudo apt install nfs-kernel-server\n</code></pre>"},{"location":"labs/embedded-linux/#recommended-tools","title":"Recommended Tools","text":"<ul> <li>Text Editor: VS Code, Vim, or Emacs</li> <li>Terminal Multiplexer: tmux or screen</li> <li>Serial Console: picocom or minicom</li> <li>Version Control: Git (for tracking progress)</li> </ul>"},{"location":"labs/embedded-linux/#lab-data-and-resources","title":"Lab Data and Resources","text":""},{"location":"labs/embedded-linux/#downloaded-materials","title":"Downloaded Materials","text":"<p>Each lab provides: - Sample source code (all original, not copied) - Configuration files - Helper scripts - Test data</p>"},{"location":"labs/embedded-linux/#external-resources","title":"External Resources","text":"<ul> <li>Kernel sources: kernel.org</li> <li>U-Boot sources: denx.de</li> <li>Buildroot: buildroot.org</li> <li>TI AM62x documentation</li> </ul>"},{"location":"labs/embedded-linux/#progress-tracking","title":"Progress Tracking","text":"<p>Track your progress through the labs:</p> <pre><code># Create progress tracker\ncat &gt; ~/embedded-linux-progress.md &lt;&lt; 'EOF'\n# Embedded Linux Labs Progress\n\n- [ ] Lab 1: Toolchain (0%)\n- [ ] Lab 2: Hardware (0%)\n- [ ] Lab 3: U-Boot (0%)\n- [ ] Lab 4: Kernel (0%)\n- [ ] Lab 5: Tiny System (0%)\n- [ ] Lab 6: Block FS (0%)\n- [ ] Lab 7: Flash FS (0%)\n- [ ] Lab 8: Buildroot (0%)\n- [ ] Lab 9: App Dev (0%)\n\n## Notes\nEOF\n</code></pre>"},{"location":"labs/embedded-linux/#getting-help","title":"Getting Help","text":""},{"location":"labs/embedded-linux/#before-asking","title":"Before Asking","text":"<ol> <li>Read error messages carefully (first error is usually the root cause)</li> <li>Search online for specific error messages</li> <li>Check documentation for the tool/command you're using</li> <li>Review lab instructions to ensure you didn't miss a step</li> </ol>"},{"location":"labs/embedded-linux/#resources","title":"Resources","text":"<ul> <li>BeagleBoard Forums: https://forum.beagleboard.org/</li> <li>Stack Overflow: Tag your questions with <code>beagleplay</code>, <code>embedded-linux</code></li> <li>GitHub Issues: Report documentation errors or unclear instructions</li> <li>IRC: #beagle on irc.libera.chat</li> </ul>"},{"location":"labs/embedded-linux/#contributing","title":"Contributing","text":"<p>Found an error? Have an improvement? Submit a pull request! See CONTRIBUTING.md for guidelines.</p>"},{"location":"labs/embedded-linux/#tips-for-success","title":"Tips for Success","text":"<ol> <li>Don't rush: Each lab takes time to understand - it's learning, not a race</li> <li>Take notes: Document issues you encounter and how you solved them</li> <li>Experiment: Try variations and optional challenges</li> <li>Ask questions: Don't stay stuck - seek help after 10-15 minutes</li> <li>Have fun: Embedded Linux is fascinating - enjoy the journey!</li> </ol>"},{"location":"labs/embedded-linux/#advanced-topics-future-labs","title":"Advanced Topics (Future Labs)","text":"<p>After completing these 9 labs, consider:</p> <ul> <li>Yocto Project (Labs 10-14): Industrial build system</li> <li>Linux Debugging (Labs 15-21): Profiling, tracing, performance analysis</li> <li>Real-Time Linux: PREEMPT-RT, Xenomai</li> <li>Device Drivers: Writing custom kernel drivers</li> <li>Security: Secure boot, encryption, hardening</li> </ul>"},{"location":"labs/embedded-linux/#license-and-attribution","title":"License and Attribution","text":"<p>All lab content is original work created for this learning repository.</p> <p>Inspiration: Lab structure inspired by professional embedded Linux training, adapted with original examples and explanations.</p> <p>License: CC BY-SA 4.0 (same as parent repository)</p> <p>Hardware: BeaglePlay specifications and documentation \u00a9 BeagleBoard.org Foundation</p> <p>Ready to start? \u2192 Lab 1: Cross-Compilation Toolchain</p> <p>Last updated: November 25, 2025 Total labs documented: 1/9 Status: Active development</p>"},{"location":"labs/embedded-linux/lab01-toolchain/","title":"Lab 1: Building a Cross-Compilation Toolchain","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about cross-compilation toolchains:</p> <p>\"A cross-compilation toolchain is a bit like a babel fish for computer architectures. It translates your perfectly reasonable x86_64 instructions into ARM64 gibberish that only a BeaglePlay can understand. The main difference is that the babel fish was designed by a benevolent creator who wanted universal communication, whereas the toolchain was designed by compiler engineers who, while generally quite pleasant at parties, seem to have been educated by Vogons.\"</p> <p>This is, of course, unfair to compiler engineers. Most of them are very nice people once you get to know them. They just happen to work in a field where a missing semicolon can cause your computer to develop what can only be described as electronic depression.</p> <p>Platform: BeaglePlay (ARM Cortex-A53, 64-bit) - Also known as \"the computer that speaks a different language\" Prerequisites: Linux command line basics, C programming, your towel Duration: 2-3 hours (or approximately 42 minutes in improbable circumstances) (or 42 minutes if you're a time traveler) Difficulty: \u2b50\u2b50\u2b50\u2606\u2606 (3/5 on the Vogon poetry scale)</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#objectives","title":"Objectives","text":"<p>By the end of this lab, you will be able to:</p> <ul> <li>[ ] Understand the components of a cross-compilation toolchain (without your brain leaking out your ears)</li> <li>[ ] Configure Crosstool-NG for ARM64 architecture (mostly harmless)</li> <li>[ ] Build a custom toolchain targeting the BeaglePlay's Cortex-A53 processor</li> <li>[ ] Test the toolchain with QEMU user-mode emulation</li> <li>[ ] Understand the difference between C libraries (musl, glibc, uclibc) and why this matters more than you'd think</li> </ul>"},{"location":"labs/embedded-linux/lab01-toolchain/#background","title":"Background","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#what-is-a-cross-compilation-toolchain","title":"What is a Cross-Compilation Toolchain?","text":"<p>The Guide's definition of cross-compilation toolchain:</p> <p>Cross-compilation toolchain (n): A set of development tools that allows you to compile code on one platform (your development PC with its fancy x86_64 processor) to run on a completely different platform (the BeaglePlay with its ARM64/AARCH64 processor, which speaks an entirely different dialect of machine code). This is roughly equivalent to writing a letter in English while sitting in London, having it automatically translated to Betelgeusean, and then mailing it to someone in the Betelgeuse system who has never heard of Earth. The remarkable thing is that it actually works.</p> <p>Components (All essential, like knowing where your towel is): - Compiler: <code>gcc</code> or <code>clang</code> - translates C/C++ to machine code (thinks it knows everything) - Binutils: Tools like <code>ld</code> (linker), <code>as</code> (assembler), <code>objdump</code>, <code>ar</code> (the supporting cast) - C Library: Provides standard functions (printf, malloc, etc.) - the babel fish of function calls - Kernel Headers: Interface to Linux system calls (Vogon poetry for the kernel) - GDB: GNU Debugger for debugging cross-compiled programs (Marvin's favorite tool)</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#why-build-your-own-toolchain","title":"Why Build Your Own Toolchain?","text":"<p>You might reasonably ask, \"Why build a toolchain when pre-built ones exist?\" This is an excellent question, showing you have the survival instincts Arthur Dent lacked when faced with planetary demolition.</p> <p>While pre-built toolchains exist (like <code>gcc-aarch64-linux-gnu</code>), building your own offers:</p> <ol> <li>Full Control: Choose specific GCC version, C library, optimizations (be your own Slartibartfast)</li> <li>Compatibility: Match exact kernel version and system requirements (avoid Vogon-level compatibility issues)</li> <li>Size Optimization: Exclude unnecessary features for embedded systems (pack light, like for hitchhiking)</li> <li>Learning: Understanding what's inside the \"black box\" (because curiosity didn't kill Ford Prefect)</li> </ol> <p>Ford Prefect's note: \"Always know how your toolchain works. You never know when you'll need to rebuild it at short notice, possibly while hanging onto the side of a hyperspace freighter.\"</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#c-library-choices","title":"C Library Choices","text":"<p>The Guide's take on C libraries: \"Choosing a C library is like choosing which Pan Galactic Gargle Blaster to drink. They all do roughly the same thing, but with vastly different levels of consequences.\"</p> Library Size Features Best For Guide Rating glibc Large (~2MB) Full POSIX, best compatibility Desktop, servers \"Mostly Harmless\" musl Small (~600KB) Clean, standards-compliant Modern embedded \"Froody\" uclibc-ng Tiny (~400KB) Configurable features Memory-constrained systems \"Hoopy\" <p>For this lab: We'll use musl - it's lightweight yet fully functional.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#prerequisites-check","title":"Prerequisites Check","text":"<p>Before starting, ensure you have:</p> <pre><code># Check available disk space (need ~10 GB)\ndf -h ~\n\n# Check RAM (need at least 4 GB)\nfree -h\n\n# Verify Ubuntu version\nlsb_release -a\n# Recommended: Ubuntu 24.04 LTS\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#setup","title":"Setup","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#workspace-preparation","title":"Workspace Preparation","text":"<pre><code># Create lab directory\nmkdir -p ~/embedded-linux-labs/lab01-toolchain\ncd ~/embedded-linux-labs/lab01-toolchain\n\n# Set environment variable for convenience\nexport LAB_DIR=$PWD\necho \"Lab directory: $LAB_DIR\"\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#required-packages","title":"Required Packages","text":"<pre><code># Update package database\nsudo apt update\n\n# Install build dependencies\nsudo apt install -y \\\n    build-essential \\\n    git \\\n    autoconf \\\n    bison \\\n    flex \\\n    texinfo \\\n    help2man \\\n    gawk \\\n    libtool-bin \\\n    libncurses5-dev \\\n    unzip \\\n    gettext \\\n    python3 \\\n    qemu-user\n\n# Verify installations\ngcc --version\ngit --version\npython3 --version\n</code></pre> <p>Expected: GCC 11.4 or newer, Git 2.34 or newer, Python 3.10 or newer</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-1-getting-crosstool-ng","title":"Part 1: Getting Crosstool-NG","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#step-11-clone-crosstool-ng-repository","title":"Step 1.1: Clone Crosstool-NG Repository","text":"<p>Goal: Download the Crosstool-NG source code</p> <pre><code># Clone from GitHub\ngit clone https://github.com/crosstool-ng/crosstool-ng.git\ncd crosstool-ng\n\n# Checkout tested version\ngit checkout crosstool-ng-1.26.0\n\n# Verify checkout\ngit describe --tags\n</code></pre> <p>Expected Output: <pre><code>crosstool-ng-1.26.0\n</code></pre></p> <p>What is Crosstool-NG? A flexible framework for building cross-compilation toolchains. It automates downloading, configuring, and building all toolchain components.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-12-bootstrap-crosstool-ng","title":"Step 1.2: Bootstrap Crosstool-NG","text":"<p>Goal: Generate configuration scripts</p> <pre><code># Run bootstrap to create configure script\n./bootstrap\n\n# Check for generated files\nls -l configure\n</code></pre> <p>Expected: You should see a <code>configure</code> script created</p> <p>Troubleshooting: - Error: \"autoconf: command not found\"   - Solution: <code>sudo apt install autoconf automake</code></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-13-build-crosstool-ng","title":"Step 1.3: Build Crosstool-NG","text":"<p>Goal: Compile Crosstool-NG for local use</p> <pre><code># Configure for local installation (no system-wide install)\n./configure --enable-local\n\n# Build (takes ~2 minutes)\nmake -j$(nproc)\n\n# Verify build\n./ct-ng version\n</code></pre> <p>Expected Output: <pre><code>This is crosstool-NG version crosstool-ng-1.26.0\n</code></pre></p> <p>What is <code>--enable-local</code>? Keeps ct-ng in the current directory instead of installing to <code>/usr/local/bin</code>. Useful for testing without root privileges.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-2-configuring-the-toolchain","title":"Part 2: Configuring the Toolchain","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#step-21-list-available-samples","title":"Step 2.1: List Available Samples","text":"<p>Goal: Explore pre-configured toolchain templates</p> <pre><code># List all sample configurations\n./ct-ng list-samples\n\n# Filter for ARM64 samples\n./ct-ng list-samples | grep aarch64\n</code></pre> <p>Expected Output (partial): <pre><code>aarch64-unknown-linux-gnu\naarch64-unknown-linux-musl\naarch64-rpi3-linux-gnu\n</code></pre></p> <p>What are samples? Pre-made configurations for common architectures. We'll use one as a starting point and customize it.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-22-load-base-configuration","title":"Step 2.2: Load Base Configuration","text":"<p>Goal: Start with ARM64/musl sample</p> <pre><code># Load the aarch64-unknown-linux-musl sample\n./ct-ng aarch64-unknown-linux-musl\n\n# Verify configuration loaded\nls -l .config\n</code></pre> <p>Expected: <code>.config</code> file created with default settings</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-23-customize-configuration","title":"Step 2.3: Customize Configuration","text":"<p>Goal: Optimize for BeaglePlay's Cortex-A53 processor</p> <pre><code># Launch menuconfig interface\n./ct-ng menuconfig\n</code></pre> <p>Navigation: Use arrow keys, Enter to select, Space to toggle, <code>/</code> to search, <code>?</code> for help</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#configuration-changes","title":"Configuration Changes:","text":"<p>1. Path and misc options: - Navigate to: <code>Paths and misc options</code> - Enable: <code>\u2611 Try features marked as EXPERIMENTAL</code> - Why: Allows newer GCC versions and features</p> <p>2. Target options: - Navigate to: <code>Target options</code> - Set <code>Emit assembly for CPU (ARCH_CPU)</code>: <code>cortex-a53</code>   - Why: BeaglePlay uses TI AM62 with Cortex-A53 cores - Verify <code>Endianness</code>: <code>Little endian</code> (default)   - Why: ARM Cortex-A53 uses little-endian mode</p> <p>3. Toolchain options: - Navigate to: <code>Toolchain options</code> - Set <code>Tuple's vendor string</code>: <code>beagleplay</code>   - Result: Toolchain will be named <code>aarch64-beagleplay-linux-musl</code> - Set <code>Tuple's alias</code>: <code>aarch64-linux</code>   - Why: Allows using shorter command <code>aarch64-linux-gcc</code></p> <p>4. Operating System: - Navigate to: <code>Operating System \u2192 Version of linux</code> - Select: <code>6.6.x</code> (or closest available LTS version)   - Why: Match kernel version you'll use on BeaglePlay   - Important: Toolchain kernel headers should NOT be newer than target kernel</p> <p>5. C-library: - Navigate to: <code>C-library</code> - Verify: <code>C library</code> = <code>musl</code> (LIBC_MUSL) - Keep default musl version (latest stable)   - Why: Lightweight, modern, clean codebase</p> <p>6. C compiler: - Navigate to: <code>C compiler</code> - Set <code>Version of gcc</code>: <code>13.3.0</code> or latest stable - Verify: <code>\u2611 C++</code> is enabled   - Why: Many embedded projects use C++</p> <p>7. Debug facilities: - Navigate to: <code>Debug facilities</code> - Disable all debug tools (gdb, strace, ltrace)   - Why: We'll build these separately later with better control   - Saves compilation time and disk space</p> <p>Save and Exit: Press <code>S</code> to save, then <code>Q</code> to quit</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-24-review-configuration","title":"Step 2.4: Review Configuration","text":"<pre><code># Display current configuration\n./ct-ng show-config\n\n# Check tuple (toolchain naming)\n./ct-ng show-tuple\n</code></pre> <p>Expected: <pre><code>aarch64-beagleplay-linux-musl\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-3-building-the-toolchain","title":"Part 3: Building the Toolchain","text":"<p>The Guide notes: \"Building a toolchain from scratch is like waiting for a Vogon to finish reading poetry - it takes an improbably long time, but the end result is (hopefully) less painful.\"</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-31-start-the-build","title":"Step 3.1: Start the Build","text":"<p>Goal: Compile the complete toolchain</p> <pre><code># Start build (this takes 30-60 minutes)\n./ct-ng build\n\n# Monitor progress in another terminal (optional)\n# tail -f ~/crosstool-ng/.build/build.log\n</code></pre> <p>What happens during build: 1. Download source tarballs (Linux headers, GCC, binutils, musl) 2. Extract archives 3. Configure each component 4. Build binutils 5. Build initial GCC (stage 1) 6. Build musl C library 7. Build full GCC (stage 2) 8. Create sysroot with headers and libraries 9. Install to <code>~/x-tools/</code></p> <p>Build time: 30-60 minutes depending on CPU Disk space used: ~9 GB during build, ~2 GB final</p> <p>Progress indicators: <pre><code>[INFO ]  Installing cross-gdb\n[EXTRA]    Configuring cross-gdb\n[INFO ]  Building cross-gdb\n[INFO ]  Installing cross-gdb\n</code></pre></p> <p>Troubleshooting: - Error: \"No space left on device\"   - Solution: Free up disk space, need ~10 GB free</p> <ul> <li>Error: Build fails with compilation errors</li> <li> <p>Solution: Check build.log: <code>tail -100 ~/.build/build.log</code></p> </li> <li> <p>Build takes too long (&gt;2 hours)</p> </li> <li>Check: CPU usage with <code>htop</code>, build should use all cores</li> <li>Note: First build is slow, subsequent builds are faster</li> </ul>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-32-verify-installation","title":"Step 3.2: Verify Installation","text":"<pre><code># Check toolchain installation\nls -lh ~/x-tools/\n\n# List toolchain directory\nls ~/x-tools/aarch64-beagleplay-linux-musl/\n\n# Check bin directory\nls ~/x-tools/aarch64-beagleplay-linux-musl/bin/\n</code></pre> <p>Expected files in bin/: <pre><code>aarch64-beagleplay-linux-musl-gcc\naarch64-beagleplay-linux-musl-g++\naarch64-beagleplay-linux-musl-ld\naarch64-beagleplay-linux-musl-as\naarch64-beagleplay-linux-musl-objdump\naarch64-linux-gcc (alias)\naarch64-linux-g++ (alias)\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-4-testing-the-toolchain","title":"Part 4: Testing the Toolchain","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#step-41-add-toolchain-to-path","title":"Step 4.1: Add Toolchain to PATH","text":"<pre><code># Add toolchain to current session\nexport PATH=$HOME/x-tools/aarch64-beagleplay-linux-musl/bin:$PATH\n\n# Verify\nwhich aarch64-linux-gcc\n\n# Make permanent (optional)\necho 'export PATH=$HOME/x-tools/aarch64-beagleplay-linux-musl/bin:$PATH' &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-42-create-test-program","title":"Step 4.2: Create Test Program","text":"<pre><code># Create test directory\ncd ~/embedded-linux-labs/lab01-toolchain\nmkdir test\ncd test\n\n# Create hello.c\ncat &gt; hello.c &lt;&lt; 'EOF'\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char **argv) {\n    printf(\"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\n\");\n    printf(\"\u2551   Hello from BeaglePlay!                \u2551\\n\");\n    printf(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\");\n    printf(\"\\n\");\n    printf(\"System Information:\\n\");\n    printf(\"  Architecture: ARM64/AARCH64\\n\");\n    printf(\"  Processor:    Cortex-A53 (64-bit)\\n\");\n    printf(\"  Platform:     TI AM62x (BeaglePlay)\\n\");\n    printf(\"  C Library:    musl libc\\n\");\n    printf(\"\\n\");\n    printf(\"Compiled with:\\n\");\n    printf(\"  GCC version:  %s\\n\", __VERSION__);\n    printf(\"  Compilation:  %s %s\\n\", __DATE__, __TIME__);\n    printf(\"\\n\");\n\n    if (argc &gt; 1) {\n        printf(\"Arguments passed: %d\\n\", argc - 1);\n        for (int i = 1; i &lt; argc; i++) {\n            printf(\"  arg[%d]: %s\\n\", i, argv[i]);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\nEOF\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-43-compile-with-cross-compiler","title":"Step 4.3: Compile with Cross-Compiler","text":"<pre><code># Cross-compile for ARM64\naarch64-linux-gcc -o hello-arm64 hello.c\n\n# Check binary type\nfile hello-arm64\n</code></pre> <p>Expected Output: <pre><code>hello-arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV),\ndynamically linked, interpreter /lib/ld-musl-aarch64.so.1, not stripped\n</code></pre></p> <p>Key observations: - <code>ARM aarch64</code>: Compiled for 64-bit ARM - <code>dynamically linked</code>: Uses shared libraries - <code>ld-musl-aarch64.so.1</code>: musl C library dynamic linker</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-44-compare-with-native-compilation","title":"Step 4.4: Compare with Native Compilation","text":"<pre><code># Compile for x86_64 (your PC)\ngcc -o hello-x86 hello.c\n\n# Compare file sizes\nls -lh hello-*\n\n# Compare binary types\nfile hello-x86\nfile hello-arm64\n</code></pre> <p>Expected: Different ELF types for x86_64 vs ARM64</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-45-inspect-binary","title":"Step 4.5: Inspect Binary","text":"<pre><code># View binary header\nreadelf -h hello-arm64\n\n# List shared library dependencies\naarch64-linux-readelf -d hello-arm64 | grep NEEDED\n\n# Or use ldd-equivalent\naarch64-linux-ldd hello-arm64\n</code></pre> <p>Expected dependencies: <pre><code>libc.so\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-5-qemu-user-mode-testing","title":"Part 5: QEMU User-Mode Testing","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#step-51-install-qemu-user","title":"Step 5.1: Install QEMU User","text":"<pre><code># Install QEMU user-mode emulator\nsudo apt install qemu-user\n\n# Verify installation\nqemu-aarch64 --version\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-52-first-run-attempt","title":"Step 5.2: First Run Attempt","text":"<pre><code># Try to run ARM64 binary on x86_64 host\nqemu-aarch64 hello-arm64\n</code></pre> <p>Expected Error: <pre><code>qemu-aarch64: Could not open '/lib/ld-musl-aarch64.so.1': No such file or directory\n</code></pre></p> <p>Why it fails: QEMU can emulate ARM64 CPU, but the binary needs ARM64 shared libraries (dynamic linker).</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-53-find-library-path","title":"Step 5.3: Find Library Path","text":"<pre><code># Find musl dynamic linker in toolchain\nfind ~/x-tools -name \"ld-musl-aarch64.so.1\"\n</code></pre> <p>Expected: <pre><code>/home/youruser/x-tools/aarch64-beagleplay-linux-musl/aarch64-beagleplay-linux-musl/sysroot/lib/ld-musl-aarch64.so.1\n</code></pre></p> <p>What is sysroot? The \"root filesystem\" for cross-compilation containing ARM64 headers and libraries.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-54-run-with-library-path","title":"Step 5.4: Run with Library Path","text":"<pre><code># Set SYSROOT variable for convenience\nexport SYSROOT=~/x-tools/aarch64-beagleplay-linux-musl/aarch64-beagleplay-linux-musl/sysroot\n\n# Run with -L flag to specify library path\nqemu-aarch64 -L $SYSROOT hello-arm64\n</code></pre> <p>Expected Output: <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551   Hello from BeaglePlay!                \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nSystem Information:\n  Architecture: ARM64/AARCH64\n  Processor:    Cortex-A53 (64-bit)\n  Platform:     TI AM62x (BeaglePlay)\n  C Library:    musl libc\n\nCompiled with:\n  GCC version:  13.3.0\n  Compilation:  Nov 25 2025 14:30:00\n</code></pre></p> <p>\ud83c\udf89 Success! You're running ARM64 code on an x86_64 PC using QEMU!</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-55-test-with-arguments","title":"Step 5.5: Test with Arguments","text":"<pre><code># Run with command-line arguments\nqemu-aarch64 -L $SYSROOT hello-arm64 arg1 arg2 \"test argument\"\n</code></pre> <p>Expected: <pre><code>Arguments passed: 3\n  arg[1]: arg1\n  arg[2]: arg2\n  arg[3]: test argument\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-6-static-vs-dynamic-linking","title":"Part 6: Static vs Dynamic Linking","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#step-61-create-static-binary","title":"Step 6.1: Create Static Binary","text":"<pre><code># Compile with static linking\naarch64-linux-gcc -static -o hello-arm64-static hello.c\n\n# Compare sizes\nls -lh hello-arm64*\n</code></pre> <p>Expected: - <code>hello-arm64</code>: ~16 KB (dynamic) - <code>hello-arm64-static</code>: ~800 KB (static)</p> <p>Why the difference? Static binary includes entire C library, dynamic binary only references it.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-62-test-static-binary","title":"Step 6.2: Test Static Binary","text":"<pre><code># Run without -L flag (no external libraries needed)\nqemu-aarch64 hello-arm64-static\n</code></pre> <p>Expected: Works without SYSROOT because all code is embedded.</p> <p>Trade-offs:</p> Linking Size Advantages Disadvantages Dynamic Small Shared libs, updates easy Needs libraries at runtime Static Large Self-contained Large, no shared updates <p>When to use each: - Dynamic: Normal applications, space-constrained systems - Static: Initial bootup programs, rescue systems, containers</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#part-7-toolchain-exploration","title":"Part 7: Toolchain Exploration","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#step-71-explore-compiler-options","title":"Step 7.1: Explore Compiler Options","text":"<pre><code># View compiler version and configuration\naarch64-linux-gcc -v\n\n# List supported CPU types\naarch64-linux-gcc --target-help | grep march\n\n# Check optimization levels\naarch64-linux-gcc --help=optimizers\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-72-compile-with-optimizations","title":"Step 7.2: Compile with Optimizations","text":"<pre><code># No optimization\naarch64-linux-gcc -O0 -o hello-O0 hello.c\n\n# Optimize for size\naarch64-linux-gcc -Os -o hello-Os hello.c\n\n# Optimize for speed\naarch64-linux-gcc -O3 -o hello-O3 hello.c\n\n# Compare sizes\nls -lh hello-O*\n</code></pre> <p>Expected: Os (size) &lt; O0 (none) &lt; O3 (speed)</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-73-inspect-generated-assembly","title":"Step 7.3: Inspect Generated Assembly","text":"<pre><code># Generate assembly output\naarch64-linux-gcc -S -O2 hello.c -o hello.s\n\n# View assembly\nhead -50 hello.s\n</code></pre> <p>Learning: See how C code translates to ARM64 instructions.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#step-74-examine-object-files","title":"Step 7.4: Examine Object Files","text":"<pre><code># Compile to object file (not linked)\naarch64-linux-gcc -c hello.c -o hello.o\n\n# Display symbols\naarch64-linux-nm hello.o\n\n# Disassemble\naarch64-linux-objdump -d hello.o | head -50\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#verification","title":"Verification","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#test-your-work","title":"Test Your Work","text":"<pre><code># Verification script\ncat &gt; verify-toolchain.sh &lt;&lt; 'EOF'\n#!/bin/bash\nset -e\n\necho \"=== Toolchain Verification ===\"\necho \"\"\n\n# Check toolchain exists\nif [ -d ~/x-tools/aarch64-beagleplay-linux-musl ]; then\n    echo \"\u2713 Toolchain installed\"\nelse\n    echo \"\u2717 Toolchain not found\"\n    exit 1\nfi\n\n# Check compiler\nif command -v aarch64-linux-gcc &amp;&gt; /dev/null; then\n    echo \"\u2713 Compiler in PATH\"\n    echo \"  Version: $(aarch64-linux-gcc --version | head -1)\"\nelse\n    echo \"\u2717 Compiler not in PATH\"\n    exit 1\nfi\n\n# Test compilation\ncd /tmp\necho 'int main() { return 0; }' &gt; test.c\nif aarch64-linux-gcc -o test test.c 2&gt;/dev/null; then\n    echo \"\u2713 Can compile test program\"\n    rm -f test test.c\nelse\n    echo \"\u2717 Compilation failed\"\n    exit 1\nfi\n\n# Check QEMU\nif command -v qemu-aarch64 &amp;&gt; /dev/null; then\n    echo \"\u2713 QEMU installed\"\nelse\n    echo \"\u2717 QEMU not found\"\n    exit 1\nfi\n\necho \"\"\necho \"=== All checks passed! ===\"\nEOF\n\nchmod +x verify-toolchain.sh\n./verify-toolchain.sh\n</code></pre>"},{"location":"labs/embedded-linux/lab01-toolchain/#checklist","title":"Checklist","text":"<ul> <li>[ ] Crosstool-NG built successfully</li> <li>[ ] Toolchain configured for Cortex-A53</li> <li>[ ] Toolchain build completed without errors</li> <li>[ ] <code>aarch64-linux-gcc</code> accessible in PATH</li> <li>[ ] Test program compiles for ARM64</li> <li>[ ] <code>file</code> command shows correct architecture</li> <li>[ ] QEMU can run the cross-compiled binary</li> <li>[ ] Both dynamic and static linking work</li> </ul>"},{"location":"labs/embedded-linux/lab01-toolchain/#cleanup-optional","title":"Cleanup (Optional)","text":"<pre><code># Remove build artifacts to save space (~9 GB)\ncd ~/embedded-linux-labs/lab01-toolchain/crosstool-ng\n./ct-ng clean\n\n# This removes:\n# - Downloaded source tarballs\n# - Temporary build files\n# - Keeps: Final toolchain in ~/x-tools/\n</code></pre> <p>Warning: Only clean if build was successful. If you need to rebuild, you'll download everything again.</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#going-further-optional-challenges","title":"Going Further (Optional Challenges)","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#challenge-1-multi-library-comparison","title":"Challenge 1: Multi-Library Comparison","text":"<p>Build three toolchains with different C libraries: 1. musl (lightweight) 2. glibc (full-featured) 3. uclibc-ng (minimal)</p> <p>Compare: - Build time - Final size - Binary size - Feature differences</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#challenge-2-cortex-a72-toolchain","title":"Challenge 2: Cortex-A72 Toolchain","text":"<p>Build a second toolchain optimized for Raspberry Pi 4 (Cortex-A72): - Change <code>ARCH_CPU</code> to <code>cortex-a72</code> - Compare performance of binaries on same hardware</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#challenge-3-custom-gcc-patches","title":"Challenge 3: Custom GCC Patches","text":"<p>Research and apply GCC patches: - Download GCC sources - Apply optimization patches - Build and benchmark</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#challenge-4-toolchain-wrapper-script","title":"Challenge 4: Toolchain Wrapper Script","text":"<p>Create a wrapper script that: - Automatically sets SYSROOT - Adds default compiler flags - Logs compilation commands - Simplifies cross-compilation workflow</p>"},{"location":"labs/embedded-linux/lab01-toolchain/#common-issues","title":"Common Issues","text":""},{"location":"labs/embedded-linux/lab01-toolchain/#issue-1-build-fails-with-no-space-left-on-device","title":"Issue 1: Build Fails with \"No space left on device\"","text":"<p>Symptoms: - Build stops mid-way - Error message about disk space</p> <p>Solution: <pre><code># Check available space\ndf -h ~\n\n# Clean up if needed\nsudo apt clean\nrm -rf ~/.cache/*\n\n# Need minimum 10 GB free\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#issue-2-configure-error-c-compiler-cannot-create-executables","title":"Issue 2: \"configure: error: C compiler cannot create executables\"","text":"<p>Symptoms: - Build fails early during binutils configuration</p> <p>Causes: - Missing build-essential package - Corrupted GCC installation</p> <p>Solutions: <pre><code># Reinstall build tools\nsudo apt install --reinstall build-essential\n\n# Verify native compiler works\ngcc --version\necho 'int main() { return 0; }' | gcc -x c - -o /tmp/test\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#issue-3-qemu-illegal-instruction-error","title":"Issue 3: QEMU \"Illegal instruction\" Error","text":"<p>Symptoms: - Binary crashes when run with QEMU</p> <p>Causes: - Binary built for wrong architecture - QEMU version too old</p> <p>Solutions: <pre><code># Verify binary architecture\nfile hello-arm64\n# Should show: ARM aarch64\n\n# Update QEMU\nsudo apt install --upgrade qemu-user\n\n# Check QEMU version\nqemu-aarch64 --version\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#issue-4-toolchain-build-takes-hours","title":"Issue 4: Toolchain Build Takes Hours","text":"<p>Symptoms: - Build running for &gt;2 hours</p> <p>Causes: - Low-end CPU - Single-core building - Slow disk I/O</p> <p>Solutions: <pre><code># Check if using multiple cores\nhtop\n# Should see high CPU usage across all cores\n\n# Force parallel build\n./ct-ng build CT_JOBS=$(nproc)\n\n# Use tmpfs for faster builds (if enough RAM)\n./ct-ng build CT_PREFIX=/tmp/toolchain\n</code></pre></p>"},{"location":"labs/embedded-linux/lab01-toolchain/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Cross-compilation is essential for embedded development - target hardware is too slow/limited for compilation</li> <li>Toolchain components work together: compiler, linker, libraries, headers</li> <li>C library choice matters: musl (small), glibc (compatible), uclibc (minimal)</li> <li>CPU optimization improves performance: <code>-mcpu=cortex-a53</code> uses specific instructions</li> <li>QEMU user-mode allows testing ARM binaries without hardware</li> <li>Sysroot is the cross-compilation \"root filesystem\" with ARM libraries</li> <li>Static linking creates larger but self-contained binaries</li> <li>Toolchain naming follows pattern: <code>arch-vendor-os-abi</code> (e.g., <code>aarch64-beagleplay-linux-musl</code>)</li> </ol>"},{"location":"labs/embedded-linux/lab01-toolchain/#references","title":"References","text":"<ul> <li>Crosstool-NG Documentation: https://crosstool-ng.github.io/docs/</li> <li>GCC Cross-Compilation: https://gcc.gnu.org/onlinedocs/gcc/Cross-Compilation.html</li> <li>musl libc: https://musl.libc.org/</li> <li>ARM Cortex-A53 TRM: https://developer.arm.com/documentation/ddi0500/latest/</li> <li>QEMU User Mode: https://qemu.readthedocs.io/en/latest/user/index.html</li> </ul>"},{"location":"labs/embedded-linux/lab01-toolchain/#next-steps","title":"Next Steps","text":"<p>\u2705 Completed: Lab 1 - Cross-Compilation Toolchain \u23ed\ufe0f Up Next: Lab 2 - BeaglePlay Hardware Discovery</p> <p>What you'll learn next: - BeaglePlay hardware architecture - Serial console communication - Device Tree basics - GPIO and peripheral access</p> <p>Recommended preparation: - Read BeaglePlay Technical Reference Manual - Review Device Tree specification - Set up serial console connection</p> <p>Lab created: November 25, 2025 Last updated: November 25, 2025 Tested on: Ubuntu 24.04 LTS, Crosstool-NG 1.26.0 Target: BeaglePlay (TI AM62x Cortex-A53)</p>"},{"location":"labs/embedded-linux/lab02-hardware/","title":"Lab 2: BeaglePlay Hardware Discovery","text":"<p>Platform: BeaglePlay (TI AM62x Cortex-A53) Prerequisites: Lab 1 completed (cross-compilation toolchain ready) Duration: 2-3 hours (or approximately 42 minutes in improbable circumstances) Difficulty: \u2b50\u2b50\u2606\u2606\u2606 (2/5)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about hardware discovery:</p> <p>\"Hardware discovery is the art of asking your embedded board what it is and what it can do, in the hope that it will answer in a language you understand. This is somewhat more successful than asking a Vogon for directions, though both may require substantial interpretation.\"</p>"},{"location":"labs/embedded-linux/lab02-hardware/#objectives","title":"Objectives","text":"<p>By the end of this lab, you will be able to:</p> <ul> <li>[ ] Understand BeaglePlay and TI AM62x hardware architecture</li> <li>[ ] Set up serial console communication (UART)</li> <li>[ ] Access U-Boot bootloader console</li> <li>[ ] Identify BeaglePlay expansion interfaces and connectors</li> <li>[ ] Control GPIO pins and LEDs from Linux</li> <li>[ ] Understand basic Device Tree concepts</li> </ul>"},{"location":"labs/embedded-linux/lab02-hardware/#background","title":"Background","text":""},{"location":"labs/embedded-linux/lab02-hardware/#beagleplay-hardware-overview","title":"BeaglePlay Hardware Overview","text":"<p>Board: BeaglePlay Rev A1 SoC: Texas Instruments AM6254 (part of AM62x family)</p> <p>Key Specifications: - Application Processor: 4x ARM Cortex-A53 @ 1.4 GHz (64-bit) - Real-Time MCU: 1x ARM Cortex-M4F @ 400 MHz - Memory: 2 GB DDR4 RAM - Storage: 16 GB eMMC + microSD slot - Wireless: WiFi 5 (2.4/5 GHz), Bluetooth 5.2 LE, SubGHz (CC1352) - Networking: Gigabit Ethernet (10/100/1000) - USB: 1x Type-C (console + power), 1x Type-A host - Video: HDMI (via mikroBUS or other expansion)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#ti-am62x-soc-architecture","title":"TI AM62x SoC Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   TI AM62x SoC                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502  Cortex-A53     \u2502      \u2502  Cortex-M4F      \u2502      \u2502\n\u2502  \u2502  Quad-core      \u2502\u25c4\u2500\u2500\u2500\u2500\u25ba\u2502  Real-Time MCU   \u2502      \u2502\n\u2502  \u2502  @ 1.4 GHz      \u2502      \u2502  @ 400 MHz       \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502         \u25b2                                            \u2502\n\u2502         \u2502                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502        Memory Subsystem                     \u2502    \u2502\n\u2502  \u2502  - DDR4 Controller (2 GB)                   \u2502    \u2502\n\u2502  \u2502  - SRAM (256 KB)                            \u2502    \u2502\n\u2502  \u2502  - L2 Cache                                 \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502         Peripherals                          \u2502   \u2502\n\u2502  \u2502  - UART (6x)       - I2C (4x)               \u2502   \u2502\n\u2502  \u2502  - SPI (3x)        - GPIO (multiple banks)   \u2502   \u2502\n\u2502  \u2502  - USB 2.0 (2x)    - MMC/SD (3x)            \u2502   \u2502\n\u2502  \u2502  - Ethernet MAC    - PCIe                    \u2502   \u2502\n\u2502  \u2502  - ADC             - PWM/Timer               \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#boot-sequence","title":"Boot Sequence","text":"<p>BeaglePlay uses a multi-stage boot process:</p> <ol> <li>ROM Code (on-chip): TI Secure Boot ROM</li> <li>R5 SPL (tiboot3.bin): 32-bit, runs on Cortex-R5 (inside DM3 subsystem)</li> <li>TF-A (bl31.bin): ARM Trusted Firmware-A (secure world)</li> <li>A53 SPL (tispl.bin): 64-bit, runs on Cortex-A53</li> <li>U-Boot (u-boot.img): Full bootloader on A53</li> <li>Linux Kernel: Your custom kernel</li> </ol>"},{"location":"labs/embedded-linux/lab02-hardware/#prerequisites-check","title":"Prerequisites Check","text":"<pre><code># Verify Lab 1 completion\nwhich aarch64-linux-gcc\n# Should show: /home/user/x-tools/aarch64-beagleplay-linux-musl/bin/aarch64-linux-gcc\n\n# Check workspace\nls ~/embedded-linux-labs/\n# Should show: lab01-toolchain/\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#setup","title":"Setup","text":""},{"location":"labs/embedded-linux/lab02-hardware/#workspace-preparation","title":"Workspace Preparation","text":"<pre><code># Create lab directory\nmkdir -p ~/embedded-linux-labs/lab02-hardware\ncd ~/embedded-linux-labs/lab02-hardware\n\n# Set environment\nexport LAB_DIR=$PWD\nexport PATH=$HOME/x-tools/aarch64-beagleplay-linux-musl/bin:$PATH\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#required-packages","title":"Required Packages","text":"<pre><code># Install serial communication tools\nsudo apt install -y \\\n    picocom \\\n    minicom \\\n    screen \\\n    cu\n\n# Install USB tools (to identify serial devices)\nsudo apt install -y \\\n    usbutils \\\n    lsusb\n\n# Add user to dialout group for serial access\nsudo usermod -a -G dialout $USER\n\n# Log out and back in for group change to take effect\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#part-1-serial-console-setup","title":"Part 1: Serial Console Setup","text":""},{"location":"labs/embedded-linux/lab02-hardware/#step-11-connect-beagleplay","title":"Step 1.1: Connect BeaglePlay","text":"<p>Hardware Connection:</p> <ol> <li>DO NOT power on BeaglePlay yet</li> <li>Connect USB-C cable from BeaglePlay to your PC</li> <li>Use the main USB-C port (not the one labeled \"Debug\")</li> <li>This provides both power and serial console</li> <li>BeaglePlay will auto-power on when USB-C is connected</li> </ol> <p>LED Indicators: - Power LED (red/green): Should light up - User LEDs (blue): May blink during boot</p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-12-identify-serial-device","title":"Step 1.2: Identify Serial Device","text":"<pre><code># Check kernel messages for new USB device\nsudo dmesg | tail -30\n\n# Look for lines like:\n# [12345.678] usb 1-2: new high-speed USB device\n# [12345.890] cdc_acm 1-2:1.0: ttyACM0: USB ACM device\n</code></pre> <p>Common device names: - <code>/dev/ttyACM0</code> - Most common for BeaglePlay USB-C console - <code>/dev/ttyUSB0</code> - If using separate USB-to-UART adapter - <code>/dev/ttyS0</code> - Built-in serial port (rare on modern PCs)</p> <p>Verify device: <pre><code># List ACM devices\nls -l /dev/ttyACM*\n\n# Check device info\nudevadm info /dev/ttyACM0 | grep ID_MODEL\n# Should show something related to BeaglePlay or CP2105\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-13-serial-console-parameters","title":"Step 1.3: Serial Console Parameters","text":"<p>BeaglePlay serial console settings: - Baud rate: 115200 - Data bits: 8 - Parity: None - Stop bits: 1 - Flow control: None</p> <p>Shorthand: <code>115200 8N1</code></p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-14-connect-with-picocom","title":"Step 1.4: Connect with picocom","text":"<pre><code># Connect to serial console\npicocom -b 115200 /dev/ttyACM0\n\n# Expected output:\n# picocom v3.1\n# port is        : /dev/ttyACM0\n# baudrate is    : 115200\n# ...\n# Terminal ready\n</code></pre> <p>picocom Controls: - Ctrl+A, Ctrl+X: Exit picocom - Ctrl+A, Ctrl+H: Show help - Ctrl+A, Ctrl+P: Toggle local echo</p> <p>Troubleshooting: <pre><code># Permission denied?\nsudo chmod 666 /dev/ttyACM0\n# Or better: add user to dialout group (already done above, requires re-login)\n\n# Device busy?\nsudo lsof | grep ttyACM0\n# Kill other process using the device\n\n# No such device?\n# Check different device: /dev/ttyUSB0, /dev/ttyACM1, etc.\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-15-first-boot-messages","title":"Step 1.5: First Boot Messages","text":"<p>With picocom connected, you should see boot messages:</p> <pre><code>U-Boot SPL 2024.01 (Nov 25 2025)\nSYSFW ABI: 3.1 (firmware rev 0x0009)\nTrying to boot from MMC1\n\n...\n\nU-Boot 2024.01 (Nov 25 2025)\nSoC:   AM62X SR1.0\nModel: BeagleBoard.org BeaglePlay\nDRAM:  2 GiB\nCore:  61 devices, 28 uclasses\n\n...\n\nHit any key to stop autoboot:  3\n=&gt;\n</code></pre> <p>If you don't see anything: 1. Power cycle BeaglePlay (unplug/replug USB-C) 2. Try different baud rates: 9600, 38400, 57600 3. Check cable (must support data, not just charging)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#part-2-u-boot-exploration","title":"Part 2: U-Boot Exploration","text":""},{"location":"labs/embedded-linux/lab02-hardware/#step-21-interrupt-boot-sequence","title":"Step 2.1: Interrupt Boot Sequence","text":"<p>When you see \"Hit any key to stop autoboot\", press Spacebar quickly.</p> <p>You'll get U-Boot prompt: <pre><code>=&gt;\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-22-basic-u-boot-commands","title":"Step 2.2: Basic U-Boot Commands","text":"<pre><code># Display U-Boot version and build info\n=&gt; version\n\n# List all available commands\n=&gt; help\n\n# Get help on specific command\n=&gt; help printenv\n\n# Display all environment variables\n=&gt; printenv\n\n# Show board information\n=&gt; bdinfo\n\n# List memory regions\n=&gt; md 0x80000000 10\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#step-23-storage-device-information","title":"Step 2.3: Storage Device Information","text":"<pre><code># List MMC (SD/eMMC) devices\n=&gt; mmc list\n# Output:\n# mmc@fa10000: 0 (eMMC)\n# mmc@fa00000: 1 (SD)\n# mmc@fa20000: 2\n\n# Select SD card\n=&gt; mmc dev 1\n\n# Show SD card info\n=&gt; mmc info\n# Shows: Device, Type, Capacity, etc.\n\n# List partitions on SD card\n=&gt; mmc part\n\n# Read filesystem (if FAT)\n=&gt; fatls mmc 1:1\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#step-24-network-information","title":"Step 2.4: Network Information","text":"<pre><code># Show network configuration\n=&gt; printenv ipaddr\n=&gt; printenv serverip\n=&gt; printenv ethaddr\n\n# Note: Network may not be configured yet (will configure in later lab)\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#part-3-hardware-interfaces","title":"Part 3: Hardware Interfaces","text":""},{"location":"labs/embedded-linux/lab02-hardware/#step-31-expansion-connectors","title":"Step 3.1: Expansion Connectors","text":"<p>BeaglePlay provides multiple expansion options:</p>"},{"location":"labs/embedded-linux/lab02-hardware/#mikrobus-socket","title":"mikroBUS Socket","text":"<p>16-pin socket for MikroElektronika Click boards:</p> Pin Function Pin Function 1 AN (Analog) 9 TX (UART) 2 RST (Reset) 10 RX (UART) 3 CS (SPI) 11 SCL (I2C) 4 SCK (SPI) 12 SDA (I2C) 5 MISO (SPI) 13 +5V 6 MOSI (SPI) 14 GND 7 +3.3V 15 GND 8 GND 16 INT (Interrupt) <p>Compatible modules: 1000+ Click boards (sensors, displays, wireless, etc.)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#grove-connector","title":"Grove Connector","text":"<p>4-pin connector for Seeed Studio Grove modules:</p> Pin Function 1 SCL (I2C) 2 SDA (I2C) 3 VCC (5V or 3.3V) 4 GND <p>Use case: Quick prototyping with I2C sensors</p>"},{"location":"labs/embedded-linux/lab02-hardware/#qwiicstemma-qt-connector","title":"QWIIC/STEMMA QT Connector","text":"<p>4-pin JST SH connector compatible with: - SparkFun Qwiic ecosystem - Adafruit STEMMA QT ecosystem</p> <p>Pinout: VCC (3.3V), GND, SDA, SCL (I2C)</p> <p>Advantage: Daisy-chaining multiple I2C devices without soldering</p>"},{"location":"labs/embedded-linux/lab02-hardware/#46-pin-headers-p8-p9","title":"46-Pin Headers (P8 &amp; P9)","text":"<p>Similar to other BeagleBone boards, providing: - GPIO (3.3V logic level - NOT 5V tolerant!) - PWM outputs - Analog inputs (ADC) - SPI, I2C, UART interfaces - Power pins (3.3V, 5V, GND)</p> <p>Pinout: See official documentation</p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-32-on-board-components","title":"Step 3.2: On-Board Components","text":"<p>LEDs: - USR0-USR3: User-controllable LEDs (blue) - Power: Power indicator (red/green) - WiFi/BT: Wireless activity indicators</p> <p>Buttons: - BOOT: Hold during power-up to force eMMC boot - RESET: Hard reset button</p> <p>Wireless: - WiFi: 2.4/5 GHz (WL1807MOD module) - Bluetooth: 5.2 LE - SubGHz: CC1352P7 (868/915 MHz for LoRa, Thread, etc.)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#part-4-gpio-and-led-control","title":"Part 4: GPIO and LED Control","text":""},{"location":"labs/embedded-linux/lab02-hardware/#step-41-understanding-gpio","title":"Step 4.1: Understanding GPIO","text":"<p>GPIO (General Purpose Input/Output) pins can be: - Output: Drive HIGH (3.3V) or LOW (0V) - Input: Read HIGH or LOW state - Interrupt: Trigger on state change</p> <p>BeaglePlay USR LEDs: - Connected to specific GPIO pins - Controlled via Linux <code>sysfs</code> interface - Can be triggered by events (heartbeat, mmc activity, etc.)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-42-led-control-from-u-boot","title":"Step 4.2: LED Control from U-Boot","text":"<p>U-Boot may not have full GPIO support configured by default, so we'll control LEDs from Linux (next labs). For now, just understand the concept.</p> <p>GPIO Calculation: - AM62x GPIO is organized in banks - Each bank has 32 GPIOs (GPIO0-GPIO31) - Formula: <code>GPIO number = (bank \u00d7 32) + pin</code></p> <p>Example: - GPIO1_25 = (1 \u00d7 32) + 25 = GPIO 57</p>"},{"location":"labs/embedded-linux/lab02-hardware/#part-5-boot-sources","title":"Part 5: Boot Sources","text":""},{"location":"labs/embedded-linux/lab02-hardware/#step-51-understanding-boot-order","title":"Step 5.1: Understanding Boot Order","text":"<p>BeaglePlay boot sequence (ROM code):</p> <ol> <li>Check USR button:</li> <li>Pressed: Skip to step 3 (eMMC only)</li> <li> <p>Not pressed: Continue</p> </li> <li> <p>Try microSD card (mmc1):</p> </li> <li>Look for bootable FAT partition</li> <li>Load <code>tiboot3.bin</code></li> <li>If found: Boot from SD</li> <li> <p>If not found: Continue</p> </li> <li> <p>Try eMMC (mmc0):</p> </li> <li>Look for bootable partition</li> <li>Load <code>tiboot3.bin</code></li> <li>If found: Boot from eMMC</li> <li> <p>If not found: Try USB/UART</p> </li> <li> <p>USB Boot (DFU mode):</p> </li> <li>Wait for USB connection</li> <li>Allow flashing via USB</li> </ol>"},{"location":"labs/embedded-linux/lab02-hardware/#step-52-forcing-boot-source","title":"Step 5.2: Forcing Boot Source","text":"<p>Boot from SD Card (default if SD inserted): - Just insert SD card and power on</p> <p>Boot from eMMC (even if SD is inserted): 1. Hold USR button 2. Power on or press RESET 3. Release USR button after 2 seconds</p> <p>Boot to USB DFU Mode (for recovery): - Remove SD card - Erase eMMC boot partition - Power on \u2192 will enter DFU mode</p>"},{"location":"labs/embedded-linux/lab02-hardware/#part-6-device-tree-introduction","title":"Part 6: Device Tree Introduction","text":""},{"location":"labs/embedded-linux/lab02-hardware/#step-61-what-is-device-tree","title":"Step 6.1: What is Device Tree?","text":"<p>Device Tree is a data structure that describes hardware to the kernel: - NOT executable code - IS a hardware description - Tells kernel: \"What devices exist and where are they?\"</p> <p>Why needed? - ARM SoCs have diverse hardware configurations - Kernel can't auto-detect everything (unlike x86 PCI) - One kernel binary + different Device Trees = support multiple boards</p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-62-device-tree-files","title":"Step 6.2: Device Tree Files","text":"<p>Source: <code>.dts</code> files (human-readable) <pre><code>/ {\n    model = \"BeagleBoard.org BeaglePlay\";\n    compatible = \"beagle,am625-beagleplay\", \"ti,am625\";\n\n    leds {\n        compatible = \"gpio-leds\";\n        led-0 {\n            label = \"beagleplay:green:usr0\";\n            gpios = &lt;&amp;main_gpio0 3 GPIO_ACTIVE_HIGH&gt;;\n            linux,default-trigger = \"heartbeat\";\n        };\n    };\n};\n</code></pre></p> <p>Compiled: <code>.dtb</code> files (binary blob) - Compiled with <code>dtc</code> (Device Tree Compiler) - Loaded by bootloader alongside kernel - Format: Flattened Device Tree (FDT)</p>"},{"location":"labs/embedded-linux/lab02-hardware/#step-63-beagleplay-device-tree","title":"Step 6.3: BeaglePlay Device Tree","text":"<p>Main DTS: <code>k3-am625-beagleplay.dts</code></p> <p>Describes: - AM62x SoC peripherals - BeaglePlay-specific hardware - GPIO assignments - I2C/SPI devices - WiFi/Bluetooth modules - Ethernet PHY - mikroBUS resources</p> <p>Location in kernel source: <pre><code>arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#verification","title":"Verification","text":""},{"location":"labs/embedded-linux/lab02-hardware/#test-your-work","title":"Test Your Work","text":"<pre><code># Create verification log\ncat &gt; verify-hardware.txt &lt;&lt; 'EOF'\nBeaglePlay Hardware Discovery - Verification Log\n=================================================\n\n1. Serial Console\n   [PASS/FAIL] Device found: /dev/ttyACM0\n   [PASS/FAIL] picocom connects successfully\n   [PASS/FAIL] Boot messages visible\n\n2. U-Boot Access\n   [PASS/FAIL] Can interrupt boot sequence\n   [PASS/FAIL] U-Boot prompt (=&gt;) appears\n   [PASS/FAIL] Commands execute (help, version)\n\n3. Storage Devices\n   [PASS/FAIL] eMMC detected (mmc list)\n   [PASS/FAIL] SD card detected (if inserted)\n\n4. Hardware Understanding\n   [PASS/FAIL] Understand mikroBUS pinout\n   [PASS/FAIL] Understand boot sequence\n   [PASS/FAIL] Understand Device Tree concept\n\nNotes:\nEOF\n\n# Fill in PASS/FAIL and notes\nnano verify-hardware.txt\n</code></pre>"},{"location":"labs/embedded-linux/lab02-hardware/#checklist","title":"Checklist","text":"<ul> <li>[ ] Serial console configured and working</li> <li>[ ] Can access U-Boot prompt</li> <li>[ ] Understand BeaglePlay hardware architecture</li> <li>[ ] Know the expansion connector options</li> <li>[ ] Understand boot source priority</li> <li>[ ] Basic Device Tree knowledge acquired</li> </ul>"},{"location":"labs/embedded-linux/lab02-hardware/#going-further-optional","title":"Going Further (Optional)","text":""},{"location":"labs/embedded-linux/lab02-hardware/#challenge-1-u-boot-scripting","title":"Challenge 1: U-Boot Scripting","text":"<p>Create a U-Boot script that: 1. Prints custom boot message 2. Tests SD card presence 3. Sets up network variables 4. Saves configuration</p>"},{"location":"labs/embedded-linux/lab02-hardware/#challenge-2-serial-console-alternatives","title":"Challenge 2: Serial Console Alternatives","text":"<p>Try other serial terminal programs: - <code>minicom</code>: More features, more complex - <code>screen</code>: Ubiquitous, multi-window support - <code>cu</code>: Simple, minimal</p> <p>Compare pros/cons of each.</p>"},{"location":"labs/embedded-linux/lab02-hardware/#challenge-3-usb-console-deep-dive","title":"Challenge 3: USB Console Deep Dive","text":"<p>Research: - How USB CDC ACM class works - BeaglePlay USB console chip (CP2105) - Writing Linux kernel driver for USB serial</p>"},{"location":"labs/embedded-linux/lab02-hardware/#common-issues","title":"Common Issues","text":""},{"location":"labs/embedded-linux/lab02-hardware/#issue-1-no-serial-device-appears","title":"Issue 1: No Serial Device Appears","text":"<p>Symptoms: - No /dev/ttyACM0 or /dev/ttyUSB0 - <code>ls /dev/tty*</code> doesn't show new devices</p> <p>Solutions: <pre><code># Check USB connection\nlsusb\n# Look for BeaglePlay or CP210x device\n\n# Check dmesg for errors\ndmesg | grep -i usb\ndmesg | grep -i cdc\n\n# Load driver manually (if needed)\nsudo modprobe cdc_acm\n\n# Try different USB port (avoid USB 3.0 hubs sometimes)\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#issue-2-permission-denied-on-devttyacm0","title":"Issue 2: Permission Denied on /dev/ttyACM0","text":"<p>Symptoms: - <code>picocom: Permission denied</code></p> <p>Solutions: <pre><code># Temporary fix (until reboot)\nsudo chmod 666 /dev/ttyACM0\n\n# Permanent fix (requires logout/login)\nsudo usermod -a -G dialout $USER\n# Then logout and back in\n\n# Verify group membership\ngroups | grep dialout\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#issue-3-garbled-characters-on-console","title":"Issue 3: Garbled Characters on Console","text":"<p>Symptoms: - Random characters instead of readable text - Symbols and garbage</p> <p>Causes: - Wrong baud rate - Flow control enabled</p> <p>Solutions: <pre><code># Try different baud rates\npicocom -b 9600 /dev/ttyACM0\npicocom -b 38400 /dev/ttyACM0\npicocom -b 57600 /dev/ttyACM0\npicocom -b 115200 /dev/ttyACM0  # Correct for BeaglePlay\n\n# Disable flow control explicitly\npicocom -b 115200 -f n /dev/ttyACM0\n</code></pre></p>"},{"location":"labs/embedded-linux/lab02-hardware/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Serial console is essential for embedded development - first interface to the board</li> <li>USB-C provides both power and console - convenient for BeaglePlay</li> <li>U-Boot is the bootloader - provides early hardware initialization and kernel loading</li> <li>Boot sequence is multi-stage: ROM \u2192 R5 SPL \u2192 TF-A \u2192 A53 SPL \u2192 U-Boot \u2192 Kernel</li> <li>Device Tree describes hardware to kernel - separation of code and hardware description</li> <li>Expansion connectors (mikroBUS, Grove, Qwiic) make prototyping easier</li> <li>GPIO provides basic digital I/O - foundation for hardware interaction</li> </ol>"},{"location":"labs/embedded-linux/lab02-hardware/#references","title":"References","text":"<ul> <li>BeaglePlay Documentation: https://docs.beagleboard.org/latest/boards/beagleplay/</li> <li>TI AM62x TRM: https://www.ti.com/lit/pdf/spruiv7</li> <li>Device Tree Specification: https://devicetree-specification.readthedocs.io/</li> <li>U-Boot Documentation: https://docs.u-boot.org/</li> <li>mikroBUS Standard: https://www.mikroe.com/mikrobus</li> </ul>"},{"location":"labs/embedded-linux/lab02-hardware/#next-steps","title":"Next Steps","text":"<p>\u2705 Completed: Lab 2 - BeaglePlay Hardware Discovery \u23ed\ufe0f Up Next: Lab 3 - U-Boot Bootloader</p> <p>What you'll learn next: - Compile U-Boot from source - Configure bootloader for network boot - Set up TFTP server - Load kernel over network - Automate boot process</p> <p>Recommended preparation: - Review U-Boot commands learned here - Set up Ethernet connection to BeaglePlay - Read about TFTP protocol</p> <p>Lab created: November 25, 2025 Last updated: November 25, 2025 Tested on: Ubuntu 24.04 LTS, BeaglePlay Rev A1 Hardware: BeaglePlay (TI AM62x Cortex-A53)</p>"},{"location":"labs/embedded-linux/lab03-bootloader/","title":"Lab 3: U-Boot Bootloader for BeaglePlay","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about bootloaders:</p> <p>\"A bootloader is the first piece of software that runs when your board powers on. It's like Arthur Dent's morning routine - essential, often confusing, and if it goes wrong, the entire day (or boot process) is ruined. The difference is that U-Boot is marginally more reliable than Arthur's grasp of temporal mechanics.\"</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will be able to:</p> <ul> <li>Understand the AM62x multi-stage boot architecture</li> <li>Build bootloader components for both 32-bit (R5) and 64-bit (A53) processors</li> <li>Compile U-Boot SPL for the R5 cortex processor</li> <li>Build ARM Trusted Firmware (TF-A) for secure boot</li> <li>Configure and compile U-Boot for the main A53 processors</li> <li>Create properly formatted SD card boot partitions</li> <li>Test and interact with U-Boot bootloader</li> <li>Configure U-Boot environment persistence</li> <li>Add custom commands to U-Boot</li> </ul> <p>Estimated Time: 4-5 hours</p> <p>Prerequisites: - Completed Lab 1 (Custom Toolchain) - Completed Lab 2 (Hardware Discovery) - Basic understanding of boot sequences - Familiarity with cross-compilation</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#introduction","title":"Introduction","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#the-beagleplay-boot-challenge","title":"The BeaglePlay Boot Challenge","text":"<p>Unlike simple microcontrollers with a single processor, the TI AM62x SoC on BeaglePlay presents a complex boot architecture with three different processor types:</p> <ol> <li>Cortex-R5F (32-bit, WKUP domain) - Boot orchestrator</li> <li>Cortex-M4F (32-bit, MCU domain) - Security &amp; power management  </li> <li>Cortex-A53 (64-bit, MAIN domain) - Linux application processors (4 cores)</li> </ol> <p>This complexity means we can't just compile a single bootloader. We need to build multiple components that work together in a carefully choreographed boot sequence.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#why-this-matters","title":"Why This Matters","text":"<p>Understanding the boot process is critical because:</p> <ul> <li>Debugging: When boot fails, you need to know which stage is failing</li> <li>Security: Each boot stage can verify the next (secure boot chains)</li> <li>Performance: Boot time optimization requires understanding each stage</li> <li>Customization: Advanced features require bootloader modifications</li> </ul> <p>Think of it like a relay race - each runner (boot stage) must successfully hand off the baton (control) to the next, or the whole race fails.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#boot-sequence-overview","title":"Boot Sequence Overview","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#ti-am62x-boot-flow","title":"TI AM62x Boot Flow","text":"<p>Here's the complete boot sequence we'll implement:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Power-On    \u2502\n\u2502  Reset       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  ROM Code (R5 CPU)   \u2502 \u2190 Built into SoC, cannot modify\n\u2502  - Minimal init      \u2502\n\u2502  - Read boot source  \u2502\n\u2502  - Load tiboot3.bin  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  tiboot3.bin         \u2502 \u2190 We build this (R5 SPL + TIFS)\n\u2502  - R5 U-Boot SPL     \u2502\n\u2502  - TIFS firmware     \u2502\n\u2502  - DDR init          \u2502\n\u2502  - Start M4F &amp; A53   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  TF-A (BL31)         \u2502 \u2190 We build this (A53 secure world)\n\u2502  - ARM Trusted FW    \u2502\n\u2502  - Secure services   \u2502\n\u2502  - Switch to normal  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  tispl.bin           \u2502 \u2190 We build this (A53 SPL)\n\u2502  - A53 U-Boot SPL    \u2502\n\u2502  - Load full U-Boot  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  u-boot.img          \u2502 \u2190 We build this (Full U-Boot)\n\u2502  - Full bootloader   \u2502\n\u2502  - Shell/commands    \u2502\n\u2502  - Load Linux kernel \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#what-were-building","title":"What We're Building","text":"Component Processor Purpose Output File R5 SPL Cortex-R5F (32-bit) Initialize DDR, start A53 <code>tiboot3.bin</code> TIFS Cortex-M4F (32-bit) Security &amp; power mgmt (embedded in tiboot3.bin) TF-A Cortex-A53 (64-bit) Secure world services <code>bl31.bin</code> \u2192 <code>tispl.bin</code> A53 SPL Cortex-A53 (64-bit) Load full U-Boot <code>tispl.bin</code> U-Boot Cortex-A53 (64-bit) Interactive shell, boot Linux <code>u-boot.img</code> <p>Notice we need two different cross-compilation toolchains: - 32-bit ARM toolchain for R5/M4F components - 64-bit ARM64 toolchain for A53 components (built in Lab 1)</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#workspace-setup","title":"Workspace Setup","text":"<p>Create a dedicated bootloader directory:</p> <pre><code>cd $HOME/embedded-labs\nmkdir -p bootloader\ncd bootloader\n</code></pre> <p>All work in this lab happens in this directory.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-1-32-bit-arm-toolchain-for-r5","title":"Part 1: 32-bit ARM Toolchain for R5","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#why-we-need-this","title":"Why We Need This","text":"<p>The R5 processor is a 32-bit ARMv7-R CPU, different from the 64-bit ARMv8-A Cortex-A53. We need a matching toolchain.</p> <p>Option A: Use Crosstool-NG to build a custom 32-bit toolchain (slow, ~2 hours) Option B: Download pre-built toolchain from ARM (fast, recommended)</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#installing-pre-built-arm-toolchain","title":"Installing Pre-built ARM Toolchain","text":"<p>Download the official ARM GNU toolchain for bare-metal 32-bit ARM:</p> <pre><code>cd $HOME/embedded-labs/bootloader\nwget https://developer.arm.com/-/media/Files/downloads/gnu/12.2.rel1/binrel/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi.tar.xz\n</code></pre> <p>Extract to the same location as our 64-bit toolchain:</p> <pre><code>tar xf arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi.tar.xz -C $HOME/x-tools/\n</code></pre> <p>Add to your PATH (add this to <code>~/.bashrc</code> for persistence):</p> <pre><code>export PATH=$HOME/x-tools/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/bin:$PATH\n</code></pre> <p>Reload your shell or source the updated <code>.bashrc</code>:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Verify the installation:</p> <pre><code>arm-none-eabi-gcc --version\n</code></pre> <p>You should see:</p> <pre><code>arm-none-eabi-gcc (Arm GNU Toolchain 12.2.Rel1 (Build arm-12.24)) 12.2.1 20221205\n</code></pre> <p>Understanding the toolchain tuple: <code>arm-none-eabi</code> - arm - Target architecture (32-bit ARM) - none - No operating system (bare metal) - eabi - Embedded Application Binary Interface</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-2-building-r5-u-boot-spl","title":"Part 2: Building R5 U-Boot SPL","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#get-u-boot-sources","title":"Get U-Boot Sources","text":"<p>BeaglePlay support is not yet in mainline U-Boot, so we use BeagleBoard's fork:</p> <pre><code>cd $HOME/embedded-labs/bootloader\ngit clone https://git.beagleboard.org/beagleplay/u-boot.git\ncd u-boot/\ngit checkout f036fb\n</code></pre> <p>The <code>f036fb</code> commit is tested and known to work with BeaglePlay.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#understand-u-boot-build-system","title":"Understand U-Boot Build System","text":"<p>Take a moment to read the README:</p> <pre><code>less README\n</code></pre> <p>Key sections: - Building the Software - Configuration and compilation process - Configuration - How defconfig files work - Building - Cross-compilation variables</p> <p>U-Boot uses Kconfig (same as Linux kernel) for configuration.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#configure-u-boot-for-r5","title":"Configure U-Boot for R5","text":"<p>We'll use out-of-tree builds to keep source clean and build artifacts separate. This allows building multiple U-Boot configurations from the same source.</p> <p>Create R5 build directory:</p> <pre><code>mkdir -p $HOME/embedded-labs/bootloader/build_uboot/r5\n</code></pre> <p>Set the cross-compiler:</p> <pre><code>export CROSS_COMPILE=arm-none-eabi-\n</code></pre> <p>Important (like knowing where your towel is): The trailing dash is required!</p> <p>Find the R5 configuration:</p> <pre><code>ls configs/ | grep am62x\n</code></pre> <p>You'll see several configs. We want <code>am62x_evm_r5_defconfig</code> for R5 SPL.</p> <p>Load the configuration:</p> <pre><code>make am62x_evm_r5_defconfig O=$HOME/embedded-labs/bootloader/build_uboot/r5/\n</code></pre> <p>The <code>O=</code> parameter tells make to place all build output in that directory.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#install-build-dependencies","title":"Install Build Dependencies","text":"<p>U-Boot needs several development packages:</p> <pre><code>sudo apt install libssl-dev device-tree-compiler swig python3-dev python3-setuptools\n</code></pre> <p>What these provide: - libssl-dev - Cryptographic signing of boot images - device-tree-compiler - Compile Device Tree Blobs (DTBs) - swig - Python bindings for U-Boot tools - python3-dev - mkimage and other build tools</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#compile-r5-u-boot-spl","title":"Compile R5 U-Boot SPL","text":"<p>Now build it:</p> <pre><code>make -j$(nproc) O=$HOME/embedded-labs/bootloader/build_uboot/r5/\n</code></pre> <p>The <code>-j$(nproc)</code> uses all CPU cores for parallel compilation.</p> <p>Build time: ~2-5 minutes on a modern system.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#verify-r5-build-output","title":"Verify R5 Build Output","text":"<p>Check what was built:</p> <pre><code>ls -lh $HOME/embedded-labs/bootloader/build_uboot/r5/spl/\n</code></pre> <p>Key files: - u-boot-spl.bin - The R5 SPL binary (this is what we need!) - u-boot-spl.map - Memory map for debugging - u-boot-spl - ELF file with debug symbols</p> <p>The <code>u-boot-spl.bin</code> is ~220KB. Check its size:</p> <pre><code>ls -lh $HOME/embedded-labs/bootloader/build_uboot/r5/spl/u-boot-spl.bin\n</code></pre> <p>What does R5 SPL do? - Initializes DDR memory (critical - without RAM, nothing else works) - Loads TIFS firmware to the M4F processor - Wakes up the first Cortex-A53 CPU - Hands control to TF-A on the A53</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-3-ti-firmware-tifs","title":"Part 3: TI Firmware (TIFS)","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#get-ti-firmware-package","title":"Get TI Firmware Package","text":"<p>TI provides pre-built firmware for security and device management:</p> <pre><code>cd $HOME/embedded-labs/bootloader\ngit clone https://git.ti.com/git/processor-firmware/ti-linux-firmware.git\ncd ti-linux-firmware\ngit checkout 09.01.00.008\n</code></pre> <p>This package contains: - TIFS - TI Foundational Security firmware (runs on M4F) - DM - Device Management firmware (power/clock control)</p> <p>Explore the firmware files:</p> <pre><code>ls -lh ti-sysfw/\nls -lh ti-dm/am62xx/\n</code></pre> <p>Key files: - <code>ti-sysfw/ti-fs-firmware-am62x-gp.bin</code> - TIFS for GP (General Purpose) devices - <code>ti-dm/am62xx/ipc_echo_testb_mcu1_0_release_strip.xer5f</code> - DM firmware</p> <p>GP vs HS: BeaglePlay uses GP (general purpose) silicon. HS (High Security) devices have secure boot enabled and require signed images.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#create-combined-tiboot3bin-image","title":"Create Combined tiboot3.bin Image","text":"<p>The ROM code expects a single <code>tiboot3.bin</code> file containing: 1. R5 U-Boot SPL 2. TIFS firmware 3. X.509 certificate wrapper (for authentication)</p> <p>TI provides the <code>k3-image-gen</code> tool to create this combined image:</p> <pre><code>cd $HOME/embedded-labs/bootloader\ngit clone https://git.ti.com/cgit/k3-image-gen/k3-image-gen\ncd k3-image-gen/\ngit checkout 09.00.00.001\n</code></pre> <p>Build the combined image:</p> <pre><code>make SOC=am62x \\\n     SBL=$HOME/embedded-labs/bootloader/build_uboot/r5/spl/u-boot-spl.bin \\\n     SYSFW_PATH=$HOME/embedded-labs/bootloader/ti-linux-firmware/ti-sysfw/ti-fs-firmware-am62x-gp.bin\n</code></pre> <p>Parameters explained: - SOC=am62x - Target SoC (determines certificate format) - SBL=... - Secondary Boot Loader (our R5 SPL) - SYSFW_PATH=... - System firmware (TIFS)</p> <p>Output:</p> <pre><code>ls -lh tiboot3-am62x-gp-evm.bin\n</code></pre> <p>The tool creates a ~280KB file and a symlink <code>tiboot3.bin</code> \u2192 <code>tiboot3-am62x-gp-evm.bin</code>.</p> <p>What's inside tiboot3.bin?</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  X.509 Certificate      \u2502  \u2190 Authentication header\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  TIFS Firmware          \u2502  \u2190 M4F security firmware\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  R5 U-Boot SPL          \u2502  \u2190 DDR init, boot orchestration\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use this command to inspect it (optional):</p> <pre><code>file tiboot3.bin\nhexdump -C tiboot3.bin | head -50\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-4-arm-trusted-firmware-tf-a","title":"Part 4: ARM Trusted Firmware (TF-A)","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#what-is-tf-a","title":"What is TF-A?","text":"<p>ARM Trusted Firmware provides: - Secure Monitor - Mediates access to secure resources - Power Management - CPU hotplug, suspend/resume - Secure Boot - Chain of trust verification</p> <p>It runs in ARM's \"Secure World\" (EL3 exception level) and provides services to the \"Normal World\" (where Linux runs).</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#get-tf-a-sources","title":"Get TF-A Sources","text":"<p>Clone the official ARM repository:</p> <pre><code>cd $HOME/embedded-labs/bootloader\ngit clone https://github.com/ARM-software/arm-trusted-firmware.git\ncd arm-trusted-firmware/\ngit checkout v2.9\n</code></pre> <p>Version 2.9 is tested with BeaglePlay.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#configure-tf-a-for-am62x","title":"Configure TF-A for AM62x","text":"<p>TF-A uses simple Makefile-based configuration. Set up for 64-bit:</p> <pre><code>export CROSS_COMPILE=aarch64-beagleplay-linux-musl-\n</code></pre> <p>This uses our custom toolchain from Lab 1!</p> <p>Build TF-A with these parameters:</p> <pre><code>make ARCH=aarch64 PLAT=k3 TARGET_BOARD=lite -j$(nproc)\n</code></pre> <p>Parameters explained: - ARCH=aarch64 - 64-bit ARM architecture - PLAT=k3 - TI K3 SoC family (AM62x, AM64x, AM65x all use this) - TARGET_BOARD=lite - BeaglePlay variant (fewer features than full EVM)</p> <p>Build time: ~1 minute</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#verify-tf-a-build","title":"Verify TF-A Build","text":"<p>Check the output:</p> <pre><code>ls -lh build/k3/lite/release/\n</code></pre> <p>Key file: - bl31.bin - BL31 (Boot Loader stage 3.1) for A53</p> <pre><code>ls -lh build/k3/lite/release/bl31.bin\n</code></pre> <p>Size: ~50-60KB</p> <p>TF-A Boot Stages: - BL1 - Not used on AM62x (ROM code replaces this) - BL2 - Not used on AM62x (R5 SPL replaces this) - BL31 - Secure Monitor (this is what we built) - BL32 - Optional Secure OS (we're not using OP-TEE) - BL33 - Normal World bootloader (U-Boot)</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-5-building-a53-u-boot","title":"Part 5: Building A53 U-Boot","text":"<p>Now we build the full U-Boot for the 64-bit Cortex-A53 processors.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#create-a53-build-directory","title":"Create A53 Build Directory","text":"<pre><code>cd $HOME/embedded-labs/bootloader\nmkdir -p build_uboot/a53\ncd u-boot/\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#configure-for-a53","title":"Configure for A53","text":"<p>Switch to 64-bit toolchain:</p> <pre><code>export CROSS_COMPILE=aarch64-beagleplay-linux-musl-\n</code></pre> <p>Load A53 defconfig:</p> <pre><code>make am62x_evm_a53_defconfig O=$HOME/embedded-labs/bootloader/build_uboot/a53/\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#customize-u-boot-environment-storage","title":"Customize U-Boot Environment Storage","text":"<p>By default, U-Boot stores its environment in various places. We'll configure it to use an ext4 filesystem on the SD card for persistence.</p> <p>Enter menuconfig:</p> <pre><code>make menuconfig O=$HOME/embedded-labs/bootloader/build_uboot/a53/\n</code></pre> <p>Navigate using arrow keys, Enter to select, Space to toggle, '/' to search.</p> <p>Configuration changes:</p> <ol> <li>Navigate to: <code>Environment</code> \u2192</li> <li>Enable: <code>Environment is in a EXT4 filesystem</code></li> <li>Disable all other environment storage options:</li> <li><code>[ ]</code> Environment is in MMC</li> <li><code>[ ]</code> Environment is in SPI flash</li> <li><code>[ ]</code> Environment is in UBI</li> <li>Configure EXT4 environment:</li> <li><code>Name of the block device for the environment</code> \u2192 <code>mmc</code></li> <li><code>Device and partition for where to store the environment</code> \u2192 <code>1:2</code></li> <li><code>Name of the EXT4 file to use for the environment</code> \u2192 <code>/uboot.env</code></li> <li>Disable: <code>SPL Environment is in a EXT4 filesystem</code> (SPL doesn't need to save env)</li> </ol> <p>Save and exit menuconfig.</p> <p>Why ext4 for environment? - Can edit <code>uboot.env</code> from Linux if needed - Better for frequent writes than FAT32 - Easier to back up</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#build-a53-u-boot","title":"Build A53 U-Boot","text":"<p>This build needs to embed TF-A and Device Management firmware:</p> <pre><code>make -j$(nproc) \\\n     ATF=$HOME/embedded-labs/bootloader/arm-trusted-firmware/build/k3/lite/release/bl31.bin \\\n     DM=$HOME/embedded-labs/bootloader/ti-linux-firmware/ti-dm/am62xx/ipc_echo_testb_mcu1_0_release_strip.xer5f \\\n     O=$HOME/embedded-labs/bootloader/build_uboot/a53/\n</code></pre> <p>Parameters explained: - ATF=... - Path to TF-A BL31 (will be embedded in tispl.bin) - DM=... - Device Management firmware for M4F - O=... - Output directory</p> <p>Build time: ~3-5 minutes</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#verify-a53-build-output","title":"Verify A53 Build Output","text":"<p>Check what was produced:</p> <pre><code>ls -lh $HOME/embedded-labs/bootloader/build_uboot/a53/\n</code></pre> <p>Critical files: - tispl.bin - TI SPL image (contains A53 SPL + TF-A + DM firmware) - u-boot.img - Full U-Boot bootloader - u-boot - ELF file with debug symbols</p> <p>Size check:</p> <pre><code>ls -lh $HOME/embedded-labs/bootloader/build_uboot/a53/{tispl.bin,u-boot.img}\n</code></pre> <p>Expected sizes: - <code>tispl.bin</code> - ~1.5MB (large because it contains TF-A and DM firmware) - <code>u-boot.img</code> - ~900KB</p> <p>What's in tispl.bin?</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  A53 U-Boot SPL         \u2502  \u2190 Loads full U-Boot\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  TF-A BL31              \u2502  \u2190 Secure monitor\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  DM Firmware            \u2502  \u2190 Device management\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Device Tree Blobs      \u2502  \u2190 Hardware descriptions\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-6-sd-card-preparation","title":"Part 6: SD Card Preparation","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#boot-requirements","title":"Boot Requirements","text":"<p>The TI ROM code expects: 1. FAT32 boot partition with specific type code 2. Bootable flag set on the partition 3. Bootloader files in a specific order</p> <p>We'll also create a second partition for U-Boot environment storage.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#identify-your-sd-card","title":"Identify Your SD Card","text":"<p>Insert your SD card. Check which device it becomes:</p> <pre><code>sudo dmesg | tail -20\n</code></pre> <p>Look for messages like:</p> <pre><code>[12345.678] mmc0: new high speed SDHC card at address 0007\n[12345.680] mmcblk0: mmc0:0007 SD16G 14.9 GiB\n</code></pre> <p>Device naming: - <code>/dev/mmcblk0</code> - SD card on internal reader - <code>/dev/sdb</code> - SD card on USB adapter</p> <p>\u26a0\ufe0f WARNING: Double-check the device name! Using the wrong device will destroy your data!</p> <p>Verify with:</p> <pre><code>lsblk\n</code></pre> <p>For this lab, we'll assume <code>/dev/mmcblk0</code>. Adjust if your device is different!</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#unmount-existing-partitions","title":"Unmount Existing Partitions","text":"<p>If the SD card is auto-mounted:</p> <pre><code>sudo umount /dev/mmcblk0p*\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#erase-partition-table","title":"Erase Partition Table","text":"<p>Zero out the first 16MB to remove any existing partitions:</p> <pre><code>sudo dd if=/dev/zero of=/dev/mmcblk0 bs=1M count=16 status=progress\n</code></pre> <p>What this does: - Removes old partition table - Removes old bootloader remnants - Ensures clean slate</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#create-partition-table","title":"Create Partition Table","text":"<p>We'll use <code>cfdisk</code> for a visual interface:</p> <pre><code>sudo apt install fdisk\nsudo cfdisk /dev/mmcblk0\n</code></pre> <p>If asked to \"Select a label type\", choose dos (MBR partition table). We don't need GPT for SD cards under 2TB.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#create-partitions","title":"Create Partitions","text":"<p>In the cfdisk interface:</p> <p>Partition 1: Boot (FAT32)</p> <ol> <li>Select <code>[ New ]</code></li> <li>Partition size: <code>128M</code></li> <li>Select <code>[ primary ]</code></li> <li>Select <code>[ Type ]</code> \u2192 Choose <code>c</code> (W95 FAT32 LBA)</li> <li>Select <code>[ Bootable ]</code> (asterisk <code>*</code> should appear in Boot column)</li> </ol> <p>Partition 2: U-Boot Environment (ext4)</p> <ol> <li>Move down to free space</li> <li>Select <code>[ New ]</code></li> <li>Partition size: <code>300M</code></li> <li>Select <code>[ primary ]</code></li> <li>Type is already <code>83</code> (Linux) - no change needed</li> </ol> <p>Write Changes:</p> <ol> <li>Select <code>[ Write ]</code></li> <li>Type <code>yes</code> to confirm</li> <li>Select <code>[ Quit ]</code></li> </ol> <p>Your partition table should look like:</p> <pre><code>Device        Boot   Start      End  Sectors  Size Id Type\n/dev/mmcblk0p1 *       2048   264191   262144  128M  c W95 FAT32 (LBA)\n/dev/mmcblk0p2       264192   878591   614400  300M 83 Linux\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#reload-partition-table","title":"Reload Partition Table","text":"<p>Remove and re-insert the SD card, or run:</p> <pre><code>sudo partprobe /dev/mmcblk0\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#create-filesystems","title":"Create Filesystems","text":"<p>Format boot partition as FAT32:</p> <pre><code>sudo mkfs.vfat -F 32 -n boot /dev/mmcblk0p1\n</code></pre> <p>Parameters: - <code>-F 32</code> - FAT32 filesystem - <code>-n boot</code> - Volume label \"boot\"</p> <p>Format environment partition as ext4:</p> <pre><code>sudo mkfs.ext4 -L env -O ^metadata_csum /dev/mmcblk0p2\n</code></pre> <p>Parameters: - <code>-L env</code> - Volume label \"env\" - <code>-O ^metadata_csum</code> - Disable metadata checksums (U-Boot doesn't support them yet)</p> <p>Why disable metadata_csum? Current U-Boot (2021.01) doesn't support ext4 metadata checksums. Without this flag, U-Boot can't read/write the partition.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#mount-boot-partition","title":"Mount Boot Partition","text":"<p>Remove and re-insert the SD card. It should auto-mount to <code>/media/$USER/boot</code>.</p> <p>Verify:</p> <pre><code>mount | grep mmcblk0p1\n</code></pre> <p>You should see:</p> <pre><code>/dev/mmcblk0p1 on /media/your-username/boot type vfat (...)\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-7-install-bootloader-to-sd-card","title":"Part 7: Install Bootloader to SD Card","text":"<p>Now we copy all our built bootloader components to the SD card.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#copy-bootloader-files","title":"Copy Bootloader Files","text":"<pre><code># Copy R5 bootloader (tiboot3.bin)\ncp $HOME/embedded-labs/bootloader/k3-image-gen/tiboot3.bin /media/$USER/boot/\n\n# Copy A53 SPL (tispl.bin)\ncp $HOME/embedded-labs/bootloader/build_uboot/a53/tispl.bin /media/$USER/boot/\n\n# Copy full U-Boot (u-boot.img)\ncp $HOME/embedded-labs/bootloader/build_uboot/a53/u-boot.img /media/$USER/boot/\n</code></pre> <p>Verify all files are present:</p> <pre><code>ls -lh /media/$USER/boot/\n</code></pre> <p>You should see:</p> <pre><code>-rwxr-xr-x 1 you you 279K tiboot3.bin\n-rwxr-xr-x 1 you you 1.5M tispl.bin\n-rwxr-xr-x 1 you you 900K u-boot.img\n</code></pre> <p>Safely eject:</p> <pre><code>sync\nsudo umount /media/$USER/boot\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-8-testing-u-boot","title":"Part 8: Testing U-Boot","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#boot-from-sd-card","title":"Boot from SD Card","text":"<ol> <li>Insert SD card into BeaglePlay</li> <li>Hold USR button (next to SD card slot)</li> <li>Power on or reset the board (keep holding USR)</li> <li>Release USR after 2 seconds</li> </ol> <p>The USR button tells ROM code to boot from SD card instead of eMMC.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#expected-boot-output","title":"Expected Boot Output","text":"<p>On your serial console (picocom), you should see:</p> <pre><code>U-Boot SPL 2021.01-gf036fbdc25 (Jan 15 2025 - 14:33:12 +0100)\nSYSFW ABI: 3.1 (firmware rev 0x0009 '9.1.8--v09.01.08 (Kool Koala)')\nSPL initial stack usage: 13384 bytes\nTrying to boot from MMC2\nspl_load_fit_image: Skip load 'tee': image size is 0!\nLoading Environment from MMC... *** Warning - No MMC card found, using default environment\n\nStarting ATF on ARM64 core...\n\nNOTICE:  BL31: v2.9(release):v2.9.0\nNOTICE:  BL31: Built : 14:28:19, Jan 15 2025\n\n\nU-Boot SPL 2021.01-gf036fbdc25 (Jan 15 2025 - 15:45:30 +0100)\nSYSFW ABI: 3.1 (firmware rev 0x0009 '9.1.8--v09.01.08 (Kool Koala)')\nTrying to boot from MMC2\n\n\nU-Boot 2021.01-gf036fbdc25 (Jan 15 2025 - 15:45:30 +0100)\n\nSoC:   AM62X SR1.0 GP\nModel: BeagleBoard.org BeaglePlay\nBoard: BEAGLEPLAY-A0- rev 02\nDRAM:  2 GiB\nMMC:   mmc@fa10000: 0, mmc@fa00000: 1, mmc@fa20000: 2\nLoading Environment from EXT4... ** File not found /uboot.env **\n** Unable to read \"/uboot.env\" from mmc1:2 **\nIn:    serial@2800000\nOut:   serial@2800000\nErr:   serial@2800000\nNet:   \nError: ethernet@8000000port@1 address not set.\n\nPress SPACE to abort autoboot in 2 seconds\n=&gt;\n</code></pre> <p>Press SPACE to stop autoboot and get to the U-Boot prompt: <code>=&gt;</code></p>"},{"location":"labs/embedded-linux/lab03-bootloader/#analyzing-boot-messages","title":"Analyzing Boot Messages","text":"<p>Let's understand what happened:</p> <p>Stage 1: R5 U-Boot SPL <pre><code>U-Boot SPL 2021.01-gf036fbdc25 (Jan 15 2025 - 14:33:12 +0100)\nSYSFW ABI: 3.1 (firmware rev 0x0009 '9.1.8--v09.01.08 (Kool Koala)')\n</code></pre> - Our R5 SPL started - TIFS firmware loaded (Kool Koala = version 9.1.8)</p> <p>Stage 2: TF-A <pre><code>NOTICE:  BL31: v2.9(release):v2.9.0\nNOTICE:  BL31: Built : 14:28:19, Jan 15 2025\n</code></pre> - Our TF-A started in secure world - Version 2.9 as expected</p> <p>Stage 3: A53 U-Boot SPL <pre><code>U-Boot SPL 2021.01-gf036fbdc25 (Jan 15 2025 - 15:45:30 +0100)\n</code></pre> - A53 SPL loaded full U-Boot</p> <p>Stage 4: Full U-Boot <pre><code>U-Boot 2021.01-gf036fbdc25 (Jan 15 2025 - 15:45:30 +0100)\nSoC:   AM62X SR1.0 GP\nModel: BeagleBoard.org BeaglePlay\nDRAM:  2 GiB\n</code></pre> - Full U-Boot running! - 2GB RAM detected</p> <p>Environment Warning (Expected): <pre><code>** File not found /uboot.env **\n</code></pre> This is normal on first boot - we'll create the environment file later.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#verify-build-dates","title":"Verify Build Dates","text":"<p>\u26a0\ufe0f Important Check: Make sure the dates in the boot messages match when you compiled!</p> <p>If you see old dates (e.g., from March 2024), you're booting from eMMC instead of SD card. Power off, and make sure you're holding the USR button during power-on.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-9-exploring-u-boot-commands","title":"Part 9: Exploring U-Boot Commands","text":"<p>Now that U-Boot is running, let's explore its features.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#basic-commands","title":"Basic Commands","text":"<p>At the <code>=&gt;</code> prompt, try:</p> <pre><code>=&gt; help\n</code></pre> <p>You'll see available commands. Key ones:</p> <ul> <li>printenv - Show environment variables</li> <li>setenv - Set environment variable</li> <li>saveenv - Save environment to storage</li> <li>mmc - MMC/SD card operations</li> <li>fatls - List FAT filesystem</li> <li>ext4ls - List ext4 filesystem</li> <li>bdinfo - Board information</li> <li>reset - Reboot the board</li> <li>boot - Boot operating system</li> </ul> <p>Get help on a specific command:</p> <pre><code>=&gt; help mmc\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#display-board-information","title":"Display Board Information","text":"<pre><code>=&gt; bdinfo\n</code></pre> <p>Output shows: - Boot parameters address - RAM start/size - Stack pointer location - Relocation addresses</p> <pre><code>=&gt; version\n</code></pre> <p>Shows U-Boot version and build configuration.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#explore-mmcsd-card","title":"Explore MMC/SD Card","text":"<p>List MMC devices:</p> <pre><code>=&gt; mmc list\n</code></pre> <p>Output:</p> <pre><code>mmc@fa10000: 0 (eMMC)\nmmc@fa00000: 1\nmmc@fa20000: 2 (SD)\n</code></pre> <p>Switch to SD card:</p> <pre><code>=&gt; mmc dev 2\n</code></pre> <p>List files on boot partition:</p> <pre><code>=&gt; fatls mmc 2:1\n</code></pre> <p>You should see:</p> <pre><code>   279552   tiboot3.bin\n  1572864   tispl.bin\n   921600   u-boot.img\n\n3 file(s), 0 dir(s)\n</code></pre> <p>These are the files we copied earlier!</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#memory-operations","title":"Memory Operations","text":"<p>Display memory (example - this won't show meaningful data yet):</p> <pre><code>=&gt; md 0x82000000 0x10\n</code></pre> <p>This displays 16 (0x10) words starting at address 0x82000000 in RAM.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-10-u-boot-environment-persistence","title":"Part 10: U-Boot Environment Persistence","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#understanding-u-boot-environment","title":"Understanding U-Boot Environment","text":"<p>The environment stores: - Boot commands - Network configuration - Custom variables - Boot arguments for Linux</p> <p>By default, it's stored in RAM (lost on reboot). We configured it to persist in ext4.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#view-current-environment","title":"View Current Environment","text":"<pre><code>=&gt; printenv\n</code></pre> <p>You'll see many variables like:</p> <pre><code>bootcmd=run findfdt; run envboot; run init_${boot_fit}; run get_kern_...\nbootdelay=2\nbaudrate=115200\narch=arm\ncpu=armv8\nboard=am62x\nsoc=am62\n...\n</code></pre> <p>Key variables: - bootcmd - Command executed after bootdelay - bootdelay - Seconds to wait before auto-boot - bootargs - Arguments passed to Linux kernel</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#create-custom-variable","title":"Create Custom Variable","text":"<pre><code>=&gt; setenv labtest \"BeaglePlay bootloader working!\"\n=&gt; printenv labtest\n</code></pre> <p>Should show:</p> <pre><code>labtest=BeaglePlay bootloader working!\n</code></pre> <p>Now reboot:</p> <pre><code>=&gt; reset\n</code></pre> <p>After reboot, press SPACE to stop autoboot, then:</p> <pre><code>=&gt; printenv labtest\n</code></pre> <p>Output:</p> <pre><code>## Error: \"labtest\" not defined\n</code></pre> <p>The variable is gone because we didn't save it!</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#save-environment","title":"Save Environment","text":"<p>Set the variable again:</p> <pre><code>=&gt; setenv labtest \"BeaglePlay persistent test\"\n=&gt; saveenv\n</code></pre> <p>You should see:</p> <pre><code>Saving Environment to EXT4... File System is consistent\nupdate journal finished\n1153 bytes written in 15 ms (74.2 KiB/s)\n</code></pre> <p>This created <code>/uboot.env</code> on partition 2!</p> <p>Now reboot and verify:</p> <pre><code>=&gt; reset\n</code></pre> <p>(Press SPACE to stop autoboot)</p> <pre><code>=&gt; printenv labtest\n</code></pre> <p>Output:</p> <pre><code>labtest=BeaglePlay persistent test\n</code></pre> <p>Success! The environment persists across reboots.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#inspect-environment-file","title":"Inspect Environment File","text":"<p>Boot to Linux later (Lab 4), and you can inspect the environment:</p> <pre><code># From Linux on BeaglePlay\nls -lh /boot/uboot.env\nhexdump -C /boot/uboot.env | head\n</code></pre> <p>You'll see it's a binary file with CRC checksums.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#reset-to-default-environment","title":"Reset to Default Environment","text":"<p>If you need to reset everything:</p> <pre><code>=&gt; env default -a\n=&gt; saveenv\n</code></pre> <p>This restores factory defaults.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#part-11-adding-custom-commands-to-u-boot","title":"Part 11: Adding Custom Commands to U-Boot","text":"<p>Let's enable the <code>config</code> command to dump U-Boot's build configuration.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#check-current-commands","title":"Check Current Commands","text":"<pre><code>=&gt; help | grep config\n</code></pre> <p>If you don't see <code>config</code>, it's not enabled.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#enable-config-command","title":"Enable Config Command","text":"<p>Back on your development PC, reconfigure U-Boot:</p> <pre><code>cd $HOME/embedded-labs/bootloader/u-boot\nmake menuconfig O=$HOME/embedded-labs/bootloader/build_uboot/a53/\n</code></pre> <p>Navigate to:</p> <pre><code>Command line interface \u2192\n  Info commands \u2192\n    [*] config\n</code></pre> <p>Press Space to enable (asterisk should appear).</p> <p>Save and exit menuconfig.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#rebuild-u-boot","title":"Rebuild U-Boot","text":"<pre><code>make -j$(nproc) \\\n     ATF=$HOME/embedded-labs/bootloader/arm-trusted-firmware/build/k3/lite/release/bl31.bin \\\n     DM=$HOME/embedded-labs/bootloader/ti-linux-firmware/ti-dm/am62xx/ipc_echo_testb_mcu1_0_release_strip.xer5f \\\n     O=$HOME/embedded-labs/bootloader/build_uboot/a53/\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#update-sd-card","title":"Update SD Card","text":"<pre><code># Re-mount if needed\n# Copy only the changed file (u-boot.img)\ncp $HOME/embedded-labs/bootloader/build_uboot/a53/u-boot.img /media/$USER/boot/\nsync\n</code></pre> <p>Note: We don't need to update tispl.bin or tiboot3.bin - only u-boot.img changed.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#test-new-command","title":"Test New Command","text":"<p>Reboot BeaglePlay (hold USR button!), stop at U-Boot prompt:</p> <pre><code>=&gt; config\n</code></pre> <p>You should see lots of output:</p> <pre><code>CONFIG_ARM=y\nCONFIG_ARCH_K3=y\nCONFIG_SYS_MALLOC_F_LEN=0x8000\nCONFIG_SPL_LIBCOMMON_SUPPORT=y\n...\n</code></pre> <p>This shows every CONFIG option U-Boot was built with - very useful for debugging!</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#challenge-add-more-commands","title":"Challenge: Add More Commands","text":"<p>Try enabling these commands in menuconfig:</p> <ol> <li><code>base</code> - Print numbers in different bases (hex, dec, oct)</li> <li><code>blob</code> - Manipulate Blob objects</li> <li><code>crc32</code> - Calculate CRC32 checksum</li> </ol> <p>Each time: 1. Enable in menuconfig 2. Rebuild 3. Copy u-boot.img to SD card 4. Test on hardware</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#troubleshooting","title":"Troubleshooting","text":"<p>Marvin's note: \"I've calculated your chances of success. You won't like them. But here's how to improve the odds anyway.\"</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#board-wont-boot-from-sd-card","title":"Board Won't Boot from SD Card","text":"<p>Symptom: Old boot messages, or no output</p> <p>Causes: 1. Not holding USR button during power-on 2. SD card not fully inserted 3. Bootloader files missing or corrupted</p> <p>Solution: - Power off completely (unplug USB-C) - Verify SD card has tiboot3.bin, tispl.bin, u-boot.img - Insert SD card firmly - Hold USR button, plug in power, wait 3 seconds, release</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#no-mmc-card-found-error","title":"\"No MMC card found\" Error","text":"<p>Symptom: Environment save fails</p> <p>Cause: Partition 2 not formatted correctly</p> <p>Solution:</p> <pre><code>sudo mkfs.ext4 -L env -O ^metadata_csum /dev/mmcblk0p2\n</code></pre> <p>Make sure you used <code>-O ^metadata_csum</code> (disables metadata checksums).</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#environment-save-shows-file-system-inconsistent","title":"Environment Save Shows \"File System Inconsistent\"","text":"<p>Cause: ext4 partition has errors</p> <p>Solution:</p> <pre><code>sudo fsck.ext4 -f /dev/mmcblk0p2\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#build-error-arm-none-eabi-gcc-command-not-found","title":"Build Error: \"arm-none-eabi-gcc: command not found\"","text":"<p>Cause: 32-bit toolchain not in PATH</p> <p>Solution:</p> <pre><code>export PATH=$HOME/x-tools/arm-gnu-toolchain-12.2.rel1-x86_64-arm-none-eabi/bin:$PATH\n</code></pre> <p>Add to <code>~/.bashrc</code> for persistence.</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#build-error-bl31bin-no-such-file","title":"Build Error: \"bl31.bin: No such file\"","text":"<p>Cause: TF-A not built or wrong path</p> <p>Solution:</p> <pre><code># Check if TF-A was built\nls -lh $HOME/embedded-labs/bootloader/arm-trusted-firmware/build/k3/lite/release/bl31.bin\n\n# If missing, rebuild TF-A\ncd $HOME/embedded-labs/bootloader/arm-trusted-firmware/\nmake ARCH=aarch64 PLAT=k3 TARGET_BOARD=lite -j$(nproc)\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#wrong-dates-in-boot-messages","title":"Wrong Dates in Boot Messages","text":"<p>Symptom: Boot messages show dates from months ago</p> <p>Cause: Booting from eMMC instead of SD card</p> <p>Solution: - Completely power off - Make absolutely sure you're holding USR button during power-on - Check that tiboot3.bin on SD card has recent timestamp</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#serial-console-shows-garbage","title":"Serial Console Shows Garbage","text":"<p>Cause: Wrong baud rate</p> <p>Solution:</p> <pre><code># Exit picocom: Ctrl+A, Ctrl+X\n# Restart with correct settings\npicocom -b 115200 /dev/ttyUSB0\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#verification-checklist","title":"Verification Checklist","text":"<p>Ford Prefect says: \"Always verify your work. It's the difference between a working system and a very expensive paperweight.\"</p> <p>Before moving to the next lab, ensure:</p> <ul> <li>[ ] 32-bit ARM toolchain (<code>arm-none-eabi-gcc</code>) installed and working</li> <li>[ ] 64-bit ARM64 toolchain from Lab 1 still working</li> <li>[ ] R5 U-Boot SPL built successfully</li> <li>[ ] TF-A v2.9 built successfully</li> <li>[ ] A53 U-Boot built successfully</li> <li>[ ] SD card partitioned correctly (FAT32 boot + ext4 env)</li> <li>[ ] All three bootloader files copied to SD card</li> <li>[ ] Board boots from SD card (verify dates in boot messages)</li> <li>[ ] U-Boot prompt accessible by pressing SPACE</li> <li>[ ] Environment variables can be saved and persist across reboots</li> <li>[ ] Custom U-Boot command (config) successfully added and tested</li> </ul>"},{"location":"labs/embedded-linux/lab03-bootloader/#going-further-optional-challenges","title":"Going Further (Optional Challenges)","text":""},{"location":"labs/embedded-linux/lab03-bootloader/#challenge-1-boot-time-optimization","title":"Challenge 1: Boot Time Optimization","text":"<p>Goal: Measure and reduce boot time to U-Boot prompt</p> <p>Tasks: 1. Add timing to boot messages (search for CONFIG_BOOTSTAGE) 2. Measure total time from power-on to U-Boot prompt 3. Reduce bootdelay from 2 seconds to 0 4. Investigate SPL size reduction options</p> <p>Hints: - Use a stopwatch or video recording to time boot - Check <code>CONFIG_BOOTDELAY</code> in menuconfig - Look for unnecessary drivers in SPL defconfig</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#challenge-2-secure-boot-exploration","title":"Challenge 2: Secure Boot Exploration","text":"<p>Goal: Understand the X.509 certificate in tiboot3.bin</p> <p>Tasks: 1. Extract the certificate from tiboot3.bin 2. Examine it with openssl 3. Research how HS (High Security) devices verify signatures</p> <p>Hints:</p> <pre><code># The certificate is at the beginning of tiboot3.bin\ndd if=tiboot3.bin of=cert.der bs=1 count=2048\nopenssl x509 -inform DER -in cert.der -text -noout\n</code></pre>"},{"location":"labs/embedded-linux/lab03-bootloader/#challenge-3-multi-boot-configuration","title":"Challenge 3: Multi-Boot Configuration","text":"<p>Goal: Create boot menu to choose between SD card and eMMC</p> <p>Tasks: 1. Research U-Boot boot scripts (boot.scr) 2. Create a menu using <code>bootmenu</code> command 3. Allow selecting boot device at startup</p> <p>Hints: - Look for CONFIG_CMD_BOOTMENU - Check U-Boot documentation: doc/README.bootmenu - Use <code>setenv bootmenu_*</code> variables</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#challenge-4-network-boot-preparation","title":"Challenge 4: Network Boot Preparation","text":"<p>Goal: Configure U-Boot for TFTP network booting (needed in Lab 4)</p> <p>Tasks: 1. Set up static IP address in U-Boot environment 2. Configure TFTP server IP 3. Test network connectivity with <code>ping</code></p> <p>Hints:</p> <pre><code>setenv ipaddr 192.168.1.100\nsetenv serverip 192.168.1.1\nping ${serverip}\n</code></pre> <p>(Won't work yet - we need to configure Ethernet in Lab 4)</p>"},{"location":"labs/embedded-linux/lab03-bootloader/#summary","title":"Summary","text":"<p>In this lab, you:</p> <p>\u2705 Understood the complex AM62x multi-stage boot architecture \u2705 Built bootloader components for two different CPU architectures (32-bit R5, 64-bit A53) \u2705 Compiled R5 U-Boot SPL with 32-bit ARM toolchain \u2705 Built ARM Trusted Firmware for secure boot services \u2705 Configured and compiled full U-Boot for A53 \u2705 Created properly formatted SD card with boot and environment partitions \u2705 Successfully booted BeaglePlay from custom bootloader \u2705 Learned U-Boot commands and environment management \u2705 Added custom commands by reconfiguring U-Boot  </p>"},{"location":"labs/embedded-linux/lab03-bootloader/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Multi-stage boot is complex - BeaglePlay requires 5+ components working together</li> <li>Architecture matters - Different CPUs need different toolchains</li> <li>Boot order is critical - Each stage must correctly hand off to the next</li> <li>Environment persistence - Proper filesystem configuration enables saving settings</li> <li>U-Boot is customizable - Can add/remove features via menuconfig</li> </ol>"},{"location":"labs/embedded-linux/lab03-bootloader/#whats-next","title":"What's Next?","text":"<p>In Lab 4, we'll: - Compile the Linux kernel for BeaglePlay - Configure kernel for AM62x hardware - Learn about Device Trees - Boot kernel over network (TFTP) - Configure U-Boot for kernel loading</p> <p>The bootloader is ready - now we need an operating system!</p> <p>Estimated completion time: 4-5 hours Difficulty: \u2b50\u2b50\u2b50\u2b50 (Advanced)</p> <p>Questions? Refer to: - U-Boot Documentation - TI AM62x Technical Reference - ARM Trusted Firmware Docs</p>"},{"location":"labs/embedded-linux/lab04-kernel/","title":"Lab 4: Linux Kernel for BeaglePlay","text":""},{"location":"labs/embedded-linux/lab04-kernel/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about the Linux kernel:</p> <p>\"The Linux kernel is the brain of your embedded system. Unlike certain galactic presidents, it's actually quite good at multitasking, managing hardware, and not generally causing chaos. Though both occasionally crash when faced with infinite improbability.\"</p>"},{"location":"labs/embedded-linux/lab04-kernel/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will be able to:</p> <ul> <li>Clone and navigate the Linux kernel source tree</li> <li>Configure the kernel for ARM64 and BeaglePlay hardware</li> <li>Cross-compile the Linux kernel and Device Tree Blobs</li> <li>Load kernel and DTB via TFTP network boot</li> <li>Set up U-Boot to boot Linux</li> <li>Understand kernel boot arguments and console configuration</li> <li>Troubleshoot kernel boot issues</li> </ul> <p>Estimated Time: 3-4 hours</p> <p>Prerequisites: - Completed Lab 1 (Custom Toolchain) - Completed Lab 2 (Hardware Discovery) - Completed Lab 3 (U-Boot Bootloader) - Familiarity with git - Basic understanding of kernel configuration</p>"},{"location":"labs/embedded-linux/lab04-kernel/#introduction","title":"Introduction","text":""},{"location":"labs/embedded-linux/lab04-kernel/#why-build-your-own-kernel","title":"Why Build Your Own Kernel?","text":"<p>The Linux kernel is the heart of your embedded system. While many projects use pre-built kernels, building your own gives you:</p> <p>Control - Enable/disable drivers for your specific hardware - Optimize for size, performance, or power consumption - Add custom patches or out-of-tree drivers</p> <p>Learning - Understand what's actually running on your hardware - Debug kernel issues with symbols and source access - Experiment with new kernel features</p> <p>Customization - Remove unnecessary features to reduce boot time - Add security features (SELinux, AppArmor, etc.) - Tune for real-time performance (PREEMPT_RT)</p> <p>For BeaglePlay, we need a kernel that supports: - TI AM62x SoC (K3 multicore architecture) - ARM Cortex-A53 processors (ARMv8-A, 64-bit) - BeaglePlay peripherals (Ethernet, mikroBUS, GPIO, etc.) - Device Tree for hardware description</p>"},{"location":"labs/embedded-linux/lab04-kernel/#what-well-build","title":"What We'll Build","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Linux Kernel Sources  \u2502 \u2190 Clone from kernel.org\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Configuration         \u2502 \u2190 defconfig + menuconfig\n\u2502  (arm64 + K3 SoC)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Cross-Compilation     \u2502 \u2190 aarch64-beagleplay-linux-musl-gcc\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Output Files:                          \u2502\n\u2502  - Image.gz (compressed kernel)         \u2502\n\u2502  - k3-am625-beagleplay.dtb (Device Tree)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  U-Boot TFTP Boot      \u2502 \u2190 Network loading\n\u2502  - tftp Image.gz       \u2502\n\u2502  - tftp DTB            \u2502\n\u2502  - booti command       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#workspace-setup","title":"Workspace Setup","text":"<p>Create kernel lab directory:</p> <pre><code>cd $HOME/embedded-labs\nmkdir -p kernel\ncd kernel\n</code></pre> <p>All kernel work happens here.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#part-1-getting-the-kernel-sources","title":"Part 1: Getting the Kernel Sources","text":""},{"location":"labs/embedded-linux/lab04-kernel/#understanding-kernel-versions","title":"Understanding Kernel Versions","text":"<p>The Linux kernel has two main development branches:</p> <p>Mainline (Linus Tree) - Latest development code - Managed by Linus Torvalds - New features, potentially less stable - Repository: <code>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux</code></p> <p>Stable Releases - Long-term support versions - Bug fixes and security patches - More stable for production - Repository: <code>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux</code></p> <p>For this lab, we'll use Linux 6.6.x (LTS - Long Term Support).</p>"},{"location":"labs/embedded-linux/lab04-kernel/#clone-the-kernel","title":"Clone the Kernel","text":"<p>\u26a0\ufe0f  WARNING (in large, friendly letters): The kernel repository is huge (~3GB). This will take 15-30 minutes on a typical connection.</p> <p>Clone Linus's mainline tree:</p> <pre><code>cd $HOME/embedded-labs/kernel\ngit clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux\ncd linux\n</code></pre> <p>While it downloads, understand what you're getting: - 50,000+ files - 30+ million lines of code - 80,000+ git commits - Drivers for thousands of devices</p> <p>Check the current version:</p> <pre><code>make kernelversion\n</code></pre> <p>You'll see something like <code>6.12.0-rc5</code> (a release candidate from mainline).</p>"},{"location":"labs/embedded-linux/lab04-kernel/#add-stable-releases","title":"Add Stable Releases","text":"<p>The stable tree contains tested LTS versions. Add it as a remote:</p> <pre><code>git remote add stable https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux\ngit fetch stable\n</code></pre> <p>This fetches stable branches (another ~2GB download, but incremental).</p> <p>List available stable branches:</p> <pre><code>git branch -r | grep stable\n</code></pre> <p>You'll see many branches:</p> <pre><code>stable/linux-4.19.y\nstable/linux-5.4.y\nstable/linux-5.10.y\nstable/linux-5.15.y\nstable/linux-6.1.y\nstable/linux-6.6.y   \u2190 We'll use this one\nstable/linux-6.12.y\n</code></pre> <p>The <code>.y</code> suffix means \"all patch releases\" (e.g., 6.6.1, 6.6.2, 6.6.3...).</p>"},{"location":"labs/embedded-linux/lab04-kernel/#checkout-stable-version","title":"Checkout Stable Version","text":"<p>Switch to Linux 6.6.x:</p> <pre><code>git checkout stable/linux-6.6.y\n</code></pre> <p>Verify the version:</p> <pre><code>make kernelversion\n</code></pre> <p>Should show something like <code>6.6.60</code> (exact patch version depends on when you ran this).</p> <p>Why 6.6? - LTS version (supported until December 2026) - Excellent TI AM62x support - Tested with BeaglePlay - Good balance of features vs stability</p>"},{"location":"labs/embedded-linux/lab04-kernel/#part-2-kernel-configuration","title":"Part 2: Kernel Configuration","text":""},{"location":"labs/embedded-linux/lab04-kernel/#understanding-kernel-configuration","title":"Understanding Kernel Configuration","text":"<p>The kernel has 10,000+ configuration options! Examples: - Which filesystems to support (ext4, FAT, NFS) - Which drivers to include (Ethernet, USB, GPIO) - Processor-specific optimizations - Debug features</p> <p>Configuration is managed by Kconfig, similar to U-Boot's system.</p> <p>Three build options for each feature: - <code>y</code> - Built into kernel image (always loaded) - <code>m</code> - Built as loadable module (can be loaded at runtime) - <code>n</code> - Not built (disabled)</p>"},{"location":"labs/embedded-linux/lab04-kernel/#set-cross-compilation-environment","title":"Set Cross-Compilation Environment","text":"<p>Tell the kernel build system we're cross-compiling:</p> <pre><code>export ARCH=arm64\nexport CROSS_COMPILE=aarch64-beagleplay-linux-musl-\n</code></pre> <p>Important (like knowing where your towel is): We use arm64 (not aarch64) for the kernel! - Kernel calls 64-bit ARM \"arm64\" - Toolchains call it \"aarch64\" - Both mean the same thing</p> <p>Add to <code>~/.bashrc</code> for persistence:</p> <pre><code>echo 'export ARCH=arm64' &gt;&gt; ~/.bashrc\necho 'export CROSS_COMPILE=aarch64-beagleplay-linux-musl-' &gt;&gt; ~/.bashrc\n</code></pre> <p>Verify toolchain is in PATH:</p> <pre><code>${CROSS_COMPILE}gcc --version\n</code></pre> <p>Should show:</p> <pre><code>aarch64-beagleplay-linux-musl-gcc (GCC) 13.2.0\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#find-default-configuration","title":"Find Default Configuration","text":"<p>List available default configurations for arm64:</p> <pre><code>make help | grep defconfig\n</code></pre> <p>Or see all arm64 defconfigs:</p> <pre><code>ls -1 arch/arm64/configs/\n</code></pre> <p>Output:</p> <pre><code>defconfig  \u2190 This is the one we want!\n</code></pre> <p>Unlike some architectures, ARM64 has a single unified <code>defconfig</code> that supports many boards through Device Tree.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#load-base-configuration","title":"Load Base Configuration","text":"<p>Load the ARM64 default configuration:</p> <pre><code>make defconfig\n</code></pre> <p>This creates <code>.config</code> in the kernel source directory with ~8,000 configuration options.</p> <p>Inspect the config file (optional):</p> <pre><code>head -50 .config\n</code></pre> <p>You'll see lines like:</p> <pre><code>CONFIG_ARM64=y\nCONFIG_64BIT=y\nCONFIG_ARCH_K3=y\n...\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#customize-configuration","title":"Customize Configuration","text":"<p>Now fine-tune the config with menuconfig:</p> <pre><code>make menuconfig\n</code></pre> <p>This opens a text-based UI. Navigate with: - Arrow keys - Move around - Enter - Select submenu - Space - Toggle option (y/m/n) - / - Search for config option - ? - Help on current option - Save - Write .config - Exit - Go back or quit</p> <p>Recommended Changes:</p> <p>1. Disable GCC Plugins (avoid build dependencies)</p> <p>Navigate to: <pre><code>Kernel hacking \u2192\n  Compile-time checks and compiler options \u2192\n    [ ] GCC plugins\n</code></pre></p> <p>Press Space to disable (no asterisk).</p> <p>2. Optimize for BeaglePlay (reduce kernel size)</p> <p>Navigate to: <pre><code>Platform selection \u2192\n</code></pre></p> <p>You'll see options for: - <code>[ ]</code> Actions Semi Platforms - <code>[ ]</code> NVIDIA Tegra SoC Family - <code>[*]</code> Texas Instruments Inc. K3 multicore SoC architecture \u2190 Keep ONLY this! - <code>[ ]</code> ARMv8 software model (Versatile Express) - Many more...</p> <p>Disable everything except \"Texas Instruments Inc. K3\" - this removes support for hundreds of boards we don't need.</p> <p>3. Disable Display Drivers (not needed for initial testing)</p> <p>Navigate to: <pre><code>Device Drivers \u2192\n  Graphics support \u2192\n    [ ] Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)\n</code></pre></p> <p>Disable this whole section - saves ~50MB in kernel size!</p> <p>4. Enable Networking Features (for TFTP and NFS)</p> <p>Navigate to: <pre><code>Device Drivers \u2192\n  Network device support \u2192\n    Ethernet driver support \u2192\n      [*] Texas Instruments (TI) devices\n        &lt;*&gt; TI K3 AM65 CPSW Ethernet driver\n</code></pre></p> <p>Make sure this is enabled (built-in, not module) - we need it for network boot!</p> <p>Optional Configuration Changes:</p> <p>Search (<code>/</code>) for these and verify they're enabled: - <code>CONFIG_NFS_FS</code> - NFS client (for root filesystem over network later) - <code>CONFIG_IP_PNP</code> - IP autoconfiguration (simplifies network boot) - <code>CONFIG_ROOT_NFS</code> - Root filesystem over NFS - <code>CONFIG_DEVTMPFS_MOUNT</code> - Auto-mount /dev (needed for init)</p> <p>Save configuration and exit menuconfig.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#verify-configuration","title":"Verify Configuration","text":"<p>Check that key options are set:</p> <pre><code>grep -E \"CONFIG_ARCH_K3|CONFIG_NFS_FS|CONFIG_DEVTMPFS_MOUNT\" .config\n</code></pre> <p>Should show:</p> <pre><code>CONFIG_ARCH_K3=y\nCONFIG_NFS_FS=y\nCONFIG_DEVTMPFS_MOUNT=y\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#part-3-cross-compiling-the-kernel","title":"Part 3: Cross-Compiling the Kernel","text":""},{"location":"labs/embedded-linux/lab04-kernel/#install-build-dependencies","title":"Install Build Dependencies","text":"<p>The kernel build needs several development packages:</p> <pre><code>sudo apt install build-essential libssl-dev libelf-dev flex bison\n</code></pre> <p>What these provide: - build-essential - GCC, make, etc. (for host tools) - libssl-dev - Cryptographic signing of kernel modules - libelf-dev - ELF binary parsing (for objtool) - flex - Lexical analyzer (for config parsers) - bison - Parser generator (for config parsers)</p>"},{"location":"labs/embedded-linux/lab04-kernel/#compile-the-kernel","title":"Compile the Kernel","text":"<p>Now build it!</p> <pre><code>make -j$(nproc)\n</code></pre> <p>What happens during the build:</p> <ol> <li>Host tools compilation (~30 seconds)</li> <li> <p>Builds scripts and utilities needed for kernel build</p> </li> <li> <p>Kernel compilation (~10-20 minutes on 4-core machine)</p> </li> <li>Compiles ~8,000 .c files</li> <li> <p>Links into vmlinux (uncompressed kernel)</p> </li> <li> <p>Image creation (~30 seconds)</p> </li> <li> <p>Compresses vmlinux \u2192 Image.gz</p> </li> <li> <p>Device Tree compilation (~10 seconds)</p> </li> <li> <p>Compiles .dts files \u2192 .dtb blobs</p> </li> <li> <p>Module compilation (if any modules enabled)</p> </li> </ol> <p>Total time: 10-25 minutes depending on CPU.</p> <p>Progress output looks like:</p> <pre><code>  CC      init/main.o\n  CC      init/version.o\n  CC      init/do_mounts.o\n  ...\n  LD      vmlinux\n  OBJCOPY arch/arm64/boot/Image\n  GZIP    arch/arm64/boot/Image.gz\n  DTC     arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#verify-build-output","title":"Verify Build Output","text":"<p>Check what was produced:</p> <pre><code>ls -lh arch/arm64/boot/\n</code></pre> <p>You should see:</p> <pre><code>-rw-r--r-- 1 you you  22M Image          \u2190 Uncompressed kernel\n-rw-r--r-- 1 you you 9.8M Image.gz       \u2190 Compressed kernel (use this!)\ndrwxr-xr-x 8 you you 4.0K dts            \u2190 Device Tree sources\n</code></pre> <p>The Image.gz is our bootable kernel - compressed from 22MB to 9.8MB!</p>"},{"location":"labs/embedded-linux/lab04-kernel/#find-the-device-tree-blob","title":"Find the Device Tree Blob","text":"<p>Device Trees are in subdirectories by vendor:</p> <pre><code>ls arch/arm64/boot/dts/ti/*.dtb | grep beagleplay\n</code></pre> <p>Output:</p> <pre><code>arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb\n</code></pre> <p>This is our Device Tree Blob (DTB) for BeaglePlay!</p> <p>Inspect its size:</p> <pre><code>ls -lh arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb\n</code></pre> <p>Should be around 200-250KB.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#understanding-build-artifacts","title":"Understanding Build Artifacts","text":"File Purpose Size Use vmlinux Uncompressed kernel ELF ~150MB Debugging with symbols Image Raw uncompressed kernel binary ~22MB Direct boot (no compression) Image.gz Gzip compressed kernel ~10MB \u2190 Use this for boot! k3-am625-beagleplay.dtb Device Tree Blob ~250KB Hardware description <p>We'll use Image.gz and k3-am625-beagleplay.dtb for booting.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#part-4-network-boot-setup","title":"Part 4: Network Boot Setup","text":"<p>Before we can boot the kernel, we need to set up TFTP for network loading.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#configure-u-boot-networking","title":"Configure U-Boot Networking","text":"<p>Power on BeaglePlay, hold USR button, stop at U-Boot prompt.</p> <p>Set IP addresses in U-Boot:</p> <pre><code>=&gt; setenv ipaddr 192.168.1.100\n=&gt; setenv serverip 192.168.1.1\n=&gt; saveenv\n</code></pre> <p>Adjust these IPs for your network! The board (ipaddr) and your PC (serverip) must be on the same subnet.</p> <p>Verify the settings:</p> <pre><code>=&gt; printenv ipaddr serverip\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#configure-pc-network-interface","title":"Configure PC Network Interface","text":"<p>Find your Ethernet interface connected to BeaglePlay:</p> <pre><code>ip a\n</code></pre> <p>Look for the interface that appears when you plug in the Ethernet cable. It might be named: - <code>enp0s31f6</code> (PCIe Ethernet) - <code>enx...</code> (USB Ethernet adapter) - <code>eth0</code> (older naming)</p> <p>Method 1: Using NetworkManager CLI (recommended)</p> <pre><code>sudo nmcli con add type ethernet ifname YOUR_INTERFACE ip4 192.168.1.1/24\n</code></pre> <p>Replace <code>YOUR_INTERFACE</code> with your actual interface name.</p> <p>Method 2: Manual configuration (if NetworkManager not available)</p> <pre><code>sudo ip addr add 192.168.1.1/24 dev YOUR_INTERFACE\nsudo ip link set YOUR_INTERFACE up\n</code></pre> <p>Verify the configuration:</p> <pre><code>ip addr show YOUR_INTERFACE\n</code></pre> <p>Should show:</p> <pre><code>inet 192.168.1.1/24 scope global YOUR_INTERFACE\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#install-tftp-server","title":"Install TFTP Server","text":"<p>Install <code>tftpd-hpa</code>:</p> <pre><code>sudo apt install tftpd-hpa\n</code></pre> <p>Check the TFTP server configuration:</p> <pre><code>cat /etc/default/tftpd-hpa\n</code></pre> <p>Should show:</p> <pre><code>TFTP_USERNAME=\"tftp\"\nTFTP_DIRECTORY=\"/srv/tftp\"\nTFTP_ADDRESS=\":69\"\nTFTP_OPTIONS=\"--secure\"\n</code></pre> <p>The default TFTP directory is <code>/srv/tftp</code>.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#prepare-tftp-directory","title":"Prepare TFTP Directory","text":"<p>Create and set permissions:</p> <pre><code>sudo mkdir -p /srv/tftp\nsudo chown -R $USER:$USER /srv/tftp\n</code></pre> <p>Restart TFTP server:</p> <pre><code>sudo systemctl restart tftpd-hpa\nsudo systemctl status tftpd-hpa\n</code></pre> <p>Should show \"active (running)\".</p>"},{"location":"labs/embedded-linux/lab04-kernel/#test-tftp-connection","title":"Test TFTP Connection","text":"<p>Create a test file:</p> <pre><code>echo \"TFTP test from BeaglePlay\" &gt; /srv/tftp/test.txt\n</code></pre> <p>From U-Boot on BeaglePlay:</p> <pre><code>=&gt; tftp 0x82000000 test.txt\n</code></pre> <p>Expected output:</p> <pre><code>Using ethernet@8000000 port@1 device\nTFTP from server 192.168.1.1; our IP address is 192.168.1.100\nFilename 'test.txt'.\nLoad address: 0x82000000\nLoading: #\n         5.9 KiB/s\ndone\nBytes transferred = 28 (1c hex)\n</code></pre> <p>Success! TFTP is working.</p> <p>Verify the data was downloaded:</p> <pre><code>=&gt; md 0x82000000\n</code></pre> <p>Should show the test file content.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#troubleshooting-tftp","title":"Troubleshooting TFTP","text":"<p>Problem: <code>TFTP error: 'Access violation'</code></p> <p>Cause: File permissions or wrong directory</p> <p>Solution:</p> <pre><code>sudo chmod -R 755 /srv/tftp\nsudo chown -R tftp:tftp /srv/tftp\n</code></pre> <p>Problem: <code>TFTP timeout</code></p> <p>Cause: Firewall blocking TFTP port 69</p> <p>Solution:</p> <pre><code>sudo ufw allow from 192.168.1.100 to any port 69 proto udp\n</code></pre> <p>Or temporarily disable firewall:</p> <pre><code>sudo ufw disable\n</code></pre> <p>Problem: <code>T T T T</code> (continuous timeouts)</p> <p>Cause: Network cable not connected or wrong interface configured</p> <p>Solution: - Check Ethernet cable is firmly connected - Verify PC interface has correct IP: <code>ip addr</code> - Try different network cable</p>"},{"location":"labs/embedded-linux/lab04-kernel/#part-5-booting-the-kernel","title":"Part 5: Booting the Kernel","text":""},{"location":"labs/embedded-linux/lab04-kernel/#copy-kernel-files-to-tftp","title":"Copy Kernel Files to TFTP","text":"<pre><code>cp $HOME/embedded-labs/kernel/linux/arch/arm64/boot/Image.gz /srv/tftp/\ncp $HOME/embedded-labs/kernel/linux/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb /srv/tftp/\n</code></pre> <p>Verify files are present:</p> <pre><code>ls -lh /srv/tftp/\n</code></pre> <p>Should show:</p> <pre><code>-rw-r--r-- 1 you you  28 test.txt\n-rw-r--r-- 1 you you 9.8M Image.gz\n-rw-r--r-- 1 you you 236K k3-am625-beagleplay.dtb\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#configure-kernel-boot-arguments","title":"Configure Kernel Boot Arguments","text":"<p>From U-Boot, set the kernel command line:</p> <pre><code>=&gt; setenv bootargs console=ttyS2,115200n8\n=&gt; saveenv\n</code></pre> <p>Bootargs explanation: - console=ttyS2 - Use serial port 2 for console output - 115200n8 - Baud rate 115200, no parity, 8 data bits</p> <p>This tells the kernel where to send console messages.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#load-kernel-via-tftp","title":"Load Kernel via TFTP","text":"<p>Load the compressed kernel image:</p> <pre><code>=&gt; tftp 0x82000000 Image.gz\n</code></pre> <p>Expected output:</p> <pre><code>Using ethernet@8000000 port@1 device\nTFTP from server 192.168.1.1; our IP address is 192.168.1.100\nFilename 'Image.gz'.\nLoad address: 0x82000000\nLoading: ########################### ... ###\n         9.1 MiB/s\ndone\nBytes transferred = 10281472 (9ce300 hex)\n</code></pre> <p>Note the hex size - we'll need this in the next step.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#load-device-tree-via-tftp","title":"Load Device Tree via TFTP","text":"<pre><code>=&gt; tftp 0x88000000 k3-am625-beagleplay.dtb\n</code></pre> <p>Different address (0x88000000) to avoid overwriting the kernel!</p> <p>Expected output:</p> <pre><code>Bytes transferred = 241664 (3b000 hex)\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#understanding-decompression-requirements","title":"Understanding Decompression Requirements","text":"<p>Try to boot:</p> <pre><code>=&gt; booti 0x82000000 - 0x88000000\n</code></pre> <p>You'll get an error:</p> <pre><code>kernel_comp_addr_r or kernel_comp_size is not provided!\n</code></pre> <p>What's happening: - <code>Image.gz</code> is compressed (9.8MB) - Before booting, U-Boot must decompress it - Decompressed size is ~22MB - U-Boot needs to know where to put the decompressed image and its maximum size</p> <p>Set decompression parameters:</p> <pre><code>=&gt; setenv kernel_comp_addr_r 0x90000000\n=&gt; setenv kernel_comp_size 0x2000000\n</code></pre> <p>Parameters explained: - kernel_comp_addr_r - RAM address for decompressed kernel (1.5GB offset) - kernel_comp_size - Max decompressed size (32MB = 0x2000000)</p> <p>Why 32MB? Our uncompressed Image is 22MB, so 32MB gives a safe margin.</p> <p>Save these settings:</p> <pre><code>=&gt; saveenv\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#boot-the-kernel","title":"Boot the Kernel","text":"<p>Now try again:</p> <pre><code>=&gt; booti 0x82000000 - 0x88000000\n</code></pre> <p>Success! You should see:</p> <pre><code>## Flattened Device Tree blob at 88000000\n   Booting using the fdt blob at 0x88000000\nWorking FDT set to 88000000\n   Uncompressing Kernel Image to 90000000\n   Loading Device Tree to 000000009f7f5000, end 000000009f7ff3bf ... OK\nWorking FDT set to 9f7f5000\n\nStarting kernel ...\n\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n[    0.000000] Linux version 6.6.60 (you@hostname) (aarch64-beagleplay-linux-musl-gcc (GCC) 13.2.0, GNU ld (GNU Binutils) 2.41) #1 SMP PREEMPT Wed Jan 15 16:45:12 UTC 2025\n[    0.000000] Machine model: BeagleBoard.org BeaglePlay\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x000000009c800000, size 3 MiB\n[    0.000000] OF: reserved mem: initialized node r5f-dma-memory@9c800000, compatible id shared-dma-pool\n...\n[    0.847623] ti-sci 44043000.system-controller: ABI: 3.1 (firmware rev 0x0009 '9.1.8--v09.01.08 (Kool Koala)')\n...\n[    2.156842] am65-cpsw-nuss 8000000.ethernet: initialized cpsw ale version 1.5\n[    2.163789] am65-cpsw-nuss 8000000.ethernet: ALE Table size 512\n...\n</code></pre> <p>The kernel will boot and eventually panic:</p> <pre><code>[    5.234567] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n</code></pre> <p>This is expected! We haven't provided a root filesystem yet. The kernel successfully booted - it just has nowhere to find <code>/sbin/init</code>.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#analyzing-the-boot-messages","title":"Analyzing the Boot Messages","text":"<p>Let's understand what happened:</p> <p>Initial Boot: <pre><code>[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n</code></pre> - CPU ID 0x410fd034 = ARM Cortex-A53 - Physical CPU 0 (first of four A53 cores)</p> <p>Kernel Version: <pre><code>[    0.000000] Linux version 6.6.60 (you@hostname) (aarch64-beagleplay-linux-musl-gcc...)\n</code></pre> - Confirms we're running our custom-built kernel - Built with our Musl toolchain!</p> <p>Hardware Detection: <pre><code>[    0.000000] Machine model: BeagleBoard.org BeaglePlay\n</code></pre> - Device Tree correctly identified the board</p> <p>TI System Firmware: <pre><code>[    0.847623] ti-sci 44043000.system-controller: ABI: 3.1 (firmware rev 0x0009 '9.1.8--v09.01.08 (Kool Koala)')\n</code></pre> - Communication with TIFS firmware working - Same \"Kool Koala\" version we saw in U-Boot</p> <p>Ethernet: <pre><code>[    2.156842] am65-cpsw-nuss 8000000.ethernet: initialized cpsw ale version 1.5\n</code></pre> - Ethernet controller initialized (we'll use this for NFS root later)</p> <p>Expected Panic: <pre><code>[    5.234567] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n</code></pre> - Normal - we haven't configured a root filesystem yet - Lab 5 will build a root filesystem</p>"},{"location":"labs/embedded-linux/lab04-kernel/#part-6-streamlining-the-boot-process","title":"Part 6: Streamlining the Boot Process","text":"<p>Manually typing TFTP commands every boot is tedious. Let's automate it!</p>"},{"location":"labs/embedded-linux/lab04-kernel/#create-boot-script","title":"Create Boot Script","text":"<p>In U-Boot, set environment variables for automatic boot:</p> <pre><code>=&gt; setenv load_kernel 'tftp ${kernel_addr_r} Image.gz'\n=&gt; setenv load_dtb 'tftp ${fdt_addr_r} k3-am625-beagleplay.dtb'\n=&gt; setenv netboot 'run load_kernel; run load_dtb; booti ${kernel_addr_r} - ${fdt_addr_r}'\n</code></pre> <p>Variables explained: - load_kernel - Command to load kernel - load_dtb - Command to load Device Tree - netboot - Run both loads and boot</p> <p>The <code>${kernel_addr_r}</code> and <code>${fdt_addr_r}</code> are predefined U-Boot variables for safe load addresses.</p> <p>Check their values:</p> <pre><code>=&gt; printenv kernel_addr_r fdt_addr_r\n</code></pre> <p>Output:</p> <pre><code>kernel_addr_r=0x82000000\nfdt_addr_r=0x88000000\n</code></pre> <p>Perfect - these are the addresses we used earlier!</p>"},{"location":"labs/embedded-linux/lab04-kernel/#test-the-boot-script","title":"Test the Boot Script","text":"<p>Now you can boot with a single command:</p> <pre><code>=&gt; run netboot\n</code></pre> <p>Should load both files and boot the kernel.</p>"},{"location":"labs/embedded-linux/lab04-kernel/#make-it-automatic-optional","title":"Make It Automatic (Optional)","text":"<p>To boot automatically after a delay:</p> <pre><code>=&gt; setenv bootcmd 'run netboot'\n=&gt; setenv bootdelay 3\n=&gt; saveenv\n</code></pre> <p>Now on every boot, U-Boot will: 1. Wait 3 seconds (press SPACE to interrupt) 2. Automatically run <code>netboot</code> 3. Load kernel and DTB via TFTP 4. Boot Linux</p> <p>Caution: Make sure TFTP server is always running! Otherwise, boot will fail.</p> <p>To disable auto-boot:</p> <pre><code>=&gt; setenv bootcmd\n=&gt; saveenv\n</code></pre> <p>(Empty bootcmd disables auto-boot)</p>"},{"location":"labs/embedded-linux/lab04-kernel/#part-7-kernel-configuration-deep-dive","title":"Part 7: Kernel Configuration Deep Dive","text":""},{"location":"labs/embedded-linux/lab04-kernel/#inspecting-configuration-options","title":"Inspecting Configuration Options","text":"<p>Find out what a specific config does:</p> <pre><code>cd $HOME/embedded-labs/kernel/linux\nmake menuconfig\n</code></pre> <p>Press <code>/</code> (search) and type <code>NFS_FS</code>. You'll see:</p> <pre><code>Symbol: NFS_FS [=y]\nType  : tristate\nDefined at fs/nfs/Kconfig:1\nPrompt: NFS client support\nDepends on: NETWORK_FILESYSTEMS [=y] &amp;&amp; INET [=y]\nLocation:\n  -&gt; File systems\n    -&gt; Network File Systems\n</code></pre> <p>This shows: - Symbol name: CONFIG_NFS_FS - Current value: y (built-in) - Dependencies: Requires networking enabled - Location: Where to find it in menuconfig</p>"},{"location":"labs/embedded-linux/lab04-kernel/#comparing-configurations","title":"Comparing Configurations","text":"<p>Save your current config:</p> <pre><code>cp .config my_beagleplay_config\n</code></pre> <p>Try changing something in menuconfig, then compare:</p> <pre><code>make menuconfig\n# Change some options\nscripts/diffconfig my_beagleplay_config .config\n</code></pre> <p>This shows only the differences!</p>"},{"location":"labs/embedded-linux/lab04-kernel/#viewing-all-enabled-options","title":"Viewing All Enabled Options","text":"<p>See every CONFIG_* set to <code>y</code> or <code>m</code>:</p> <pre><code>grep -E \"^CONFIG_\" .config | grep -v \"# CONFIG\" | wc -l\n</code></pre> <p>Typical ARM64 defconfig: ~2,500 options enabled!</p> <p>See the largest categories:</p> <pre><code>grep -E \"^CONFIG_\" .config | cut -d_ -f1-2 | sort | uniq -c | sort -rn | head -20\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#troubleshooting","title":"Troubleshooting","text":"<p>Marvin's note: \"I've calculated your chances of success. You won't like them. But here's how to improve the odds anyway.\"</p>"},{"location":"labs/embedded-linux/lab04-kernel/#kernel-panics-on-boot","title":"Kernel Panics on Boot","text":"<p>Symptom: Kernel panics before mounting root</p> <p>Possible Causes: 1. Wrong Device Tree (DTB) 2. Missing critical drivers 3. Incorrect bootargs</p> <p>Solution: - Verify DTB filename: <code>k3-am625-beagleplay.dtb</code> - Check bootargs: <code>console=ttyS2,115200n8</code> - Enable debug output: <code>setenv bootargs '${bootargs} debug'</code></p>"},{"location":"labs/embedded-linux/lab04-kernel/#tftp-download-fails","title":"TFTP Download Fails","text":"<p>Symptom: <code>T T T T</code> timeout errors</p> <p>Check List: - [ ] Ethernet cable connected - [ ] PC IP configured: <code>ip addr show</code> - [ ] TFTP server running: <code>systemctl status tftpd-hpa</code> - [ ] Files in <code>/srv/tftp/</code>: <code>ls /srv/tftp/</code> - [ ] Firewall allows TFTP: <code>sudo ufw status</code> - [ ] U-Boot IP correct: <code>printenv ipaddr serverip</code></p>"},{"location":"labs/embedded-linux/lab04-kernel/#kernel-decompression-error","title":"Kernel Decompression Error","text":"<p>Symptom: <code>kernel_comp_addr_r or kernel_comp_size is not provided!</code></p> <p>Solution:</p> <pre><code>setenv kernel_comp_addr_r 0x90000000\nsetenv kernel_comp_size 0x2000000\nsaveenv\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#wrong-console-output","title":"Wrong Console Output","text":"<p>Symptom: No kernel messages on serial console</p> <p>Cause: Wrong console device in bootargs</p> <p>Solution:</p> <p>Check Device Tree for correct serial port:</p> <pre><code>grep -A5 \"chosen\" arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts\n</code></pre> <p>Should show:</p> <pre><code>chosen {\n    stdout-path = \"serial2:115200n8\";\n};\n</code></pre> <p>This means <code>console=ttyS2</code> (serial2 = ttyS2).</p>"},{"location":"labs/embedded-linux/lab04-kernel/#build-errors","title":"Build Errors","text":"<p>Error: <code>No rule to make target 'debian/canonical-certs.pem'</code></p> <p>Cause: Ubuntu-specific certificate config</p> <p>Solution:</p> <pre><code>scripts/config --disable SYSTEM_TRUSTED_KEYS\nscripts/config --disable SYSTEM_REVOCATION_KEYS\nmake olddefconfig\n</code></pre> <p>Error: <code>ld: cannot find -lelf</code></p> <p>Cause: Missing libelf-dev</p> <p>Solution:</p> <pre><code>sudo apt install libelf-dev\n</code></pre> <p>Error: <code>flex: not found</code></p> <p>Cause: Missing flex/bison</p> <p>Solution:</p> <pre><code>sudo apt install flex bison\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#network-interface-not-found","title":"Network Interface Not Found","text":"<p>Symptom: Ethernet not working in kernel</p> <p>Solution:</p> <p>Enable TI K3 Ethernet driver:</p> <pre><code>make menuconfig\n# Navigate to:\n# Device Drivers \u2192 Network device support \u2192 Ethernet driver support \u2192\n# [*] Texas Instruments (TI) devices\n#   &lt;*&gt; TI K3 AM65 CPSW Ethernet driver\n</code></pre> <p>Rebuild:</p> <pre><code>make -j$(nproc)\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#verification-checklist","title":"Verification Checklist","text":"<p>Ford Prefect says: \"Always verify your work. It's the difference between a working system and a very expensive paperweight.\"</p> <p>Before moving to the next lab, ensure:</p> <ul> <li>[ ] Linux kernel source cloned and stable/linux-6.6.y checked out</li> <li>[ ] Kernel configured with ARM64 defconfig and customized for BeaglePlay</li> <li>[ ] Kernel compilation successful</li> <li>[ ] Image.gz and k3-am625-beagleplay.dtb files generated</li> <li>[ ] TFTP server installed and running on development PC</li> <li>[ ] Network configured (PC and BeaglePlay on same subnet)</li> <li>[ ] TFTP download test successful from U-Boot</li> <li>[ ] Kernel boots via TFTP and displays boot messages</li> <li>[ ] Kernel panics with \"Unable to mount root fs\" (expected!)</li> <li>[ ] U-Boot boot script created for streamlined booting</li> </ul>"},{"location":"labs/embedded-linux/lab04-kernel/#going-further-optional-challenges","title":"Going Further (Optional Challenges)","text":""},{"location":"labs/embedded-linux/lab04-kernel/#challenge-1-kernel-size-optimization","title":"Challenge 1: Kernel Size Optimization","text":"<p>Goal: Reduce kernel size by disabling unnecessary features</p> <p>Tasks: 1. Current Image.gz size: ~10MB 2. Target: Get it under 5MB 3. Disable unused drivers (sound, graphics, USB gadgets) 4. Compare boot time before/after</p> <p>Hints: - Use <code>make localmodconfig</code> to only enable currently loaded modules (won't help much on first build) - Disable entire subsystems: sound, media, staging drivers - Check size: <code>ls -lh arch/arm64/boot/Image.gz</code></p>"},{"location":"labs/embedded-linux/lab04-kernel/#challenge-2-custom-kernel-command-line","title":"Challenge 2: Custom Kernel Command Line","text":"<p>Goal: Pass custom parameters to the kernel</p> <p>Tasks: 1. Add <code>initcall_debug</code> to bootargs (shows function call timings) 2. Add <code>quiet</code> to reduce boot messages 3. Compare boot times with different log levels</p> <p>Hints:</p> <pre><code>setenv bootargs 'console=ttyS2,115200n8 initcall_debug'\n</code></pre> <p>Research kernel parameters: <code>Documentation/admin-guide/kernel-parameters.txt</code></p>"},{"location":"labs/embedded-linux/lab04-kernel/#challenge-3-device-tree-exploration","title":"Challenge 3: Device Tree Exploration","text":"<p>Goal: Understand how Device Tree describes hardware</p> <p>Tasks: 1. Read the Device Tree source: <code>arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts</code> 2. Find the serial console node 3. Find the Ethernet controller node 4. Identify mikroBUS connector pinout</p> <p>Hints:</p> <pre><code>less arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts\n# Search for: /serial@, /ethernet@, /chosen\n</code></pre>"},{"location":"labs/embedded-linux/lab04-kernel/#challenge-4-enable-kernel-debugging","title":"Challenge 4: Enable Kernel Debugging","text":"<p>Goal: Build kernel with debug symbols for GDB debugging</p> <p>Tasks: 1. Enable CONFIG_DEBUG_INFO 2. Enable CONFIG_GDB_SCRIPTS 3. Build and compare vmlinux size 4. Explore debug symbols with GDB (later lab)</p> <p>Hints:</p> <pre><code>make menuconfig\n# Kernel hacking \u2192 Compile-time checks and compiler options \u2192\n#   [*] Compile the kernel with debug info\n</code></pre> <p>Note: This makes the kernel MUCH larger (~500MB vmlinux)!</p>"},{"location":"labs/embedded-linux/lab04-kernel/#challenge-5-build-a-module","title":"Challenge 5: Build a Module","text":"<p>Goal: Compile a kernel driver as a loadable module</p> <p>Tasks: 1. Choose a simple driver (e.g., dummy network driver) 2. Configure it as <code>&lt;M&gt;</code> (module) instead of <code>&lt;*&gt;</code> (built-in) 3. Build just that module: <code>make M=drivers/net</code> 4. Find the .ko file</p> <p>Hints:</p> <pre><code>make menuconfig\n# Find a driver, set to &lt;M&gt;\nmake modules\nfind . -name \"*.ko\"\n</code></pre> <p>We'll learn to load modules in Lab 5!</p>"},{"location":"labs/embedded-linux/lab04-kernel/#summary","title":"Summary","text":"<p>In this lab, you:</p> <p>\u2705 Cloned the Linux kernel source tree (mainline + stable) \u2705 Checked out a stable LTS version (6.6.x) \u2705 Configured the kernel for ARM64 and BeaglePlay hardware \u2705 Cross-compiled the kernel and Device Tree Blobs \u2705 Set up TFTP server for network-based kernel loading \u2705 Configured U-Boot networking and boot arguments \u2705 Successfully booted a custom Linux kernel via TFTP \u2705 Created U-Boot boot scripts to streamline the process \u2705 Learned to troubleshoot kernel boot issues  </p>"},{"location":"labs/embedded-linux/lab04-kernel/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Kernel is highly configurable - Thousands of options affect functionality and size</li> <li>Device Tree is critical - Modern ARM systems require correct DTB for hardware detection</li> <li>Network boot is powerful - TFTP allows rapid testing without SD card writes</li> <li>Compression saves space - Image.gz is ~50% smaller than uncompressed Image</li> <li>Boot arguments matter - Console configuration must match hardware</li> </ol>"},{"location":"labs/embedded-linux/lab04-kernel/#whats-next","title":"What's Next?","text":"<p>In Lab 5, we'll: - Build a minimal root filesystem with BusyBox - Create init scripts and startup configuration - Mount the root filesystem over NFS - Get a working shell prompt - Build statically and dynamically linked programs</p> <p>The kernel is booting - now we need a userspace!</p> <p>Estimated completion time: 3-4 hours Difficulty: \u2b50\u2b50\u2b50 (Intermediate)</p> <p>Questions? Refer to: - Kernel Documentation - Device Tree Specification - Linux ARM64 Boot</p>"},{"location":"labs/embedded-linux/lab05-rootfs/","title":"Lab 5: Root Filesystem with BusyBox and NFS","text":""},{"location":"labs/embedded-linux/lab05-rootfs/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about root filesystems:</p> <p>\"A root filesystem is where all your files live. Think of it as the contents of your towel bag - essential utilities, helpful tools, and the occasional item whose purpose you've completely forgotten but you're certain you'll need eventually.\"</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will be able to:</p> <ul> <li>Understand Linux root filesystem structure and requirements</li> <li>Build BusyBox to provide essential Unix utilities</li> <li>Create a minimal root filesystem from scratch</li> <li>Set up NFS server for network-based root filesystem</li> <li>Configure kernel for NFS root boot</li> <li>Create init scripts and system startup configuration</li> <li>Mount virtual filesystems (proc, sysfs, devtmpfs)</li> <li>Switch between static and dynamic linking</li> <li>Set up a simple web server on the embedded system</li> </ul> <p>Estimated Time: 3-4 hours</p> <p>Prerequisites: - Completed Lab 1 (Custom Toolchain) - Completed Lab 2 (Hardware Discovery) - Completed Lab 3 (U-Boot Bootloader) - Completed Lab 4 (Linux Kernel) - Understanding of filesystem hierarchy - Basic shell scripting knowledge</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#introduction","title":"Introduction","text":""},{"location":"labs/embedded-linux/lab05-rootfs/#what-is-a-root-filesystem","title":"What is a Root Filesystem?","text":"<p>In Lab 4, our kernel successfully booted but panicked with:</p> <pre><code>Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n</code></pre> <p>This happened because the kernel needs a root filesystem - a directory tree containing: - <code>/sbin/init</code> - The first userspace program (PID 1) - Essential commands - ls, cp, cat, mount, etc. - Libraries - Shared libraries for dynamically linked programs - Configuration files - System startup scripts, network config, etc. - Device files - In <code>/dev</code> (or created dynamically)</p> <p>Without a root filesystem, the kernel has no userspace to run!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#why-busybox","title":"Why BusyBox?","text":"<p>BusyBox is the \"Swiss Army Knife of Embedded Linux\":</p> <p>Single Binary, Multiple Tools - One executable provides 300+ Unix utilities - <code>busybox ls</code>, <code>busybox cp</code>, <code>busybox mount</code>, etc. - Symbolic links allow <code>ls</code> \u2192 <code>busybox</code></p> <p>Tiny Size - Full-featured: ~900KB static binary - Minimal config: ~400KB - Compare to GNU coreutils: ~14MB!</p> <p>Perfect for Embedded - Low memory footprint - No dependencies when built static - Configurable features (like kernel menuconfig)</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#why-nfs-root","title":"Why NFS Root?","text":"<p>During development, NFS (Network File System) root is invaluable:</p> <p>Instant Updates - Edit files on PC, changes immediately visible on target - No reflashing, no SD card swapping - Edit-test cycle in seconds, not minutes</p> <p>Easy Debugging - Access target filesystem from PC - Copy files in/out effortlessly - Inspect logs, add debugging tools</p> <p>Flexibility - Try different configurations quickly - Revert changes instantly - Share root filesystem between multiple boards</p> <p>Production Note: NFS root is for development only. Production systems use local storage (eMMC, SD, flash).</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#what-well-build","title":"What We'll Build","text":"<pre><code>Development PC                    BeaglePlay\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 \u2502              \u2502              \u2502\n\u2502 /home/you/      \u2502              \u2502 Kernel boots \u2502\n\u2502  nfsroot/       \u2502              \u2502              \u2502\n\u2502   bin/          \u2502  NFS mount   \u2502 Mounts NFS   \u2502\n\u2502   sbin/     \u25c4\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 as /       \u2502\n\u2502   etc/          \u2502  Ethernet    \u2502              \u2502\n\u2502   lib/          \u2502              \u2502 Runs init    \u2502\n\u2502   ...           \u2502              \u2502              \u2502\n\u2502                 \u2502              \u2502 Shell prompt!\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The BeaglePlay will mount your PC's directory as its root filesystem over the network!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#workspace-setup","title":"Workspace Setup","text":"<p>Create root filesystem lab directory:</p> <pre><code>cd $HOME/embedded-labs\nmkdir -p tinysystem\ncd tinysystem\n</code></pre> <p>All root filesystem work happens here.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-1-understanding-nfs-root-requirements","title":"Part 1: Understanding NFS Root Requirements","text":""},{"location":"labs/embedded-linux/lab05-rootfs/#kernel-configuration-check","title":"Kernel Configuration Check","text":"<p>First, verify our kernel has NFS client support.</p> <p>Check if NFS is enabled:</p> <pre><code>cd $HOME/embedded-labs/kernel/linux\ngrep -E \"CONFIG_NFS_FS|CONFIG_ROOT_NFS|CONFIG_IP_PNP\" .config\n</code></pre> <p>Should show:</p> <pre><code>CONFIG_NFS_FS=y\nCONFIG_ROOT_NFS=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\n</code></pre> <p>If any are missing or set to <code>=m</code> (module), enable them:</p> <pre><code>make menuconfig\n</code></pre> <p>Navigate to:</p> <pre><code>File systems \u2192\n  Network File Systems \u2192\n    [*] NFS client support\n    [*] NFS client support for NFS version 3\n    [*] Root file system on NFS\n</code></pre> <p>And:</p> <pre><code>Networking support \u2192\n  Networking options \u2192\n    [*] IP: kernel level autoconfiguration\n</code></pre> <p>Also verify <code>devtmpfs</code> is configured to auto-mount:</p> <pre><code>grep CONFIG_DEVTMPFS .config\n</code></pre> <p>Should show:</p> <pre><code>CONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\n</code></pre> <p>If you made changes, rebuild the kernel:</p> <pre><code>make -j$(nproc)\ncp arch/arm64/boot/Image.gz /srv/tftp/\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#nfs-root-boot-flow","title":"NFS Root Boot Flow","text":"<p>Here's what happens when booting with NFS root:</p> <pre><code>1. U-Boot loads kernel via TFTP\n2. Kernel boots, initializes network\n3. Kernel contacts NFS server (IP from bootargs)\n4. Kernel mounts NFS export as root filesystem\n5. Kernel executes /sbin/init from NFS\n6. System boots normally!\n</code></pre> <p>The kernel needs these boot arguments:</p> <pre><code>root=/dev/nfs                    \u2190 Use NFS for root\nnfsroot=192.168.1.1:/path,opts   \u2190 NFS server and path\nip=192.168.1.100::::eth0         \u2190 Board IP config\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-2-building-busybox","title":"Part 2: Building BusyBox","text":""},{"location":"labs/embedded-linux/lab05-rootfs/#get-busybox-sources","title":"Get BusyBox Sources","text":"<p>Clone the stable BusyBox repository:</p> <pre><code>cd $HOME/embedded-labs/tinysystem\ngit clone https://git.busybox.net/busybox\ncd busybox/\ngit checkout 1_37_stable\n</code></pre> <p>Version 1.37 is the latest stable branch.</p> <p>Check the version:</p> <pre><code>head -5 Makefile | grep VERSION\n</code></pre> <p>Should show:</p> <pre><code>VERSION = 1\nPATCHLEVEL = 37\nSUBLEVEL = 0\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#explore-busybox","title":"Explore BusyBox","text":"<p>BusyBox uses Kconfig like the kernel. Check available commands:</p> <pre><code>ls -1 */Config.in | head -20\n</code></pre> <p>You'll see configuration files for: - <code>archival/Config.in</code> - tar, gzip, unzip - <code>console-tools/Config.in</code> - loadfont, setconsole - <code>coreutils/Config.in</code> - ls, cp, mv, cat, etc. - <code>editors/Config.in</code> - vi, sed, awk - <code>networking/Config.in</code> - wget, ifconfig, ping</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#load-base-configuration","title":"Load Base Configuration","text":"<p>Start with a default config optimized for embedded systems:</p> <pre><code>make defconfig\n</code></pre> <p>This creates <code>.config</code> with reasonable defaults.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#configure-busybox","title":"Configure BusyBox","text":"<p>Customize the configuration:</p> <pre><code>make menuconfig\n</code></pre> <p>Critical Changes:</p> <p>1. Enable Static Linking (for now)</p> <p>Navigate to:</p> <pre><code>Settings \u2192\n  [*] Build static binary (no shared libs)\n</code></pre> <p>Press Space to enable (asterisk should appear).</p> <p>Why static? Initially we have no C library in our root filesystem. Static linking embeds everything into the BusyBox binary. Later we'll switch to dynamic linking.</p> <p>2. Set Installation Prefix</p> <p>Navigate to:</p> <pre><code>Settings \u2192\n  Installation Options (\"make install\" behavior) \u2192\n    Destination path for 'make install'\n</code></pre> <p>Set this to:</p> <pre><code>/home/YOUR_USERNAME/embedded-labs/tinysystem/nfsroot\n</code></pre> <p>Replace YOUR_USERNAME! This is where BusyBox will be installed.</p> <p>3. Enable Useful Commands (optional but recommended)</p> <p>Navigate and enable these if not already enabled:</p> <pre><code>Archival Utilities \u2192\n  [*] tar\n  [*] gunzip\n  [*] gzip\n\nEditors \u2192\n  [*] vi\n\nNetworking Utilities \u2192\n  [*] ping\n  [*] wget\n  [*] httpd (we'll use this later!)\n</code></pre> <p>Save and exit menuconfig.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#cross-compile-busybox","title":"Cross-Compile BusyBox","text":"<p>Set up cross-compilation environment:</p> <pre><code>export ARCH=arm64\nexport CROSS_COMPILE=aarch64-beagleplay-linux-musl-\n</code></pre> <p>Build BusyBox:</p> <pre><code>make -j$(nproc)\n</code></pre> <p>Build time: ~1-2 minutes.</p> <p>Check the binary size:</p> <pre><code>ls -lh busybox\n</code></pre> <p>Should be around 900KB-1.2MB for a static build with most features enabled.</p> <p>Verify it's statically linked:</p> <pre><code>file busybox\n</code></pre> <p>Output:</p> <pre><code>busybox: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped\n</code></pre> <p>\"statically linked\" confirms it has no library dependencies.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#install-busybox","title":"Install BusyBox","text":"<p>Install to our NFS root directory:</p> <pre><code>make install\n</code></pre> <p>This creates the directory structure:</p> <pre><code>ls -la $HOME/embedded-labs/tinysystem/nfsroot/\n</code></pre> <p>You should see:</p> <pre><code>total 12\ndrwxr-xr-x  4 you you 4096 bin\ndrwxr-xr-x  2 you you 4096 sbin\nlrwxrwxrwx  1 you you   11 linuxrc -&gt; bin/busybox\n</code></pre> <p>Check what's in <code>bin/</code>:</p> <pre><code>ls $HOME/embedded-labs/tinysystem/nfsroot/bin/ | head -20\n</code></pre> <p>You'll see hundreds of symlinks:</p> <pre><code>ls -&gt; busybox\ncp -&gt; busybox\nmv -&gt; busybox\ncat -&gt; busybox\n...\n</code></pre> <p>Check the actual BusyBox binary:</p> <pre><code>ls -lh $HOME/embedded-labs/tinysystem/nfsroot/bin/busybox\n</code></pre> <p>Should show the same ~900KB size.</p> <p>How it works: - All commands are symlinks to <code>busybox</code> - BusyBox checks <code>argv[0]</code> (program name) - Executes appropriate functionality</p> <p>Test locally (won't fully work on x86, but demonstrates the concept):</p> <pre><code>$HOME/embedded-labs/tinysystem/nfsroot/bin/busybox echo \"Hello from BusyBox\"\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-3-creating-root-filesystem-structure","title":"Part 3: Creating Root Filesystem Structure","text":"<p>BusyBox installed <code>bin/</code> and <code>sbin/</code>, but we need more directories.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-essential-directories","title":"Create Essential Directories","text":"<pre><code>cd $HOME/embedded-labs/tinysystem/nfsroot\nmkdir -p dev etc lib proc sys tmp usr/lib usr/bin\n</code></pre> <p>Explanation of each directory:</p> Directory Purpose /dev Device files (will be auto-populated by devtmpfs) /etc Configuration files (init scripts, network config) /lib Shared libraries (for dynamic linking later) /proc Virtual filesystem for process information /sys Virtual filesystem for kernel/device information /tmp Temporary files /usr/lib Additional libraries /usr/bin User commands <p>Set proper permissions:</p> <pre><code>chmod 1777 tmp\n</code></pre> <p>The <code>1777</code> sets: - <code>1</code> - Sticky bit (only owner can delete files) - <code>777</code> - Read/write/execute for everyone</p> <p>Verify the structure:</p> <pre><code>tree -L 1 .\n</code></pre> <p>Should show:</p> <pre><code>.\n\u251c\u2500\u2500 bin -&gt; usr/bin\n\u251c\u2500\u2500 dev\n\u251c\u2500\u2500 etc\n\u251c\u2500\u2500 lib -&gt; usr/lib\n\u251c\u2500\u2500 linuxrc -&gt; bin/busybox\n\u251c\u2500\u2500 proc\n\u251c\u2500\u2500 sbin -&gt; usr/sbin\n\u251c\u2500\u2500 sys\n\u251c\u2500\u2500 tmp\n\u2514\u2500\u2500 usr\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-4-nfs-server-setup","title":"Part 4: NFS Server Setup","text":"<p>Now we'll export this directory via NFS so BeaglePlay can mount it.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#install-nfs-server","title":"Install NFS Server","text":"<pre><code>sudo apt install nfs-kernel-server\n</code></pre> <p>Verify it's running:</p> <pre><code>sudo systemctl status nfs-kernel-server\n</code></pre> <p>Should show \"active (running)\".</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#configure-nfs-export","title":"Configure NFS Export","text":"<p>Edit the NFS exports file:</p> <pre><code>sudo nano /etc/exports\n</code></pre> <p>Add this line (all on ONE line):</p> <pre><code>/home/YOUR_USERNAME/embedded-labs/tinysystem/nfsroot 192.168.1.100(rw,no_root_squash,no_subtree_check,sync)\n</code></pre> <p>Replace YOUR_USERNAME with your actual username!</p> <p>Parameters explained: - 192.168.1.100 - Only allow this IP (our BeaglePlay) - rw - Read-write access - no_root_squash - Don't map root to anonymous user (allows root to create files) - no_subtree_check - Faster, less secure (OK for development) - sync - Write changes immediately (safer but slower)</p> <p>Important (like knowing where your towel is): Make sure there's NO SPACE between the IP and the opening parenthesis! Otherwise default (read-only) options will be used.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#apply-nfs-configuration","title":"Apply NFS Configuration","text":"<p>Reload the NFS server configuration:</p> <pre><code>sudo exportfs -ra\n</code></pre> <p>The <code>-ra</code> means \"re-export all directories\".</p> <p>Verify the export:</p> <pre><code>sudo exportfs -v\n</code></pre> <p>Should show:</p> <pre><code>/home/you/embedded-labs/tinysystem/nfsroot\n        192.168.1.100(rw,wdelay,no_root_squash,no_subtree_check,sec=sys,...)\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#test-nfs-locally-optional","title":"Test NFS Locally (Optional)","text":"<p>Before testing on BeaglePlay, verify NFS works locally:</p> <pre><code>sudo mkdir -p /mnt/test\nsudo mount -t nfs localhost:/home/$USER/embedded-labs/tinysystem/nfsroot /mnt/test\nls /mnt/test\n</code></pre> <p>Should show <code>bin</code>, <code>sbin</code>, <code>etc</code>, etc.</p> <p>Unmount:</p> <pre><code>sudo umount /mnt/test\n</code></pre> <p>Success! NFS server is ready.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-5-booting-with-nfs-root","title":"Part 5: Booting with NFS Root","text":""},{"location":"labs/embedded-linux/lab05-rootfs/#configure-u-boot-for-nfs-root","title":"Configure U-Boot for NFS Root","text":"<p>Power on BeaglePlay, hold USR button, stop at U-Boot prompt.</p> <p>Set kernel boot arguments for NFS root:</p> <pre><code>=&gt; setenv bootargs console=ttyS2,115200n8 root=/dev/nfs ip=192.168.1.100::::eth0 nfsroot=192.168.1.1:/home/YOUR_USERNAME/embedded-labs/tinysystem/nfsroot,nfsvers=3,tcp rw\n=&gt; saveenv\n</code></pre> <p>Adjust these values: - YOUR_USERNAME - Your actual username - 192.168.1.100 - BeaglePlay IP - 192.168.1.1 - Your PC IP</p> <p>Bootargs breakdown:</p> Parameter Meaning <code>console=ttyS2,115200n8</code> Serial console configuration <code>root=/dev/nfs</code> Use NFS for root filesystem <code>ip=192.168.1.100::::eth0</code> Static IP for eth0 (format: ip:server:gateway:netmask:hostname:device) <code>nfsroot=192.168.1.1:/path,nfsvers=3,tcp</code> NFS server, path, version 3, TCP protocol <code>rw</code> Mount read-write"},{"location":"labs/embedded-linux/lab05-rootfs/#boot-the-system","title":"Boot the System","text":"<p>Load kernel and DTB:</p> <pre><code>=&gt; run netboot\n</code></pre> <p>(Or manually: <code>tftp 0x82000000 Image.gz; tftp 0x88000000 k3-am625-beagleplay.dtb; booti 0x82000000 - 0x88000000</code>)</p> <p>Watch the boot messages closely. You should see:</p> <pre><code>[    0.000000] Kernel command line: console=ttyS2,115200n8 root=/dev/nfs ip=192.168.1.100::::eth0 nfsroot=192.168.1.1:/home/you/embedded-labs/tinysystem/nfsroot,nfsvers=3,tcp rw\n...\n[    2.456789] am65-cpsw-nuss 8000000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off\n...\n[    3.123456] IP-Config: Complete:\n[    3.123500]      device=eth0, hwaddr=xx:xx:xx:xx:xx:xx, ipaddr=192.168.1.100, mask=255.255.255.0, gw=255.255.255.255\n...\n[    4.567890] VFS: Mounted root (nfs filesystem) on device 0:18.\n...\n[    5.234567] devtmpfs: mounted\n[    5.678901] Freeing unused kernel image (initmem) memory: 6464K\n[    5.678950] Run /sbin/init as init process\n</code></pre> <p>Expected failure:</p> <pre><code>[    6.123456] Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\n</code></pre> <p>This is progress! The kernel: \u2705 Configured networking \u2705 Mounted NFS root \u2705 Tried to run <code>/sbin/init</code> \u274c But <code>/sbin/init</code> doesn't exist yet!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-dev-directory","title":"Create /dev Directory","text":"<p>The panic might also mention:</p> <pre><code>[    5.123456] devtmpfs: error mounting -2\n</code></pre> <p>This is because <code>/dev</code> doesn't exist. Create it:</p> <pre><code>cd $HOME/embedded-labs/tinysystem/nfsroot\nmkdir -p dev\n</code></pre> <p>Reboot BeaglePlay. The devtmpfs error should be gone, but init panic remains.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-6-init-system-configuration","title":"Part 6: Init System Configuration","text":"<p>Linux needs <code>/sbin/init</code> - the first userspace program. BusyBox provides a simple init system.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-init-symlink","title":"Create Init Symlink","text":"<p>BusyBox init is just the busybox binary called as <code>init</code>:</p> <pre><code>cd $HOME/embedded-labs/tinysystem/nfsroot\nln -s ../bin/busybox sbin/init\n</code></pre> <p>Verify:</p> <pre><code>ls -l sbin/init\n</code></pre> <p>Should show:</p> <pre><code>lrwxrwxrwx 1 you you 14 sbin/init -&gt; ../bin/busybox\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-inittab-configuration","title":"Create inittab Configuration","text":"<p>BusyBox init reads <code>/etc/inittab</code> for configuration.</p> <p>Create it:</p> <pre><code>cat &gt; etc/inittab &lt;&lt; 'EOF'\n# /etc/inittab for BusyBox init\n\n# Mount proc and sysfs at boot\n::sysinit:/etc/init.d/rcS\n\n# Start a shell on console\n::askfirst:/bin/sh\n\n# Reboot on Ctrl-Alt-Del\n::ctrlaltdel:/sbin/reboot\n\n# Shutdown cleanly\n::shutdown:/bin/umount -a -r\nEOF\n</code></pre> <p>Inittab format: <code>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</code></p> <ul> <li>::sysinit: - Run <code>/etc/init.d/rcS</code> at system initialization</li> <li>::askfirst: - Start <code>/bin/sh</code>, ask for Enter first (prevents boot spam from covering prompt)</li> <li>::ctrlaltdel: - Handle Ctrl-Alt-Del</li> <li>::shutdown: - Unmount filesystems cleanly on shutdown</li> </ul>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-startup-script","title":"Create Startup Script","text":"<p>Create the <code>rcS</code> startup script referenced in inittab:</p> <pre><code>mkdir -p etc/init.d\ncat &gt; etc/init.d/rcS &lt;&lt; 'EOF'\n#!/bin/sh\n\n# BeaglePlay system startup script\n\necho \"Starting BeaglePlay system...\"\n\n# Mount proc filesystem (process information)\nmount -t proc proc /proc\n\n# Mount sysfs filesystem (kernel/device information)\nmount -t sysfs sysfs /sys\n\n# Mount devtmpfs if not already mounted by kernel\nmount -t devtmpfs devtmpfs /dev 2&gt;/dev/null || true\n\n# Set hostname\nhostname beagleplay\n\necho \"System initialization complete.\"\nEOF\n</code></pre> <p>Make it executable:</p> <pre><code>chmod +x etc/init.d/rcS\n</code></pre> <p>What this script does: 1. Mounts <code>/proc</code> - Virtual FS for process info (<code>ps</code> needs this) 2. Mounts <code>/sys</code> - Virtual FS for device info 3. Mounts <code>/dev</code> - Device files (may already be mounted by kernel) 4. Sets hostname</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-7-first-successful-boot","title":"Part 7: First Successful Boot!","text":"<p>Reboot BeaglePlay. You should now see:</p> <pre><code>[    5.678901] Run /sbin/init as init process\nStarting BeaglePlay system...\nSystem initialization complete.\n\nPlease press Enter to activate this console.\n</code></pre> <p>Press Enter and you'll get a shell prompt:</p> <pre><code>/ #\n</code></pre> <p>Success! You now have a working embedded Linux system!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#test-your-system","title":"Test Your System","text":"<p>Try some commands:</p> <pre><code>ls /\npwd\ncat /proc/cpuinfo\ncat /proc/meminfo\nfree\nps\nuname -a\n</code></pre> <p>Each command is actually BusyBox:</p> <pre><code>ls -l /bin/ls\n</code></pre> <p>Shows it's a symlink to busybox.</p> <p>Check mounted filesystems:</p> <pre><code>mount\n</code></pre> <p>Should show:</p> <pre><code>192.168.1.1:/home/you/.../nfsroot on / type nfs (rw,...)\nproc on /proc type proc (rw,...)\nsysfs on /sys type sysfs (rw,...)\ndevtmpfs on /dev type devtmpfs (rw,...)\n</code></pre> <p>Your root filesystem is mounted via NFS!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#test-nfs-live-updates","title":"Test NFS Live Updates","text":"<p>On your PC, create a test file:</p> <pre><code>echo \"Hello from NFS!\" &gt; $HOME/embedded-labs/tinysystem/nfsroot/tmp/test.txt\n</code></pre> <p>On BeaglePlay:</p> <pre><code>cat /tmp/test.txt\n</code></pre> <p>You immediately see the file! No reboot, no copying. This is the power of NFS root for development.</p> <p>Edit on PC, see changes instantly on target. Try it:</p> <pre><code># On PC\necho \"Updated content\" &gt; $HOME/embedded-labs/tinysystem/nfsroot/tmp/test.txt\n\n# On BeaglePlay\ncat /tmp/test.txt\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-8-virtual-filesystems-deep-dive","title":"Part 8: Virtual Filesystems Deep Dive","text":"<p>Let's understand what we mounted in <code>rcS</code>.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#proc-process-information","title":"/proc - Process Information","text":"<p>Explore <code>/proc</code>:</p> <pre><code>ls /proc\n</code></pre> <p>You'll see numbered directories (PIDs) and special files.</p> <p>See all processes:</p> <pre><code>cat /proc/1/cmdline &amp;&amp; echo\n</code></pre> <p>Shows PID 1's command line (<code>/sbin/init</code>).</p> <p>CPU information:</p> <pre><code>cat /proc/cpuinfo\n</code></pre> <p>Shows all 4 Cortex-A53 cores.</p> <p>Memory info:</p> <pre><code>cat /proc/meminfo\n</code></pre> <p>Shows total, free, cached memory.</p> <p>Current kernel command line:</p> <pre><code>cat /proc/cmdline\n</code></pre> <p>Shows the bootargs we set in U-Boot!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#sys-kernel-and-device-information","title":"/sys - Kernel and Device Information","text":"<p>Explore <code>/sys</code>:</p> <pre><code>ls /sys\n</code></pre> <p>Check network interface info:</p> <pre><code>cat /sys/class/net/eth0/address\ncat /sys/class/net/eth0/speed\ncat /sys/class/net/eth0/statistics/rx_bytes\n</code></pre> <p>Shows MAC address, link speed (1000 Mbps), received bytes.</p> <p>See all I2C buses:</p> <pre><code>ls /sys/bus/i2c/devices/\n</code></pre> <p>Check MMC devices:</p> <pre><code>ls /sys/class/mmc_host/\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#dev-device-files","title":"/dev - Device Files","text":"<p>List device files:</p> <pre><code>ls -l /dev/ | head -20\n</code></pre> <p>Key devices: - console - System console - ttyS0, ttyS1, ttyS2 - Serial ports (we're using ttyS2) - null - Null device (discards all writes) - zero - Provides infinite zeros - random, urandom - Random number generators - mmcblk0, mmcblk0p1, etc. - MMC/SD card and partitions</p> <p>These are created by <code>devtmpfs</code> - the kernel automatically populates <code>/dev</code>.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-9-switching-to-shared-libraries","title":"Part 9: Switching to Shared Libraries","text":"<p>Currently BusyBox is statically linked (~900KB). Let's rebuild with shared libraries to reduce size.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-a-test-program","title":"Create a Test Program","text":"<p>First, let's see how dynamic linking works.</p> <p>On your PC, create a test program:</p> <pre><code>cd $HOME/embedded-labs/tinysystem\ncat &gt; hello.c &lt;&lt; 'EOF'\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello from BeaglePlay with dynamic linking!\\n\");\n    return 0;\n}\nEOF\n</code></pre> <p>Compile it dynamically:</p> <pre><code>aarch64-beagleplay-linux-musl-gcc hello.c -o hello\n</code></pre> <p>Check what it needs:</p> <pre><code>file hello\n</code></pre> <p>Output:</p> <pre><code>hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-aarch64.so.1, not stripped\n</code></pre> <p>It needs <code>/lib/ld-musl-aarch64.so.1</code> - the dynamic linker!</p> <p>Copy to target:</p> <pre><code>cp hello nfsroot/usr/bin/\n</code></pre> <p>On BeaglePlay, try to run it:</p> <pre><code>/usr/bin/hello\n</code></pre> <p>Error:</p> <pre><code>/usr/bin/hello: No such file or directory\n</code></pre> <p>Misleading error! It's not the program that's missing - it's the dynamic linker!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#install-dynamic-linker","title":"Install Dynamic Linker","text":"<p>The dynamic linker is part of our toolchain. Find it:</p> <pre><code>find $HOME/x-tools/aarch64-beagleplay-linux-musl -name \"ld-musl-aarch64.so.1\"\n</code></pre> <p>Output:</p> <pre><code>/home/you/x-tools/aarch64-beagleplay-linux-musl/aarch64-beagleplay-linux-musl/lib/ld-musl-aarch64.so.1\n</code></pre> <p>Copy it to the target:</p> <pre><code>cp $HOME/x-tools/aarch64-beagleplay-linux-musl/aarch64-beagleplay-linux-musl/lib/ld-musl-aarch64.so.1 \\\n   nfsroot/lib/\n</code></pre> <p>With Musl, the dynamic linker contains the entire C library! So this one file is all we need.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#test-dynamic-program","title":"Test Dynamic Program","text":"<p>On BeaglePlay, try again:</p> <pre><code>/usr/bin/hello\n</code></pre> <p>Output:</p> <pre><code>Hello from BeaglePlay with dynamic linking!\n</code></pre> <p>Success! Dynamic linking works.</p> <p>If you get an error, wait 30-60 seconds (NFS cache delay) and try again.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#rebuild-busybox-dynamically","title":"Rebuild BusyBox Dynamically","text":"<p>Measure current BusyBox size:</p> <pre><code>ls -lh $HOME/embedded-labs/tinysystem/nfsroot/bin/busybox\n</code></pre> <p>Note the size (~900KB static).</p> <p>Reconfigure BusyBox:</p> <pre><code>cd $HOME/embedded-labs/tinysystem/busybox\nmake menuconfig\n</code></pre> <p>Navigate to:</p> <pre><code>Settings \u2192\n  [ ] Build static binary (no shared libs)\n</code></pre> <p>Press Space to disable static linking (no asterisk).</p> <p>Save and exit.</p> <p>Rebuild and reinstall:</p> <pre><code>make -j$(nproc)\nmake install\n</code></pre> <p>Check new size:</p> <pre><code>ls -lh $HOME/embedded-labs/tinysystem/nfsroot/bin/busybox\n</code></pre> <p>Should be ~600KB - about 30% smaller!</p> <p>Verify it's dynamic:</p> <pre><code>file $HOME/embedded-labs/tinysystem/nfsroot/bin/busybox\n</code></pre> <p>Should show \"dynamically linked\".</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#test-dynamic-busybox","title":"Test Dynamic BusyBox","text":"<p>Reboot BeaglePlay. Everything should still work:</p> <pre><code>ls /\nps\ncat /proc/cpuinfo\n</code></pre> <p>Now check what libraries are needed:</p> <pre><code>ldd /bin/busybox\n</code></pre> <p>BusyBox will show:</p> <pre><code>ldd: /bin/busybox: Not a valid dynamic program (error 1)\n</code></pre> <p>This error is because BusyBox's <code>ldd</code> implementation is basic. But the program works, so dynamic linking is functioning!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#part-10-simple-web-server","title":"Part 10: Simple Web Server","text":"<p>BusyBox includes a simple HTTP server. Let's set it up!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-web-content","title":"Create Web Content","text":"<p>Create web directory and a simple page:</p> <pre><code>cd $HOME/embedded-labs/tinysystem/nfsroot\nmkdir -p www\ncat &gt; www/index.html &lt;&lt; 'EOF'\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;BeaglePlay Web Server&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 800px;\n            margin: 50px auto;\n            padding: 20px;\n            background: #f5f5f5;\n        }\n        h1 {\n            color: #333;\n            border-bottom: 2px solid #0066cc;\n            padding-bottom: 10px;\n        }\n        .info {\n            background: white;\n            padding: 15px;\n            border-radius: 5px;\n            margin: 10px 0;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome to BeaglePlay!&lt;/h1&gt;\n    &lt;div class=\"info\"&gt;\n        &lt;h2&gt;System Information&lt;/h2&gt;\n        &lt;p&gt;&lt;strong&gt;Board:&lt;/strong&gt; BeagleBoard.org BeaglePlay&lt;/p&gt;\n        &lt;p&gt;&lt;strong&gt;SoC:&lt;/strong&gt; TI AM625 (ARM Cortex-A53)&lt;/p&gt;\n        &lt;p&gt;&lt;strong&gt;Root FS:&lt;/strong&gt; NFS from development PC&lt;/p&gt;\n        &lt;p&gt;&lt;strong&gt;Web Server:&lt;/strong&gt; BusyBox httpd&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=\"info\"&gt;\n        &lt;h2&gt;Lab Progress&lt;/h2&gt;\n        &lt;p&gt;\u2705 Custom toolchain built&lt;/p&gt;\n        &lt;p&gt;\u2705 U-Boot compiled and installed&lt;/p&gt;\n        &lt;p&gt;\u2705 Linux kernel cross-compiled&lt;/p&gt;\n        &lt;p&gt;\u2705 Root filesystem created&lt;/p&gt;\n        &lt;p&gt;\u2705 BusyBox configured and built&lt;/p&gt;\n        &lt;p&gt;\u2705 NFS root working&lt;/p&gt;\n        &lt;p&gt;\u2705 Web server running!&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nEOF\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#start-web-server","title":"Start Web Server","text":"<p>On BeaglePlay, start the HTTP server:</p> <pre><code>/usr/sbin/httpd -h /www -p 8080\n</code></pre> <p>Parameters: - -h /www - Document root - -p 8080 - Port 8080</p> <p>The server automatically backgrounds itself.</p> <p>Verify it's running:</p> <pre><code>ps | grep httpd\n</code></pre> <p>Should show the httpd process.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#test-web-server","title":"Test Web Server","text":"<p>From your development PC, open a browser and navigate to:</p> <pre><code>http://192.168.1.100:8080/\n</code></pre> <p>You should see your webpage!</p> <p>If you're using a proxy, make sure to bypass it for <code>192.168.1.100</code>: - Firefox: Preferences \u2192 Network Settings \u2192 No proxy for: <code>192.168.1.100</code> - Chrome: Use system proxy settings and configure in system network settings</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#add-to-startup-script","title":"Add to Startup Script","text":"<p>Make the web server start automatically:</p> <pre><code>cat &gt;&gt; $HOME/embedded-labs/tinysystem/nfsroot/etc/init.d/rcS &lt;&lt; 'EOF'\n\n# Start web server\n/usr/sbin/httpd -h /www -p 8080\necho \"Web server started on port 8080\"\nEOF\n</code></pre> <p>Reboot and verify the web server starts automatically.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#create-a-cgi-script-optional","title":"Create a CGI Script (Optional)","text":"<p>BusyBox httpd supports CGI scripts. Create a dynamic page:</p> <pre><code>mkdir -p nfsroot/www/cgi-bin\ncat &gt; nfsroot/www/cgi-bin/info.sh &lt;&lt; 'EOF'\n#!/bin/sh\n\necho \"Content-type: text/html\"\necho \"\"\necho \"&lt;html&gt;&lt;head&gt;&lt;title&gt;System Info&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"\necho \"&lt;h1&gt;BeaglePlay System Information&lt;/h1&gt;\"\necho \"&lt;pre&gt;\"\necho \"&lt;b&gt;Hostname:&lt;/b&gt; $(hostname)\"\necho \"&lt;b&gt;Uptime:&lt;/b&gt; $(uptime)\"\necho \"&lt;b&gt;Memory:&lt;/b&gt;\"\nfree\necho \"\"\necho \"&lt;b&gt;Processes:&lt;/b&gt;\"\nps\necho \"&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\"\nEOF\n\nchmod +x nfsroot/www/cgi-bin/info.sh\n</code></pre> <p>Browse to: <code>http://192.168.1.100:8080/cgi-bin/info.sh</code></p> <p>You'll see live system information!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#troubleshooting","title":"Troubleshooting","text":"<p>Marvin's note: \"I've calculated your chances of success. You won't like them. But here's how to improve the odds anyway.\"</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#nfs-mount-fails","title":"NFS Mount Fails","text":"<p>Symptom: Kernel panics with \"VFS: Unable to mount root (nfs)\"</p> <p>Causes: 1. NFS server not running 2. Wrong IP addresses in bootargs 3. Export path incorrect 4. Firewall blocking NFS</p> <p>Solutions:</p> <p>Check NFS server status:</p> <pre><code>sudo systemctl status nfs-kernel-server\n</code></pre> <p>Verify export:</p> <pre><code>sudo exportfs -v\n</code></pre> <p>Check firewall (Ubuntu):</p> <pre><code>sudo ufw allow from 192.168.1.100\n</code></pre> <p>Test NFS mount locally:</p> <pre><code>sudo mount -t nfs localhost:/home/$USER/embedded-labs/tinysystem/nfsroot /mnt\nls /mnt\nsudo umount /mnt\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#init-not-found","title":"Init Not Found","text":"<p>Symptom: \"No working init found\"</p> <p>Cause: <code>/sbin/init</code> doesn't exist or isn't executable</p> <p>Solution:</p> <pre><code>cd $HOME/embedded-labs/tinysystem/nfsroot\nls -l sbin/init\n# Should be a symlink to ../bin/busybox\n\n# If missing:\nln -s ../bin/busybox sbin/init\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#shell-prompt-shows-cant-access-tty-job-control-turned-off","title":"Shell Prompt Shows \"can't access tty; job control turned off\"","text":"<p>Cause: Wrong console device in inittab</p> <p>Solution:</p> <p>Edit <code>etc/inittab</code>, change:</p> <pre><code>::askfirst:/bin/sh\n</code></pre> <p>To:</p> <pre><code>ttyS2::askfirst:/bin/sh\n</code></pre> <p>This specifies the exact console device.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#commands-not-working","title":"Commands Not Working","text":"<p>Symptom: \"sh: command not found\" for basic commands</p> <p>Cause: BusyBox not installed or PATH wrong</p> <p>Solution:</p> <p>Check BusyBox installation:</p> <pre><code>ls $HOME/embedded-labs/tinysystem/nfsroot/bin/busybox\n</code></pre> <p>On target, check PATH:</p> <pre><code>echo $PATH\n</code></pre> <p>Should include <code>/bin</code> and <code>/sbin</code>.</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#web-server-wont-start","title":"Web Server Won't Start","text":"<p>Symptom: httpd exits immediately</p> <p>Cause: Port already in use or wrong path</p> <p>Solution:</p> <p>Check if port 8080 is available:</p> <pre><code>netstat -tuln | grep 8080\n</code></pre> <p>Try a different port:</p> <pre><code>/usr/sbin/httpd -h /www -p 8000\n</code></pre> <p>Verify /www exists:</p> <pre><code>ls -ld /www\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#nfs-writes-fail","title":"NFS Writes Fail","text":"<p>Symptom: \"Read-only file system\" when creating files</p> <p>Cause: <code>no_root_squash</code> not set in exports</p> <p>Solution:</p> <p>Edit <code>/etc/exports</code>, ensure:</p> <pre><code>/path/to/nfsroot 192.168.1.100(rw,no_root_squash,no_subtree_check)\n</code></pre> <p>No space between IP and <code>(</code> !</p> <p>Reload exports:</p> <pre><code>sudo exportfs -ra\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#verification-checklist","title":"Verification Checklist","text":"<p>Ford Prefect says: \"Always verify your work. It's the difference between a working system and a very expensive paperweight.\"</p> <p>Before moving to the next lab, ensure:</p> <ul> <li>[ ] BusyBox compiled and installed with all essential commands</li> <li>[ ] Root filesystem directory structure created</li> <li>[ ] NFS server configured and exporting nfsroot directory</li> <li>[ ] Kernel configured with NFS client and root support</li> <li>[ ] BeaglePlay boots with NFS root successfully</li> <li>[ ] Shell prompt accessible on serial console</li> <li>[ ] /proc, /sys, and /dev mounted correctly</li> <li>[ ] <code>ps</code>, <code>free</code>, <code>ls</code> commands working</li> <li>[ ] Files created on PC instantly visible on target (NFS live update)</li> <li>[ ] Dynamic linking working with shared libraries</li> <li>[ ] BusyBox rebuilt dynamically and system still boots</li> <li>[ ] Web server running and accessible from PC browser</li> <li>[ ] System startup script (rcS) executes on boot</li> </ul>"},{"location":"labs/embedded-linux/lab05-rootfs/#going-further-optional-challenges","title":"Going Further (Optional Challenges)","text":""},{"location":"labs/embedded-linux/lab05-rootfs/#challenge-1-initramfs-boot","title":"Challenge 1: Initramfs Boot","text":"<p>Goal: Boot from initramfs instead of NFS</p> <p>Tasks: 1. Configure kernel with <code>CONFIG_INITRAMFS_SOURCE</code> pointing to nfsroot 2. Create <code>/init</code> symlink to <code>/sbin/init</code> 3. Rebuild kernel - initramfs will be embedded 4. Boot without NFS (bootargs without nfsroot)</p> <p>Hints:</p> <pre><code>cd $HOME/embedded-labs/tinysystem/nfsroot\nln -s sbin/init init\n\ncd $HOME/embedded-labs/kernel/linux\nmake menuconfig\n# General setup \u2192 Initramfs source file(s)\n# Enter: /home/you/embedded-labs/tinysystem/nfsroot\n</code></pre> <p>The Guide notes: Switch back to NFS root after testing - it's more convenient for development!</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#challenge-2-custom-init-system","title":"Challenge 2: Custom Init System","text":"<p>Goal: Write your own init replacement</p> <p>Tasks: 1. Create a C program that mounts filesystems 2. Spawns a shell 3. Handles reaping zombie processes (wait()) 4. Use it instead of BusyBox init</p> <p>Hints:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;sys/mount.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(void) {\n    mount(\"proc\", \"/proc\", \"proc\", 0, NULL);\n    mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);\n    // ... spawn shell with fork()/execve()\n    // ... wait() in loop for child processes\n}\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#challenge-3-network-configuration-script","title":"Challenge 3: Network Configuration Script","text":"<p>Goal: Set up networking from init script</p> <p>Tasks: 1. Create <code>/etc/network/interfaces</code> config 2. Write script to parse it and configure interfaces 3. Add to rcS 4. Support static IP and DHCP</p> <p>Hints:</p> <p>BusyBox includes <code>ifconfig</code>, <code>route</code>, and <code>udhcpc</code> (DHCP client).</p>"},{"location":"labs/embedded-linux/lab05-rootfs/#challenge-4-persistent-storage","title":"Challenge 4: Persistent Storage","text":"<p>Goal: Mount SD card partition for persistent storage</p> <p>Tasks: 1. Create mount point <code>/mnt/data</code> 2. Add to rcS: <code>mount /dev/mmcblk0p3 /mnt/data</code> 3. Create files that survive reboot 4. Handle mount failure gracefully</p> <p>Hints:</p> <p>Check available partitions: <code>cat /proc/partitions</code></p>"},{"location":"labs/embedded-linux/lab05-rootfs/#challenge-5-system-logging","title":"Challenge 5: System Logging","text":"<p>Goal: Implement syslog for system logging</p> <p>Tasks: 1. Enable <code>CONFIG_SYSLOGD</code> in BusyBox 2. Configure syslogd in rcS 3. Make kernel log to /var/log/messages 4. Add log rotation</p> <p>Hints:</p> <pre><code>mkdir -p /var/log\nsyslogd -O /var/log/messages\n</code></pre>"},{"location":"labs/embedded-linux/lab05-rootfs/#summary","title":"Summary","text":"<p>In this lab, you:</p> <p>\u2705 Built BusyBox to provide essential Unix utilities \u2705 Created a minimal root filesystem from scratch \u2705 Set up NFS server for network-based development \u2705 Configured kernel to boot with NFS root \u2705 Created init system with startup scripts \u2705 Mounted virtual filesystems (proc, sysfs, devtmpfs) \u2705 Understood the difference between static and dynamic linking \u2705 Switched BusyBox from static to dynamic to reduce size \u2705 Set up a simple web server on the embedded system \u2705 Experienced the power of NFS root for rapid development  </p>"},{"location":"labs/embedded-linux/lab05-rootfs/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Root filesystem is essential - Kernel is useless without userspace</li> <li>BusyBox is incredibly powerful - 300+ utilities in one small binary</li> <li>NFS root accelerates development - Edit on PC, test instantly on target</li> <li>Init system can be simple - Just mount filesystems and spawn shell</li> <li>Virtual filesystems provide kernel info - /proc and /sys are invaluable</li> <li>Dynamic linking saves space - But requires runtime libraries</li> </ol>"},{"location":"labs/embedded-linux/lab05-rootfs/#whats-next","title":"What's Next?","text":"<p>In Lab 6, we'll: - Explore hardware devices in <code>/dev</code> and <code>/sys</code> - Control GPIOs and LEDs from userspace - Use I2C to communicate with sensors - Add a Nunchuk joystick as an input device - Compile and load kernel modules - Modify Device Tree to enable hardware</p> <p>The system is running - now let's make it interact with hardware!</p> <p>Estimated completion time: 3-4 hours Difficulty: \u2b50\u2b50\u2b50 (Intermediate)</p> <p>Questions? Refer to: - BusyBox Documentation - NFS Documentation - Linux Filesystem Hierarchy</p>"},{"location":"labs/embedded-linux/lab06-hardware/","title":"Lab 6: Hardware Device Access and Driver Development","text":""},{"location":"labs/embedded-linux/lab06-hardware/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about hardware discovery:</p> <p>\"Hardware discovery is the art of asking your embedded board what it is and what it can do, in the hope that it will answer in a language you understand. This is somewhat more successful than asking a Vogon for directions, though both may require substantial interpretation.\"</p>"},{"location":"labs/embedded-linux/lab06-hardware/#objectives","title":"Objectives","text":"<p>Master hardware device access patterns on embedded Linux systems:</p> <ul> <li>Explore Linux device abstractions (<code>/dev</code>, <code>/sys</code>)</li> <li>Control GPIOs using the legacy sysfs interface</li> <li>Manage LEDs through the LED subsystem</li> <li>Enable and probe I2C buses</li> <li>Compile and install in-tree kernel modules</li> <li>Develop and deploy out-of-tree kernel modules</li> <li>Declare devices in the Device Tree</li> <li>Work with USB devices and the Linux device driver model</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 5 (Root Filesystem)</li> <li>Working NFS root filesystem</li> <li>Serial console access to BeaglePlay</li> <li>Basic understanding of Linux kernel modules</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#lab-duration","title":"Lab Duration","text":"<p>Approximately 4-5 hours</p>"},{"location":"labs/embedded-linux/lab06-hardware/#system-architecture","title":"System Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      User Space                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 i2cdetect\u2502  \u2502  lsusb   \u2502  \u2502  lsmod   \u2502  \u2502 modprobe \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       \u2502    Kernel Space            \u2502             \u2502          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  sysfs   \u2502  \u2502 USB Core \u2502  \u2502  Module  \u2502  \u2502 I2C Core \u2502 \u2502\n\u2502  \u2502/sys/class\u2502  \u2502 /sys/bus \u2502  \u2502 Loader   \u2502  \u2502/dev/i2c-*\u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502            Device Driver Subsystems                   \u2502 \u2502\n\u2502  \u2502  GPIO \u2502 LED \u2502 I2C \u2502 USB \u2502 Sound \u2502 Input \u2502 MMC       \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2518 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524\n\u2502  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2510 \u2502\n\u2502  \u2502           Hardware (BeaglePlay AM62x)                \u2502 \u2502\n\u2502  \u2502  GPIOs \u2502 LEDs \u2502 I2C \u2502 USB \u2502 Pins \u2502 MMC \u2502 Audio      \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#environment-setup","title":"Environment Setup","text":""},{"location":"labs/embedded-linux/lab06-hardware/#working-directory","title":"Working Directory","text":"<pre><code># Create dedicated hardware lab directory\ncd $HOME/embedded-linux-beagleplay-labs\nmkdir -p hardware/nunchuk-driver\ncd hardware\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#verify-nfs-root-filesystem","title":"Verify NFS Root Filesystem","text":"<p>We'll continue using the NFS root filesystem from Lab 5:</p> <pre><code># Verify NFS export\ncat /etc/exports | grep tinysystem\n\n# Expected output:\n# /home/&lt;user&gt;/embedded-linux-beagleplay-labs/tinysystem/nfsroot *(rw,no_root_squash,no_subtree_check)\n\n# Restart NFS server if needed\nsudo systemctl restart nfs-kernel-server\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#boot-the-system","title":"Boot the System","text":"<p>Power on your BeaglePlay and verify the NFS boot:</p> <pre><code># On BeaglePlay serial console, verify the mount\nmount | grep nfs\n\n# Expected output showing NFS root:\n# 192.168.0.1:/home/&lt;user&gt;/embedded-linux-beagleplay-labs/tinysystem/nfsroot on / type nfs ...\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#section-1-exploring-the-linux-device-model","title":"Section 1: Exploring the Linux Device Model","text":""},{"location":"labs/embedded-linux/lab06-hardware/#understanding-dev","title":"Understanding /dev","text":"<p>The <code>/dev</code> directory contains device files - special files that represent hardware devices.</p> <p>On the BeaglePlay:</p> <pre><code># List all device files\nls -l /dev/\n\n# Terminal devices (text input/output)\nls -l /dev/tty*\n\n# Console device (kernel command line console= parameter)\nls -l /dev/console\n\n# Serial ports\nls -l /dev/ttyS*\n\n# MMC devices and partitions\nls -l /dev/mmcblk*\n</code></pre> <p>Device File Anatomy:</p> <pre><code># Example: character device\ncrw-rw---- 1 root tty 5, 1 Jan  1 00:00 /dev/console\n# c = character device\n# 5 = major number (device driver)\n# 1 = minor number (specific device instance)\n\n# Example: block device\nbrw-rw---- 1 root disk 179, 0 Jan  1 00:00 /dev/mmcblk0\n# b = block device\n# 179 = major number (MMC/SD driver)\n# 0 = minor number (first MMC device)\n</code></pre> <p>Challenge: Find the device file for the serial console you're using.</p> Solution <pre><code># Check kernel boot messages for console device\ndmesg | grep console\n\n# Usually /dev/ttyS2 on BeaglePlay\nls -l /dev/ttyS2\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#exploring-sysfs-sys","title":"Exploring sysfs (/sys)","text":"<p>Sysfs provides a structured view of the kernel's device model.</p> <p>Device Classification:</p> <pre><code># Explore devices by class (subsystem)\nls /sys/class/\n\n# Network devices\nls -l /sys/class/net/\n\n# Examine network interface properties\ncd /sys/class/net/eth0/  # or your network interface name\n\n# Link speed (Mbps)\ncat speed\n\n# MAC address\ncat address\n\n# RX statistics\ncat statistics/rx_bytes\ncat statistics/rx_packets\n\n# TX statistics\ncat statistics/tx_bytes\ncat statistics/tx_packets\n</code></pre> <p>Bus Exploration:</p> <pre><code># All buses in the system\nls /sys/bus/\n\n# MMC bus devices\nls /sys/bus/mmc/devices/\n\n# Explore first MMC device\ncd /sys/bus/mmc/devices/mmc0:0001/\n\n# Device serial number\ncat serial\n\n# Product name\ncat name\n\n# Manufacturing date\ncat date\n\n# Preferred erase size (for partition alignment)\ncat preferred_erase_size\n</code></pre> <p>Platform Devices:</p> <pre><code># Platform bus (SoC-integrated devices)\nls /sys/bus/platform/devices/\n\n# I2C controllers\nls /sys/bus/platform/devices/ | grep i2c\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Successfully explored <code>/dev</code> and identified device types</li> <li>[ ] Found serial console device file</li> <li>[ ] Examined network interface properties in <code>/sys/class/net/</code></li> <li>[ ] Explored MMC device information</li> <li>[ ] Located platform devices for I2C controllers</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-2-gpio-control-with-legacy-sysfs","title":"Section 2: GPIO Control with Legacy Sysfs","text":""},{"location":"labs/embedded-linux/lab06-hardware/#enable-gpio-sysfs-interface","title":"Enable GPIO Sysfs Interface","text":"<p>The legacy GPIO sysfs interface requires <code>CONFIG_GPIO_SYSFS</code>.</p> <p>Kernel Configuration:</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/kernel/linux\n\n# Enable legacy GPIO interface\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- menuconfig\n\n# Navigate to:\n# General setup\n#   --&gt; Configure standard kernel features (expert users)\n#       [*] Configure standard kernel features (expert users)  # Enable CONFIG_EXPERT\n\n# Device Drivers\n#   --&gt; GPIO Support\n#       [*] /sys/class/gpio/... (sysfs interface) (DEPRECATED)  # Enable CONFIG_GPIO_SYSFS\n\n# Also enable Debugfs:\n# Kernel hacking\n#   --&gt; Generic Kernel Debugging Instruments\n#       [*] Debug Filesystem\n#       [*] Debugfs default access (Access normal)\n\n# Save and exit\n</code></pre> <p>Compile and Install:</p> <pre><code># Build kernel image\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- Image.gz -j$(nproc)\n\n# Copy to TFTP directory\ncp arch/arm64/boot/Image.gz /srv/tftp/\n\n# Reboot BeaglePlay and verify new kernel\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#mount-debugfs","title":"Mount Debugfs","text":"<pre><code># On BeaglePlay\nmount -t debugfs debugfs /sys/kernel/debug\n\n# View GPIO information\ncat /sys/kernel/debug/gpio\n</code></pre> <p>Expected Output:</p> <pre><code>gpiochip0: GPIOs 0-87, parent: platform/600000.gpio, 600000.gpio:\n gpio-42  (                    |reset               ) out lo ACTIVE LOW\n gpio-50  (                    |cd                  ) in  hi ACTIVE LOW\n\ngpiochip1: GPIOs 88-175, parent: platform/601000.gpio, 601000.gpio:\n\ngpiochip2: GPIOs 512-639, parent: platform/4201000.gpio, 4201000.gpio:\n\ngpiochip3: GPIOs 640-727, parent: platform/42110000.gpio, 42110000.gpio:\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#beagleplay-mikrobus-gpio-selection","title":"BeaglePlay mikroBUS GPIO Selection","text":"<p>The BeaglePlay mikroBUS connector provides several GPIO pins.</p> <p>MikroBUS Pinout (Connector J5):</p> <pre><code>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nPWM  \u2502 1         2 \u2502 AN\nINT  \u2502 3         4 \u2502 RST\nCS   \u2502 5         6 \u2502 SCK\nMOSI \u2502 7         8 \u2502 MISO\n3.3V \u2502 9        10 \u2502 GND\n5V   \u250211        12 \u2502 GND\nSDA  \u250213        14 \u2502 SCL\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Pin Mapping to SoC:</p> <p>According to BeaglePlay schematics: - INT pin \u2192 GPIO1_9 (SoC pin) - PWM pin \u2192 GPIO0_36 (SoC pin) - AN pin \u2192 GPIO0_35 (SoC pin) - RST pin \u2192 GPIO1_14 (SoC pin)</p> <p>Find INT Pin Linux GPIO Number:</p> <pre><code># Check debugfs GPIO listing\ncat /sys/kernel/debug/gpio | grep MIKROBUS\n\n# Look for GPIO1_9, also called gpio-640\n# Output should show:\n# gpio-640 (MIKROBUS_GPIO1_9  |                    ) in  hi\n</code></pre> <p>The INT pin is GPIO 640 (gpio-640 in Linux).</p>"},{"location":"labs/embedded-linux/lab06-hardware/#control-gpio-via-sysfs","title":"Control GPIO via Sysfs","text":"<p>Test Setup - Hardware Wiring:</p> <p>Use a male-to-male jumper wire: 1. Connect one end to INT pin (pin 3) on mikroBUS connector 2. Connect other end to GND pin (pin 10) on mikroBUS connector</p> <p>Export GPIO:</p> <pre><code># Navigate to GPIO sysfs interface\ncd /sys/class/gpio\n\n# Export GPIO 640 (INT pin)\necho 640 &gt; export\n\n# Verify new GPIO directory created\nls -l gpio640/\n</code></pre> <p>Configure as Input:</p> <pre><code># Set direction to input\necho in &gt; gpio640/direction\n\n# Read current value (should be 0, connected to GND)\ncat gpio640/value\n# Output: 0\n</code></pre> <p>Test with 3.3V:</p> <pre><code># Disconnect the wire from GND\n# Connect it to 3.3V pin (pin 9) instead\n\n# Read value again (should be 1)\ncat gpio640/value\n# Output: 1\n</code></pre> <p>Configure as Output:</p> <pre><code># Set direction to output\necho out &gt; gpio640/direction\n\n# Set high (3.3V)\necho 1 &gt; gpio640/value\n\n# You can measure 3.3V on the INT pin with a multimeter\n\n# Set low (0V)\necho 0 &gt; gpio640/value\n\n# Disconnect wire from 3.3V before continuing\n</code></pre> <p>Check GPIO Status:</p> <pre><code># View GPIO in debugfs (shows usage and direction)\ncat /sys/kernel/debug/gpio | grep 640\n\n# Expected output:\n# gpio-640 (MIKROBUS_GPIO1_9  |sysfs              ) out lo\n</code></pre> <p>Unexport GPIO:</p> <pre><code># Release the GPIO when done\ncd /sys/class/gpio\necho 640 &gt; unexport\n\n# Verify directory removed\nls gpio640/\n# Should show: No such file or directory\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Kernel compiled with <code>CONFIG_GPIO_SYSFS</code> enabled</li> <li>[ ] Debugfs mounted and GPIO information visible</li> <li>[ ] GPIO 640 (INT pin) successfully exported</li> <li>[ ] Read LOW value (0) when connected to GND</li> <li>[ ] Read HIGH value (1) when connected to 3.3V</li> <li>[ ] Successfully configured GPIO as output</li> <li>[ ] Unexported GPIO after testing</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-3-led-control-via-sysfs","title":"Section 3: LED Control via Sysfs","text":""},{"location":"labs/embedded-linux/lab06-hardware/#kernel-configuration","title":"Kernel Configuration","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/kernel/linux\n\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- menuconfig\n\n# Enable:\n# Device Drivers\n#   --&gt; LED Support\n#       &lt;*&gt; LED Class Support                      # CONFIG_LEDS_CLASS\n#       &lt;*&gt; LED Support for GPIO connected LEDs    # CONFIG_LEDS_GPIO\n#       &lt;*&gt; LED Trigger support\n#           &lt;*&gt; LED Timer Trigger                  # CONFIG_LEDS_TRIGGER_TIMER\n#           &lt;*&gt; LED Heartbeat Trigger              # CONFIG_LEDS_TRIGGER_HEARTBEAT\n\n# Save and rebuild kernel\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- Image.gz -j$(nproc)\ncp arch/arm64/boot/Image.gz /srv/tftp/\n</code></pre> <p>Reboot the BeaglePlay with the updated kernel.</p>"},{"location":"labs/embedded-linux/lab06-hardware/#explore-led-devices","title":"Explore LED Devices","text":"<pre><code># On BeaglePlay\ncd /sys/class/leds\nls -l\n\n# You should see several LEDs, including:\n# beagleplay:green:usr0\n# beagleplay:green:usr1\n# beagleplay:green:usr2\n# beagleplay:green:usr3\n# beagleplay:green:usr4\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#control-led-manually","title":"Control LED Manually","text":"<pre><code># Enter LED directory (choose any user LED)\ncd /sys/class/leds/beagleplay:green:usr0\n\n# Check current trigger\ncat trigger\n# Output shows available triggers and current (in brackets):\n# none usb-gadget usb-host rc-feedback kbd-scrolllock ...\n# [heartbeat] timer ... default-on\n\n# Disable all triggers\necho none &gt; trigger\n\n# Manual control - turn ON\necho 1 &gt; brightness\n\n# Wait a moment, then turn OFF\necho 0 &gt; brightness\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#use-timer-trigger","title":"Use Timer Trigger","text":"<pre><code># Enable timer trigger\necho timer &gt; trigger\n\n# Set ON time (milliseconds)\necho 100 &gt; delay_on\n\n# Set OFF time (milliseconds)\necho 900 &gt; delay_off\n\n# LED should now blink: 100ms ON, 900ms OFF\n</code></pre> <p>Experiment with Different Patterns:</p> <pre><code># Fast blink\necho 50 &gt; delay_on\necho 50 &gt; delay_off\n\n# Slow pulse\necho 500 &gt; delay_on\necho 1500 &gt; delay_off\n\n# Short flash\necho 20 &gt; delay_on\necho 2000 &gt; delay_off\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#restore-heartbeat","title":"Restore Heartbeat","text":"<pre><code># Return to heartbeat trigger\necho heartbeat &gt; trigger\n\n# LED will pulse with a heartbeat pattern\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] LED class and GPIO LED support compiled into kernel</li> <li>[ ] LEDs visible in <code>/sys/class/leds/</code></li> <li>[ ] Successfully controlled LED brightness manually</li> <li>[ ] Timer trigger functional with custom delays</li> <li>[ ] Heartbeat trigger operational</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-4-i2c-bus-management","title":"Section 4: I2C Bus Management","text":""},{"location":"labs/embedded-linux/lab06-hardware/#list-i2c-buses","title":"List I2C Buses","text":"<pre><code># On BeaglePlay\ni2cdetect -l\n\n# Expected output:\n# i2c-0   i2c       OMAP I2C adapter              I2C adapter\n# i2c-1   i2c       OMAP I2C adapter              I2C adapter\n# i2c-2   i2c       OMAP I2C adapter              I2C adapter\n# i2c-3   i2c       OMAP I2C adapter              I2C adapter\n# i2c-5   i2c       OMAP I2C adapter              I2C adapter\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#map-i2c-linux-numbers-to-hardware","title":"Map I2C Linux Numbers to Hardware","text":"<pre><code># Check I2C controller base addresses\nls -l /sys/bus/i2c/devices/i2c-*\n\n# Output:\n# ... -&gt; .../20000000.i2c/i2c-0    # I2C0 controller\n# ... -&gt; .../20010000.i2c/i2c-1    # I2C1 controller\n# ... -&gt; .../20020000.i2c/i2c-2    # I2C2 controller\n# ... -&gt; .../20030000.i2c/i2c-3    # I2C3 controller\n# ... -&gt; .../4900000.i2c/i2c-5     # MCU_I2C0 controller\n</code></pre> <p>AM62x I2C Controller Addresses (from TRM):</p> Linux Name Hardware Name Base Address BeaglePlay Connector i2c-0 I2C0 0x2000_0000 Internal only i2c-1 I2C1 0x2001_0000 Grove connector i2c-2 I2C2 0x2002_0000 Qwiic connector i2c-3 I2C3 0x2003_0000 mikroBUS connector i2c-5 MCU_I2C0 0x0490_0000 Internal only <p>We'll use i2c-3 (mikroBUS connector) for the Nunchuk.</p>"},{"location":"labs/embedded-linux/lab06-hardware/#probe-i2c-buses","title":"Probe I2C Buses","text":"<pre><code># Probe internal I2C bus (i2c-0)\ni2cdetect -r 0\n\n# WARNING will appear - this is normal\n# Output shows detected devices:\n#      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n# 00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n# 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 30: UU -- -- -- -- -- -- -- -- -- -- -- -- -- -- --    # 0x30: kernel driver active\n# 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 50: 50 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --    # 0x50: EEPROM\n# 60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --    # 0x68: RTC or sensor\n# 70: -- -- -- -- -- -- -- --\n\n# Probe mikroBUS I2C bus (i2c-3) - should be empty\ni2cdetect -r 3\n# All -- (no devices detected yet)\n</code></pre> <p>UU vs Address: - <code>UU</code>: Device detected AND bound to a kernel driver - <code>50</code>, <code>68</code>: Device detected but no driver bound</p> <p>Verification Checklist:</p> <ul> <li>[ ] All I2C buses listed with <code>i2cdetect -l</code></li> <li>[ ] Mapped Linux I2C numbers to hardware controllers</li> <li>[ ] Successfully probed i2c-0 and observed internal devices</li> <li>[ ] Probed i2c-3 (mikroBUS) and confirmed no devices yet</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-5-usb-device-detection","title":"Section 5: USB Device Detection","text":""},{"location":"labs/embedded-linux/lab06-hardware/#check-usb-subsystem","title":"Check USB Subsystem","text":"<pre><code># On BeaglePlay (before plugging USB audio)\nlsusb\n\n# Expected output (USB host controller only):\n# Bus 001 Device 001: ID 1d6b:0002\n\n# View USB devices in sysfs\nls -l /sys/bus/usb/devices/\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#plug-usb-audio-headset","title":"Plug USB Audio Headset","text":"<p>Connect the USB audio headset to BeaglePlay's USB host port.</p> <p>Monitor Kernel Messages:</p> <pre><code># Watch kernel log in real-time\ndmesg -w\n\n# You should see messages like:\n# usb 1-1: new full-speed USB device number 2 using xhci-hcd\n# usb 1-1: New USB device found, idVendor=1b3f, idProduct=2008\n# usb 1-1: Product: USB Audio Device\n# usb 1-1: Manufacturer: GeneralPlus\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#explore-usb-device-in-sysfs","title":"Explore USB Device in Sysfs","text":"<pre><code># List USB devices again\nlsusb\n# Bus 001 Device 001: ID 1d6b:0002\n# Bus 001 Device 002: ID 1b3f:2008    # &lt;-- New device!\n\n# Navigate to device sysfs directory\n# Device topology: Bus 1, Port 1\ncd /sys/bus/usb/devices/1-1\n\n# Examine device properties\ncat idVendor\n# 1b3f\n\ncat idProduct\n# 2008\n\ncat manufacturer\n# GeneralPlus\n\ncat product\n# USB Audio Device\n\ncat speed\n# 12 (Mbps - full speed USB)\n</code></pre> <p>The Guide notes: The USB device is detected, but no audio driver is loaded yet (we'll fix this in the next section).</p> <p>Verification Checklist:</p> <ul> <li>[ ] USB host controller visible with <code>lsusb</code> before plugging device</li> <li>[ ] USB audio device detected after plugging</li> <li>[ ] Kernel messages show device enumeration</li> <li>[ ] Device properties readable in <code>/sys/bus/usb/devices/1-1/</code></li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-6-in-tree-kernel-modules","title":"Section 6: In-Tree Kernel Modules","text":""},{"location":"labs/embedded-linux/lab06-hardware/#configure-usb-audio-as-module","title":"Configure USB Audio as Module","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/kernel/linux\n\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- menuconfig\n\n# Navigate to:\n# Device Drivers\n#   --&gt; Sound card support\n#       &lt;*&gt; Advanced Linux Sound Architecture (ALSA)\n#           &lt;M&gt; USB sound devices   # &lt;-- Change from &lt;*&gt; to &lt;M&gt;\n#               &lt;M&gt; USB Audio/MIDI driver    # CONFIG_SND_USB_AUDIO\n\n# Save and exit\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#compile-kernel-and-modules","title":"Compile Kernel and Modules","text":"<pre><code># Build kernel image (version will change to \"dirty\")\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- Image.gz -j$(nproc)\n\n# Build all modules\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- modules -j$(nproc)\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#install-modules-to-nfs-root","title":"Install Modules to NFS Root","text":"<pre><code># Install modules\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- \\\n    INSTALL_MOD_PATH=$HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot \\\n    modules_install\n\n# Verify installation\nls -l $HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot/lib/modules/\n\n# You should see a directory like: 6.6.x-dirty/\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#update-kernel-and-reboot","title":"Update Kernel and Reboot","text":"<pre><code># Copy new kernel to TFTP directory\ncp arch/arm64/boot/Image.gz /srv/tftp/\n\n# Reboot BeaglePlay\n# The kernel version now matches the module directory: 6.6.x-dirty\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#load-usb-audio-module","title":"Load USB Audio Module","text":"<pre><code># On BeaglePlay, with USB audio headset plugged in\n\n# Load the module\nmodprobe snd-usb-audio\n\n# Check loaded modules\nlsmod | grep snd\n\n# Expected output showing dependencies:\n# snd_usb_audio         245760  0\n# snd_usbmidi_lib        36864  1 snd_usb_audio\n# snd_rawmidi            36864  1 snd_usbmidi_lib\n# snd_seq_device         16384  1 snd_rawmidi\n# snd_hwdep              16384  1 snd_usb_audio\n# snd_pcm               114688  1 snd_usb_audio\n# snd_timer              32768  1 snd_pcm\n# snd                    73728  7 snd_usb_audio,snd_hwdep,snd_timer,...\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#verify-audio-subsystem","title":"Verify Audio Subsystem","text":"<pre><code># Check ALSA sound cards\ncat /proc/asound/cards\n# 0 [Device         ]: USB-Audio - USB Audio Device\n#                      GeneralPlus USB Audio Device at usb-xhci-hcd...\n\n# Check audio device files\nls -l /dev/snd/\n# Should show: controlC0  pcmC0D0c  pcmC0D0p  timer\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#check-usb-driver-binding","title":"Check USB Driver Binding","text":"<pre><code># List USB audio driver\nls -l /sys/bus/usb/drivers/snd-usb-audio/\n\n# Should show symbolic link to device 1-1\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#auto-load-module-at-boot","title":"Auto-Load Module at Boot","text":"<p>Add module loading to startup scripts:</p> <pre><code># On your workstation\ncd $HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot/etc/init.d\n\n# Edit rcS\nvi rcS\n\n# Add before the \"Starting system...\" message:\n# Load kernel modules\nmodprobe snd-usb-audio\n</code></pre> <p>Reboot BeaglePlay and verify the module loads automatically:</p> <pre><code># After reboot\nlsmod | grep snd\n\n# Should show snd_usb_audio and dependencies loaded\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] USB audio driver configured as module (<code>CONFIG_SND_USB_AUDIO=m</code>)</li> <li>[ ] Kernel and modules compiled successfully</li> <li>[ ] Modules installed to NFS root filesystem</li> <li>[ ] Module loads successfully with <code>modprobe snd-usb-audio</code></li> <li>[ ] ALSA sound card detected in <code>/proc/asound/cards</code></li> <li>[ ] Device files created in <code>/dev/snd/</code></li> <li>[ ] USB driver binding visible in sysfs</li> <li>[ ] Module auto-loads at boot from startup script</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-7-out-of-tree-kernel-module-nunchuk-driver","title":"Section 7: Out-of-Tree Kernel Module - Nunchuk Driver","text":""},{"location":"labs/embedded-linux/lab06-hardware/#hardware-setup-nunchuk-wiring","title":"Hardware Setup - Nunchuk Wiring","text":"<p>The Nintendo Wii Nunchuk uses I2C communication.</p> <p>Nunchuk Pinout:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   (UEXT front)  \u2502\n\u2502                 \u2502\n\u2502  \u2460 \u2461 \u2462 \u2463 \u2464 \u2465  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPin 1: +3.3V (PWR)\nPin 2: GND\nPin 3: SCL (I2C clock)\nPin 4: SDA (I2C data)\nPin 5: Not connected\nPin 6: Not connected\n</code></pre> <p>Connect to BeaglePlay mikroBUS:</p> <p>Using male-to-female jumper wires:</p> Nunchuk Pin BeaglePlay mikroBUS Pin Pin 1 (PWR) Pin 9 (3.3V) Pin 2 (GND) Pin 10 (GND) Pin 3 (SCL) Pin 14 (SCL) Pin 4 (SDA) Pin 13 (SDA)"},{"location":"labs/embedded-linux/lab06-hardware/#detect-nunchuk-on-i2c-bus","title":"Detect Nunchuk on I2C Bus","text":"<pre><code># On BeaglePlay, probe I2C3 bus\ni2cdetect -r 3\n\n# Expected output:\n#      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n# 00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n# 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 50: -- -- 52 -- -- -- -- -- -- -- -- -- -- -- -- --    # &lt;-- Nunchuk at 0x52!\n# 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n# 70: -- -- -- -- -- -- -- --\n</code></pre> <p>The Nunchuk is detected at I2C address 0x52.</p>"},{"location":"labs/embedded-linux/lab06-hardware/#obtain-nunchuk-driver-source","title":"Obtain Nunchuk Driver Source","text":"<pre><code># On your workstation\ncd $HOME/embedded-linux-beagleplay-labs/hardware\n\n# Download or create nunchuk.c driver\n# For this lab, we'll create a simplified version\n</code></pre> <p>Create nunchuk.c:</p> <pre><code>// nunchuk.c - I2C driver for Nintendo Wii Nunchuk\n#include &lt;linux/module.h&gt;\n#include &lt;linux/i2c.h&gt;\n#include &lt;linux/input.h&gt;\n#include &lt;linux/input-polldev.h&gt;\n#include &lt;linux/delay.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Nintendo Wii Nunchuk I2C driver\");\n\nstruct nunchuk_dev {\n    struct i2c_client *client;\n    struct input_polled_dev *polled_input;\n};\n\nstatic void nunchuk_poll(struct input_polled_dev *polled_input)\n{\n    struct nunchuk_dev *nunchuk = polled_input-&gt;private;\n    struct i2c_client *client = nunchuk-&gt;client;\n    u8 data[6];\n    int ret;\n    int z, c;\n\n    // Request data from Nunchuk\n    ret = i2c_master_send(client, (u8[]){0x00}, 1);\n    if (ret &lt; 0) {\n        dev_err(&amp;client-&gt;dev, \"Failed to request data\\n\");\n        return;\n    }\n\n    msleep(10);\n\n    // Read 6 bytes of data\n    ret = i2c_master_recv(client, data, 6);\n    if (ret != 6) {\n        dev_err(&amp;client-&gt;dev, \"Failed to read data\\n\");\n        return;\n    }\n\n    // Parse button states (inverted logic)\n    z = !(data[5] &amp; BIT(0));\n    c = !(data[5] &amp; BIT(1));\n\n    // Report button events\n    input_report_key(polled_input-&gt;input, BTN_Z, z);\n    input_report_key(polled_input-&gt;input, BTN_C, c);\n\n    // Report joystick position\n    input_report_abs(polled_input-&gt;input, ABS_X, data[0]);\n    input_report_abs(polled_input-&gt;input, ABS_Y, data[1]);\n\n    input_sync(polled_input-&gt;input);\n}\n\nstatic int nunchuk_probe(struct i2c_client *client,\n                         const struct i2c_device_id *id)\n{\n    struct nunchuk_dev *nunchuk;\n    struct input_polled_dev *polled_input;\n    struct input_dev *input;\n    int ret;\n\n    dev_info(&amp;client-&gt;dev, \"Nunchuk probe started\\n\");\n\n    // Initialize Nunchuk\n    ret = i2c_master_send(client, (u8[]){0xf0, 0x55}, 2);\n    if (ret &lt; 0) {\n        dev_err(&amp;client-&gt;dev, \"Failed to send init cmd 1\\n\");\n        return ret;\n    }\n\n    udelay(1000);\n\n    ret = i2c_master_send(client, (u8[]){0xfb, 0x00}, 2);\n    if (ret &lt; 0) {\n        dev_err(&amp;client-&gt;dev, \"Failed to send init cmd 2\\n\");\n        return ret;\n    }\n\n    // Allocate device structure\n    nunchuk = devm_kzalloc(&amp;client-&gt;dev, sizeof(*nunchuk), GFP_KERNEL);\n    if (!nunchuk)\n        return -ENOMEM;\n\n    nunchuk-&gt;client = client;\n\n    // Allocate polled input device\n    polled_input = input_allocate_polled_device();\n    if (!polled_input) {\n        dev_err(&amp;client-&gt;dev, \"Failed to allocate polled input\\n\");\n        return -ENOMEM;\n    }\n\n    nunchuk-&gt;polled_input = polled_input;\n    polled_input-&gt;private = nunchuk;\n    polled_input-&gt;poll = nunchuk_poll;\n    polled_input-&gt;poll_interval = 50; // 50ms polling\n\n    input = polled_input-&gt;input;\n    input-&gt;name = \"Wii Nunchuk\";\n    input-&gt;id.bustype = BUS_I2C;\n\n    // Setup input capabilities\n    set_bit(EV_KEY, input-&gt;evbit);\n    set_bit(BTN_Z, input-&gt;keybit);\n    set_bit(BTN_C, input-&gt;keybit);\n\n    set_bit(EV_ABS, input-&gt;evbit);\n    set_bit(ABS_X, input-&gt;absbit);\n    set_bit(ABS_Y, input-&gt;absbit);\n\n    input_set_abs_params(input, ABS_X, 30, 220, 4, 8);\n    input_set_abs_params(input, ABS_Y, 40, 200, 4, 8);\n\n    // Register input device\n    ret = input_register_polled_device(polled_input);\n    if (ret) {\n        dev_err(&amp;client-&gt;dev, \"Failed to register input device\\n\");\n        input_free_polled_device(polled_input);\n        return ret;\n    }\n\n    i2c_set_clientdata(client, nunchuk);\n\n    dev_info(&amp;client-&gt;dev, \"Nunchuk device probed successfully\\n\");\n    return 0;\n}\n\nstatic int nunchuk_remove(struct i2c_client *client)\n{\n    struct nunchuk_dev *nunchuk = i2c_get_clientdata(client);\n\n    input_unregister_polled_device(nunchuk-&gt;polled_input);\n    input_free_polled_device(nunchuk-&gt;polled_input);\n\n    dev_info(&amp;client-&gt;dev, \"Nunchuk device removed\\n\");\n    return 0;\n}\n\nstatic const struct i2c_device_id nunchuk_id[] = {\n    { \"nunchuk\", 0 },\n    { }\n};\nMODULE_DEVICE_TABLE(i2c, nunchuk_id);\n\nstatic const struct of_device_id nunchuk_dt_ids[] = {\n    { .compatible = \"nintendo,nunchuk\" },\n    { }\n};\nMODULE_DEVICE_TABLE(of, nunchuk_dt_ids);\n\nstatic struct i2c_driver nunchuk_driver = {\n    .driver = {\n        .name = \"nunchuk\",\n        .of_match_table = nunchuk_dt_ids,\n    },\n    .probe = nunchuk_probe,\n    .remove = nunchuk_remove,\n    .id_table = nunchuk_id,\n};\nmodule_i2c_driver(nunchuk_driver);\n</code></pre> <p>Create Makefile:</p> <pre><code>obj-m := nunchuk.o\n\nall:\n    make -C $(KERNEL_DIR) M=$(PWD) modules\n\nclean:\n    make -C $(KERNEL_DIR) M=$(PWD) clean\n\ninstall:\n    make -C $(KERNEL_DIR) M=$(PWD) INSTALL_MOD_PATH=$(INSTALL_MOD_PATH) modules_install\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#compile-out-of-tree-module","title":"Compile Out-of-Tree Module","text":"<pre><code># Set environment variables\nexport KERNEL_DIR=$HOME/embedded-linux-beagleplay-labs/kernel/linux\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-beagleplay-linux-musl-\n\n# Compile module\ncd $HOME/embedded-linux-beagleplay-labs/hardware\nmake\n\n# Verify nunchuk.ko was created\nls -l nunchuk.ko\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#install-module-to-nfs-root","title":"Install Module to NFS Root","text":"<pre><code># Install to NFS root filesystem\nmake install INSTALL_MOD_PATH=$HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot\n\n# Verify installation\nls -l $HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot/lib/modules/6.6.*/updates/\n\n# Should show nunchuk.ko\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#load-module-on-target","title":"Load Module on Target","text":"<pre><code># On BeaglePlay\nmodprobe nunchuk\n\n# Check kernel messages\ndmesg | tail -20\n\n# Expected output:\n# nunchuk: loading out-of-tree module taints kernel.\n# Nunchuk probe started\n</code></pre> <p>But wait! The driver loaded, but the device wasn't probed. Check I2C bus:</p> <pre><code>i2cdetect -r 3\n# Device at 0x52 still shown as \"52\", not \"UU\"\n# This means no driver is bound to it!\n\n# Check I2C drivers\nls /sys/bus/i2c/drivers/\n# You'll see \"nunchuk\" directory\n\n# But no devices inside:\nls /sys/bus/i2c/drivers/nunchuk/\n# Empty!\n</code></pre> <p>Why? The kernel doesn't know about the Nunchuk device yet. We need to declare it in the Device Tree!</p>"},{"location":"labs/embedded-linux/lab06-hardware/#section-8-device-tree-declaration","title":"Section 8: Device Tree Declaration","text":""},{"location":"labs/embedded-linux/lab06-hardware/#create-custom-device-tree","title":"Create Custom Device Tree","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/kernel/linux/arch/arm64/boot/dts/ti\n\n# Create custom DTS\nvi k3-am625-beagleplay-custom.dts\n</code></pre> <p>k3-am625-beagleplay-custom.dts:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n/*\n * Custom BeaglePlay Device Tree\n * Based on k3-am625-beagleplay.dts\n */\n\n/dts-v1/;\n\n#include \"k3-am625-beagleplay.dts\"\n\n/ {\n    model = \"BeaglePlay Custom Hardware Lab\";\n};\n\n/* I2C3 - mikroBUS connector */\n&amp;main_i2c3 {\n    status = \"okay\";\n    clock-frequency = &lt;100000&gt;; /* 100 kHz for Nunchuk */\n\n    nunchuk: joystick@52 {\n        compatible = \"nintendo,nunchuk\";\n        reg = &lt;0x52&gt;;\n    };\n};\n</code></pre> <p>Key Elements:</p> <ul> <li><code>#include \"k3-am625-beagleplay.dts\"</code>: Inherit standard BeaglePlay DT</li> <li><code>&amp;main_i2c3</code>: Override I2C3 node</li> <li><code>clock-frequency = &lt;100000&gt;</code>: Set bus to 100 kHz (Nunchuk requirement)</li> <li><code>nunchuk: joystick@52</code>: Declare device at address 0x52</li> <li><code>compatible = \"nintendo,nunchuk\"</code>: Match driver's <code>of_device_id</code></li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#compile-custom-device-tree","title":"Compile Custom Device Tree","text":"<pre><code># Add to Makefile\ncd $HOME/embedded-linux-beagleplay-labs/kernel/linux/arch/arm64/boot/dts/ti\n\nvi Makefile\n\n# Add line:\n# dtb-$(CONFIG_ARCH_K3) += k3-am625-beagleplay-custom.dtb\n\n# Compile\ncd $HOME/embedded-linux-beagleplay-labs/kernel/linux\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- dtbs\n\n# Copy to TFTP directory\ncp arch/arm64/boot/dts/ti/k3-am625-beagleplay-custom.dtb /srv/tftp/\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#update-u-boot-to-use-custom-dtb","title":"Update U-Boot to Use Custom DTB","text":"<p>On BeaglePlay U-Boot console:</p> <pre><code># Load custom DTB\n=&gt; setenv dtb_file k3-am625-beagleplay-custom.dtb\n\n# Save environment\n=&gt; saveenv\n\n# Boot\n=&gt; boot\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#verify-nunchuk-driver-binding","title":"Verify Nunchuk Driver Binding","text":"<pre><code># On BeaglePlay, reload module\nmodprobe -r nunchuk\nmodprobe nunchuk\n\n# Check kernel messages\ndmesg | tail -10\n\n# Expected output:\n# nunchuk: loading out-of-tree module taints kernel.\n# Nunchuk probe started\n# Nunchuk device probed successfully\n# input: Wii Nunchuk as /devices/platform/bus@f0000/20030000.i2c/i2c-3/3-0052/input/input2\n\n# Check I2C driver binding\nls -l /sys/bus/i2c/drivers/nunchuk/\n# Should show: 3-0052 -&gt; ../../../../devices/platform/.../i2c-3/3-0052\n\n# Probe I2C bus\ni2cdetect -r 3\n# Device at 0x52 now shows \"UU\" (driver bound!)\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#test-input-events","title":"Test Input Events","text":"<pre><code># Find input device number\nls /dev/input/event*\n\n# Based on kernel message (input2 \u2192 event2), test events\ncat /dev/input/event2 | od -x\n\n# Press buttons and move joystick on Nunchuk\n# You should see hexadecimal output changing\n\n# Stop with Ctrl+C\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Nunchuk wired correctly to mikroBUS I2C3</li> <li>[ ] Device detected at address 0x52 with <code>i2cdetect</code></li> <li>[ ] Out-of-tree module compiled successfully</li> <li>[ ] Module installed to NFS root filesystem</li> <li>[ ] Custom Device Tree created with Nunchuk node</li> <li>[ ] Custom DTB compiled and copied to TFTP directory</li> <li>[ ] U-Boot configured to load custom DTB</li> <li>[ ] Driver probe successful (kernel message visible)</li> <li>[ ] Driver bound to device (visible in sysfs)</li> <li>[ ] Input events generated when Nunchuk is used</li> </ul>"},{"location":"labs/embedded-linux/lab06-hardware/#section-9-persistent-module-loading","title":"Section 9: Persistent Module Loading","text":""},{"location":"labs/embedded-linux/lab06-hardware/#auto-load-nunchuk-module","title":"Auto-Load Nunchuk Module","text":"<pre><code># On workstation\ncd $HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot/etc/init.d\n\n# Edit rcS\nvi rcS\n\n# Add after snd-usb-audio modprobe line:\nmodprobe nunchuk\n\n# Save and exit\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#reboot-and-verify","title":"Reboot and Verify","text":"<pre><code># On BeaglePlay\nreboot\n\n# After boot, check loaded modules\nlsmod | grep nunchuk\n\n# Check driver binding\nls -l /sys/bus/i2c/drivers/nunchuk/\n\n# Verify input device\nls /dev/input/event*\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"labs/embedded-linux/lab06-hardware/#problem-gpio-export-fails-with-device-or-resource-busy","title":"Problem: GPIO export fails with \"Device or resource busy\"","text":"<p>Cause: GPIO already claimed by another driver or device.</p> <p>Solution:</p> <pre><code># Check GPIO usage\ncat /sys/kernel/debug/gpio | grep &lt;gpio-number&gt;\n\n# If in use by device tree, modify DT to disable that node\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#problem-i2cdetect-shows-empty-bus-but-device-is-connected","title":"Problem: i2cdetect shows empty bus but device is connected","text":"<p>Symptoms:</p> <pre><code>i2cdetect -r 3\n# All -- (no devices)\n</code></pre> <p>Checklist:</p> <ol> <li>Verify wiring:</li> <li>Check PWR \u2192 3.3V</li> <li>Check GND \u2192 GND</li> <li>Check SCL \u2192 SCL pin</li> <li> <p>Check SDA \u2192 SDA pin</p> </li> <li> <p>Check pull-up resistors: Nunchuk has internal pull-ups, but verify voltage on SDA/SCL is ~3.3V with multimeter</p> </li> <li> <p>Test with different Nunchuk (if available)</p> </li> <li> <p>Verify I2C bus is enabled in Device Tree:</p> </li> </ol> <pre><code># Check if I2C3 controller is enabled\nls /sys/bus/platform/devices/ | grep 20030000.i2c\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#problem-module-loads-but-device-not-probed","title":"Problem: Module loads but device not probed","text":"<p>Symptoms:</p> <pre><code>modprobe nunchuk\n# No error, but no \"probed successfully\" message\n</code></pre> <p>Cause: Device not declared in Device Tree.</p> <p>Solution:</p> <ol> <li>Verify custom DTB is loaded:</li> </ol> <pre><code># Check device tree model\ncat /sys/firmware/devicetree/base/model\n# Should show: BeaglePlay Custom Hardware Lab\n</code></pre> <ol> <li>Check I2C3 node in DT:</li> </ol> <pre><code>ls /sys/firmware/devicetree/base/bus@f0000/i2c@20030000/\n# Should show \"joystick@52\" directory\n</code></pre> <ol> <li>Recompile and reload custom DTB if missing</li> </ol>"},{"location":"labs/embedded-linux/lab06-hardware/#problem-version-magic-mismatch-when-loading-module","title":"Problem: \"version magic\" mismatch when loading module","text":"<p>Error:</p> <pre><code>insmod: ERROR: could not insert module nunchuk.ko: Invalid module format\ndmesg: version magic '6.6.52 SMP mod_unload aarch64' should be '6.6.52-dirty SMP mod_unload aarch64'\n</code></pre> <p>Cause: Module compiled against different kernel version than running kernel.</p> <p>Solution:</p> <pre><code># Check running kernel version\nuname -r\n# 6.6.52-dirty\n\n# Check module build version\nmodinfo nunchuk.ko | grep vermagic\n# vermagic: 6.6.52 SMP mod_unload aarch64\n\n# Rebuild kernel and modules together:\ncd $HOME/embedded-linux-beagleplay-labs/kernel/linux\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- Image.gz modules -j$(nproc)\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- \\\n    INSTALL_MOD_PATH=$HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot \\\n    modules_install\n\n# Rebuild out-of-tree module\ncd $HOME/embedded-linux-beagleplay-labs/hardware\nmake clean\nmake\nmake install INSTALL_MOD_PATH=$HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot\n\n# Update kernel on TFTP\ncp $HOME/embedded-linux-beagleplay-labs/kernel/linux/arch/arm64/boot/Image.gz /srv/tftp/\n\n# Reboot target\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#problem-input-events-not-generated","title":"Problem: Input events not generated","text":"<p>Symptoms:</p> <pre><code>cat /dev/input/event2 | od -x\n# No output when Nunchuk buttons pressed\n</code></pre> <p>Debug steps:</p> <ol> <li>Verify driver probed:</li> </ol> <pre><code>dmesg | grep -i nunchuk\n# Should show \"Nunchuk device probed successfully\"\n</code></pre> <ol> <li>Check input device registered:</li> </ol> <pre><code>cat /proc/bus/input/devices | grep -A 5 Nunchuk\n</code></pre> <ol> <li> <p>Enable I2C debugging in driver (requires driver modification)</p> </li> <li> <p>Test I2C communication manually:</p> </li> </ol> <pre><code># Read from Nunchuk\ni2cget -y 3 0x52 0x00\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#advanced-challenges","title":"Advanced Challenges","text":""},{"location":"labs/embedded-linux/lab06-hardware/#challenge-1-led-heartbeat-on-gpio","title":"Challenge 1: LED Heartbeat on GPIO","text":"<p>Create a custom LED trigger that blinks an external LED connected to GPIO 640.</p> <p>Requirements: - Add LED definition in Device Tree - Use timer trigger - Configure 1 second ON, 1 second OFF</p> Hint  Add to Device Tree:  <pre><code>/ {\n    leds {\n        compatible = \"gpio-leds\";\n\n        custom_led {\n            label = \"mikrobus:green:custom\";\n            gpios = &lt;&amp;main_gpio0 36 GPIO_ACTIVE_HIGH&gt;;\n            linux,default-trigger = \"timer\";\n        };\n    };\n};\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#challenge-2-explore-more-i2c-devices","title":"Challenge 2: Explore More I2C Devices","text":"<p>Scan all I2C buses and identify all devices. Research their addresses and likely function.</p> <p>Tools:</p> <pre><code># Scan all buses\nfor i in 0 1 2 3 5; do\n    echo \"=== Bus i2c-$i ===\"\n    i2cdetect -r $i\ndone\n\n# Decode device addresses using I2C device list:\n# https://i2c.wiki.kernel.org/index.php/Device_Addresses\n</code></pre>"},{"location":"labs/embedded-linux/lab06-hardware/#challenge-3-nunchuk-accelerometer-data","title":"Challenge 3: Nunchuk Accelerometer Data","text":"<p>Modify the Nunchuk driver to also report accelerometer data (bytes 2-4 in the Nunchuk data packet).</p> <p>Requirements: - Add <code>ABS_RX</code>, <code>ABS_RY</code>, <code>ABS_RZ</code> axes - Parse accelerometer bytes - Report values using <code>input_report_abs()</code></p>"},{"location":"labs/embedded-linux/lab06-hardware/#challenge-4-create-systemd-service-for-module-loading","title":"Challenge 4: Create systemd Service for Module Loading","text":"<p>Instead of loading modules from <code>rcS</code>, create a proper systemd service.</p> <p>Hint: Create <code>/etc/systemd/system/hardware-init.service</code></p>"},{"location":"labs/embedded-linux/lab06-hardware/#what-youve-learned","title":"What You've Learned","text":"<p>By completing this lab, you've gained hands-on experience with:</p> <p>\u2705 Linux Device Model: - Explored <code>/dev</code> device files and their major/minor numbers - Navigated sysfs (<code>/sys/class</code>, <code>/sys/bus</code>, <code>/sys/devices</code>) - Understood device classification by subsystem</p> <p>\u2705 GPIO Management: - Enabled legacy GPIO sysfs interface - Exported and controlled GPIOs from userspace - Configured GPIOs as inputs and outputs - Read digital values and set output states</p> <p>\u2705 LED Subsystem: - Controlled LEDs through sysfs - Used LED triggers (heartbeat, timer, manual) - Configured LED timing parameters</p> <p>\u2705 I2C Bus Management: - Listed and identified I2C controllers - Mapped Linux I2C numbers to hardware addresses - Probed I2C buses for devices - Interpreted <code>i2cdetect</code> output</p> <p>\u2705 USB Device Model: - Detected USB devices with <code>lsusb</code> - Explored USB device properties in sysfs - Understood USB device enumeration</p> <p>\u2705 Kernel Module Development: - Configured kernel features as loadable modules - Compiled in-tree modules - Installed modules to target filesystem - Loaded modules with <code>modprobe</code> - Inspected module dependencies with <code>lsmod</code> - Created out-of-tree kernel modules - Wrote Makefile for external module compilation</p> <p>\u2705 Device Tree: - Created custom Device Tree overlays - Declared I2C devices in DT - Matched devices to drivers via <code>compatible</code> strings - Compiled and deployed custom DTBs - Verified DT contents via sysfs</p> <p>\u2705 Driver Development: - Wrote I2C device driver (Nunchuk) - Implemented probe and remove functions - Registered input devices - Reported events to input subsystem - Debugged driver-device binding issues</p> <p>\u2705 System Integration: - Automated module loading at boot - Modified startup scripts - Persistent hardware configuration</p>"},{"location":"labs/embedded-linux/lab06-hardware/#going-further","title":"Going Further","text":""},{"location":"labs/embedded-linux/lab06-hardware/#recommended-reading","title":"Recommended Reading","text":"<p>Kernel Documentation: - <code>Documentation/driver-api/gpio/</code> - GPIO subsystem - <code>Documentation/leds/</code> - LED class documentation - <code>Documentation/i2c/</code> - I2C subsystem - <code>Documentation/input/</code> - Input device drivers - <code>Documentation/devicetree/</code> - Device Tree bindings</p> <p>Books: - Linux Device Drivers (3rd Edition) - Chapters 9-11 - Essential Linux Device Drivers - Chapters 3-8</p>"},{"location":"labs/embedded-linux/lab06-hardware/#next-steps","title":"Next Steps","text":"<p>In Lab 7: Block Filesystems, you'll: - Create ext4 filesystems on SD card - Implement SquashFS for read-only root - Use tmpfs for volatile storage - Boot entirely from SD card (no NFS)</p> <p>Estimated Completion Time: 4-5 hours</p> <p>Difficulty: \u2b50\u2b50\u2b50\u2606\u2606 (Intermediate)</p> <p>Prerequisites Met: \u2705 Lab 5 (Root Filesystem)</p> <p>Leads to: Lab 7 (Block Filesystems)</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/","title":"Lab 7: Block Filesystems and Persistent Storage","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about root filesystems:</p> <p>\"A root filesystem is where all your files live. Think of it as the contents of your towel bag - essential utilities, helpful tools, and the occasional item whose purpose you've completely forgotten but you're certain you'll need eventually.\"</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#objectives","title":"Objectives","text":"<p>Transition from network-based root filesystem to persistent block storage:</p> <ul> <li>Create and manage filesystem partitions on SD card</li> <li>Build ext4 filesystems for data storage</li> <li>Create read-only SquashFS root filesystem</li> <li>Use tmpfs for volatile temporary storage</li> <li>Configure persistent mounts with fstab</li> <li>Boot completely from SD card (kernel + DTB + rootfs)</li> <li>Implement proper separation: system vs. user data</li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 6 (Hardware Devices)</li> <li>Working NFS root filesystem from Lab 5</li> <li>SD card (minimum 8GB) in BeaglePlay</li> <li>Understanding of filesystem concepts</li> <li>Familiarity with partition tables</li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#lab-duration","title":"Lab Duration","text":"<p>Approximately 3-4 hours</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#storage-architecture-overview","title":"Storage Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        SD Card (mmcblk0)                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Partition 1    \u2502 Partition 2  \u2502 Partition 3    \u2502 Partition 4    \u2502\n\u2502 Boot (FAT32)   \u2502 Env (ext4)   \u2502 RootFS (squash)\u2502 Data (ext4)    \u2502\n\u2502 ~100MB         \u2502 ~50MB        \u2502 ~100MB         \u2502 Rest of space  \u2502\n\u2502                \u2502              \u2502                \u2502                \u2502\n\u2502 tiboot3.bin    \u2502 uEnv.txt     \u2502 BusyBox        \u2502 /www/upload/   \u2502\n\u2502 tispl.bin      \u2502 Image.gz     \u2502 Libraries      \u2502 files/         \u2502\n\u2502 u-boot.img     \u2502 *.dtb        \u2502 /bin, /sbin    \u2502 User data      \u2502\n\u2502                \u2502              \u2502 /etc (config)  \u2502                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSystem Boot Flow:\n1. ROM \u2192 tiboot3.bin (partition 1, FAT32)\n2. R5 SPL \u2192 tispl.bin (partition 1, FAT32)\n3. A53 U-Boot \u2192 u-boot.img (partition 1, FAT32)\n4. U-Boot loads: Image.gz + DTB (partition 2, ext4)\n5. Linux mounts: root=squashfs (partition 3, read-only)\n6. System mounts: /www/upload/files (partition 4, read-write)\n7. tmpfs mounted at: /var/log, /tmp (volatile RAM)\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#environment-setup","title":"Environment Setup","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#working-directory","title":"Working Directory","text":"<pre><code># Create block filesystem lab directory\ncd $HOME/embedded-linux-beagleplay-labs\nmkdir -p blockfs\ncd blockfs\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-current-nfs-setup","title":"Verify Current NFS Setup","text":"<pre><code># On BeaglePlay, verify current NFS mount\nmount | grep nfs\n\n# Expected:\n# 192.168.0.1:/home/&lt;user&gt;/.../tinysystem/nfsroot on / type nfs ...\n\n# Note current system size\ndu -sh /\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-1-filesystem-support-in-kernel","title":"Section 1: Filesystem Support in Kernel","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#configure-kernel-for-filesystem-types","title":"Configure Kernel for Filesystem Types","text":"<p>We need support for ext4, SquashFS, and tmpfs.</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/kernel/linux\n\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- menuconfig\n</code></pre> <p>Enable the following:</p> <pre><code>File systems ---&gt;\n    &lt;*&gt; Second extended fs support            (CONFIG_EXT2_FS)\n    &lt;*&gt; The Extended 4 (ext4) filesystem      (CONFIG_EXT4_FS)\n        [*] Ext4 POSIX Access Control Lists\n        [*] Ext4 Security Labels\n\n    [*] Miscellaneous filesystems ---&gt;\n        &lt;*&gt; SquashFS 4.0 - Squashed file system support  (CONFIG_SQUASHFS)\n            [*] Squashfs XATTR support\n            [*] Include support for ZLIB compressed file systems\n            [*] Include support for LZ4 compressed file systems\n            [*] Include support for LZO compressed file systems\n            [*] Include support for XZ compressed file systems\n            [*] Include support for ZSTD compressed file systems\n\n    Pseudo filesystems ---&gt;\n        [*] Tmpfs virtual memory file system support (CONFIG_TMPFS)\n        [*] Tmpfs POSIX Access Control Lists\n</code></pre> <p>Compile and Deploy:</p> <pre><code># Build kernel\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- Image.gz -j$(nproc)\n\n# Copy to TFTP\ncp arch/arm64/boot/Image.gz /srv/tftp/\n\n# Reboot BeaglePlay\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-filesystem-support","title":"Verify Filesystem Support","text":"<pre><code># On BeaglePlay (after reboot)\ncat /proc/filesystems\n\n# Expected output (partial):\n# nodev   sysfs\n# nodev   tmpfs\n# nodev   devtmpfs\n#         ext4\n#         squashfs\n# nodev   nfs\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] ext4 filesystem support enabled</li> <li>[ ] SquashFS support with compression enabled</li> <li>[ ] tmpfs support enabled</li> <li>[ ] Kernel compiled and deployed</li> <li>[ ] Filesystem types visible in <code>/proc/filesystems</code></li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-2-sd-card-partitioning","title":"Section 2: SD Card Partitioning","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#identify-sd-card-device","title":"Identify SD Card Device","text":"<pre><code># On BeaglePlay\ncat /proc/partitions\n\n# Expected output:\n# major minor  #blocks  name\n#  179        0    7634944 mmcblk0\n#  179        1     131072 mmcblk0p1    # Boot partition (existing)\n#  179        2      32768 mmcblk0p2    # Env partition (existing)\n</code></pre> <p>Important (like knowing where your towel is):  - <code>mmcblk0</code> is the SD card device - Existing partitions 1 and 2 contain bootloader and environment - DO NOT DELETE OR MODIFY PARTITIONS 1 AND 2!</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#backup-important-data","title":"Backup Important Data","text":"<p>Before repartitioning, backup the web upload files (if any):</p> <pre><code># On workstation (from NFS root)\ncd $HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot\ntar czf /tmp/www-backup.tar.gz www/upload/files/\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#create-new-partitions","title":"Create New Partitions","text":"<p>We'll add two new partitions: - Partition 3: 100MB for SquashFS root filesystem - Partition 4: Remaining space for data (ext4)</p> <p>On BeaglePlay:</p> <pre><code># CAUTION: This modifies the partition table!\nfdisk /dev/mmcblk0\n</code></pre> <p>fdisk interactive commands:</p> <pre><code>Command (m for help): p    # Print current partition table\n\n# You should see partitions 1 and 2\n# Note the end sector of partition 2\n\nCommand (m for help): n    # New partition\nPartition type: p          # Primary\nPartition number: 3        # Partition 3\nFirst sector: &lt;press Enter to accept default&gt;\nLast sector: +100M         # 100 megabytes for root filesystem\n\nCommand (m for help): n    # New partition for data\nPartition type: p          # Primary\nPartition number: 4        # Partition 4  \nFirst sector: &lt;press Enter&gt;\nLast sector: &lt;press Enter&gt; # Use remaining space\n\nCommand (m for help): p    # Print to verify\n\n# You should now see 4 partitions:\n# mmcblk0p1 (boot, FAT32)\n# mmcblk0p2 (env, ext4)\n# mmcblk0p3 (rootfs, will be SquashFS)\n# mmcblk0p4 (data, will be ext4)\n\nCommand (m for help): w    # Write changes and exit\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-new-partitions","title":"Verify New Partitions","text":"<pre><code># Re-read partition table\npartprobe /dev/mmcblk0\n\n# Or reboot if partprobe not available\nreboot\n\n# After reboot, verify\ncat /proc/partitions\n\n# Expected:\n#  179        0    7634944 mmcblk0\n#  179        1     131072 mmcblk0p1\n#  179        2      32768 mmcblk0p2\n#  179        3     102400 mmcblk0p3    # New: ~100MB\n#  179        4    7398400 mmcblk0p4    # New: rest of card\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Partition table backed up (optional but recommended)</li> <li>[ ] New partition 3 created (100MB)</li> <li>[ ] New partition 4 created (remaining space)</li> <li>[ ] Partition table written successfully</li> <li>[ ] New partitions visible in <code>/proc/partitions</code></li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-3-data-partition-ext4","title":"Section 3: Data Partition (ext4)","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#create-ext4-filesystem","title":"Create ext4 Filesystem","text":"<pre><code># On BeaglePlay\n# Create ext4 filesystem on partition 4\nmkfs.ext4 -L data /dev/mmcblk0p4\n\n# Flags explanation:\n# -L data: Set volume label to \"data\"\n# -E nodiscard: Skip bad block discarding (faster, optional)\n\n# Expected output:\n# Creating filesystem with ... 4k blocks and ... inodes\n# ...\n# Writing superblocks and filesystem accounting information: done\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#mount-and-test-data-partition","title":"Mount and Test Data Partition","text":"<pre><code># Create mount point\nmkdir -p /mnt/data\n\n# Mount partition\nmount /dev/mmcblk0p4 /mnt/data\n\n# Verify mount\nmount | grep mmcblk0p4\n# /dev/mmcblk0p4 on /mnt/data type ext4 (rw,relatime)\n\n# Test write\necho \"Test file on data partition\" &gt; /mnt/data/test.txt\ncat /mnt/data/test.txt\n\n# Check filesystem info\ndf -h /mnt/data\n# Should show available space\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#migrate-upload-directory-to-data-partition","title":"Migrate Upload Directory to Data Partition","text":"<p>Currently, web uploads are stored in <code>/www/upload/files</code> in the NFS root. Let's move this to persistent storage.</p> <pre><code># Create directory structure on data partition\nmkdir -p /mnt/data/www/upload/files\n\n# Restore backup if you created one earlier\n# (or manually copy any existing files from NFS)\n\n# Unmount for now (we'll set up automatic mounting later)\numount /mnt/data\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] ext4 filesystem created on <code>/dev/mmcblk0p4</code></li> <li>[ ] Filesystem labeled as \"data\"</li> <li>[ ] Successfully mounted and tested write access</li> <li>[ ] Directory structure created for web uploads</li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-4-root-filesystem-squashfs","title":"Section 4: Root Filesystem (SquashFS)","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#prepare-root-filesystem-directory","title":"Prepare Root Filesystem Directory","text":"<p>We'll use the NFS root from Lab 5 as the base.</p> <pre><code># On workstation\ncd $HOME/embedded-linux-beagleplay-labs/blockfs\n\n# Copy NFS root to blockfs directory\ncp -a ../tinysystem/nfsroot ./rootfs\n\n# Important: Create init symlink\n# SquashFS kernel boot requires /init\ncd rootfs\nln -s sbin/init init\n\n# Verify\nls -l init\n# lrwxrwxrwx 1 user user 9 ... init -&gt; sbin/init\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#modify-startup-scripts-for-block-storage","title":"Modify Startup Scripts for Block Storage","text":"<p>The startup script needs to mount the data partition automatically.</p> <pre><code># Edit rcS\ncd $HOME/embedded-linux-beagleplay-labs/blockfs/rootfs/etc/init.d\nvi rcS\n</code></pre> <p>Modify rcS to add data partition mount:</p> <pre><code>#!/bin/sh\n\n# Mount essential filesystems\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\n\n# Mount data partition for web uploads\nmkdir -p /www/upload/files\nmount -t ext4 /dev/mmcblk0p4 /www/upload/files\n\n# Mount tmpfs for temporary files\nmount -t tmpfs tmpfs /tmp\nmount -t tmpfs tmpfs /var\n\n# Create necessary directories in tmpfs\nmkdir -p /var/log\nmkdir -p /var/run\n\n# Load kernel modules\nmodprobe snd-usb-audio\nmodprobe nunchuk\n\n# Network configuration\nip addr add 192.168.0.100/24 dev eth0\nip link set eth0 up\n\n# Start web server\n/usr/sbin/httpd -h /www/\n\necho \"Starting system...\"\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#update-upload-script-configuration","title":"Update Upload Script Configuration","text":"<p>The upload script needs to log to tmpfs, not the data partition.</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/blockfs/rootfs/www/cgi-bin\nvi upload.cfg\n</code></pre> <p>Update log file path:</p> <pre><code>#!/bin/sh\n\n# Upload configuration\nUPLOAD_DIR=/www/upload/files\nLOG_FILE=/var/log/upload.log    # Changed from /www/upload/files/upload.log\nMAX_SIZE=10485760  # 10MB\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#install-squashfs-tools-workstation","title":"Install SquashFS Tools (Workstation)","text":"<pre><code># On workstation\nsudo apt update\nsudo apt install squashfs-tools\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#create-squashfs-image","title":"Create SquashFS Image","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/blockfs\n\n# Create compressed SquashFS image\nmksquashfs rootfs rootfs.sqfs -comp xz -Xbcj arm\n\n# Flags explanation:\n# -comp xz: Use XZ compression (best compression ratio)\n# -Xbcj arm: ARM-specific binary optimization filter\n\n# Expected output:\n# Creating 4.0 filesystem on rootfs.sqfs, block size 131072.\n# ...\n# Exportable Squashfs 4.0 filesystem, xz compressed, data block size 131072\n</code></pre> <p>Check Image Size:</p> <pre><code>ls -lh rootfs.sqfs\n\n# Should be significantly smaller than original rootfs directory\ndu -sh rootfs\ndu -sh rootfs.sqfs\n\n# Example:\n# 50M   rootfs/\n# 12M   rootfs.sqfs\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#write-squashfs-to-sd-card","title":"Write SquashFS to SD Card","text":"<p>We'll use <code>dd</code> to write the image directly to partition 3.</p> <p>Important (like knowing where your towel is): This operation must be done from the workstation or from BeaglePlay before mounting partition 3.</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#option-a-from-workstation-sd-card-reader","title":"Option A: From Workstation (SD Card Reader)","text":"<pre><code># Remove SD card from BeaglePlay and insert into workstation SD reader\n# Identify device (e.g., /dev/sdb)\nlsblk\n\n# Write SquashFS image to partition 3\nsudo dd if=rootfs.sqfs of=/dev/sdb3 bs=1M status=progress\n\n# Sync to ensure all data is written\nsync\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#option-b-from-beagleplay-via-nfs","title":"Option B: From BeaglePlay (via NFS)","text":"<pre><code># On workstation: copy image to NFS root\ncp rootfs.sqfs $HOME/embedded-linux-beagleplay-labs/tinysystem/nfsroot/tmp/\n\n# On BeaglePlay:\ndd if=/tmp/rootfs.sqfs of=/dev/mmcblk0p3 bs=1M\n\n# Sync\nsync\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] NFS root copied to blockfs/rootfs directory</li> <li>[ ] <code>/init</code> symlink created pointing to <code>/sbin/init</code></li> <li>[ ] Startup script modified to mount data partition</li> <li>[ ] Upload script configured to log to <code>/var/log</code></li> <li>[ ] SquashFS image created successfully</li> <li>[ ] Image written to <code>/dev/mmcblk0p3</code></li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-5-tmpfs-for-volatile-storage","title":"Section 5: Tmpfs for Volatile Storage","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#why-tmpfs","title":"Why Tmpfs?","text":"<p>Tmpfs is a temporary filesystem stored in RAM:</p> <ul> <li>Fast: No disk I/O, operates at RAM speed</li> <li>Volatile: Data lost on reboot (ideal for logs, temporary files)</li> <li>Automatically sized: Grows/shrinks based on usage</li> <li>Read-only root friendly: Allows writes even with SquashFS root</li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#tmpfs-mount-points","title":"Tmpfs Mount Points","text":"<p>Our startup script already mounts tmpfs at:</p> <pre><code>mount -t tmpfs tmpfs /tmp      # Temporary files\nmount -t tmpfs tmpfs /var      # Variable data (logs, run files)\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-tmpfs-in-startup-script","title":"Verify Tmpfs in Startup Script","text":"<p>The <code>rcS</code> script we modified earlier should have:</p> <pre><code># Mount tmpfs for temporary files\nmount -t tmpfs tmpfs /tmp\nmount -t tmpfs tmpfs /var\n\n# Create necessary directories in tmpfs\nmkdir -p /var/log\nmkdir -p /var/run\n</code></pre> <p>This ensures: - <code>/var/log/upload.log</code> is stored in RAM (volatile) - System run files go to <code>/var/run</code> (volatile) - Temporary files go to <code>/tmp</code> (volatile)</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-6-boot-from-sd-card-root-filesystem","title":"Section 6: Boot from SD Card Root Filesystem","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#configure-u-boot-bootcmd","title":"Configure U-Boot Bootcmd","text":"<p>Now we'll configure U-Boot to boot the kernel and DTB from SD card partition 2 (ext4), and mount root from partition 3 (SquashFS).</p> <p>Copy Kernel and DTB to SD Card (Workstation):</p> <pre><code># Remove SD card from BeaglePlay, insert into workstation\n# Assume partition 2 is mounted at /media/&lt;user&gt;/env\n\n# Copy kernel\ncp $HOME/embedded-linux-beagleplay-labs/kernel/linux/arch/arm64/boot/Image.gz \\\n   /media/&lt;user&gt;/env/\n\n# Copy Device Tree\ncp $HOME/embedded-linux-beagleplay-labs/kernel/linux/arch/arm64/boot/dts/ti/k3-am625-beagleplay-custom.dtb \\\n   /media/&lt;user&gt;/env/\n\n# Sync and unmount\nsync\nsudo umount /media/&lt;user&gt;/env\n</code></pre> <p>Insert SD card back into BeaglePlay and boot.</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#update-u-boot-environment","title":"Update U-Boot Environment","text":"<p>On BeaglePlay U-Boot console (interrupt boot with any key):</p> <pre><code># Save current TFTP boot command (for easy switching back)\n=&gt; setenv bootcmdtftp \"${bootcmd}\"\n\n# Define SD card boot command\n=&gt; setenv bootcmdsd 'load mmc 1:2 0x80000000 Image.gz; load mmc 1:2 0x82000000 k3-am625-beagleplay-custom.dtb; booti 0x80000000 - 0x82000000'\n\n# Set kernel command line for SD card root\n=&gt; setenv bootargs 'console=ttyS2,115200 root=/dev/mmcblk0p3 rootwait ro'\n\n# Explanation:\n# - console=ttyS2,115200: Serial console\n# - root=/dev/mmcblk0p3: Root filesystem on partition 3\n# - rootwait: Wait for SD card initialization before mounting root\n# - ro: Mount root filesystem as read-only (SquashFS requirement)\n\n# Set bootcmd to SD card boot\n=&gt; setenv bootcmd 'run bootcmdsd'\n\n# Save environment\n=&gt; saveenv\n\n# Boot\n=&gt; boot\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#expected-boot-sequence","title":"Expected Boot Sequence","text":"<p>Watch the boot messages:</p> <pre><code>U-Boot SPL 2024.01 (...)\n...\nLoading kernel from MMC...\nLoading Device Tree from MMC...\nStarting kernel ...\n\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n...\n[    2.543210] VFS: Mounted root (squashfs filesystem) readonly on device 179:3.\n[    2.678543] devtmpfs: mounted\n...\n[    3.123456] mount: mounting /dev/mmcblk0p4 on /www/upload/files succeeded\n...\nStarting system...\n\nWelcome to BeaglePlay!\nbeagleplay login:\n</code></pre> <p>Key indicators: - <code>Mounted root (squashfs filesystem) readonly on device 179:3</code> \u2190 SquashFS root - <code>mounting /dev/mmcblk0p4 on /www/upload/files succeeded</code> \u2190 Data partition</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-mounts","title":"Verify Mounts","text":"<pre><code># Login as root (no password)\n\n# Check all mounts\nmount\n\n# Expected output:\n# /dev/mmcblk0p3 on / type squashfs (ro,relatime)\n# devtmpfs on /dev type devtmpfs (rw,relatime,...)\n# proc on /proc type proc (rw,relatime)\n# sysfs on /sys type sysfs (rw,relatime)\n# /dev/mmcblk0p4 on /www/upload/files type ext4 (rw,relatime)\n# tmpfs on /tmp type tmpfs (rw,relatime)\n# tmpfs on /var type tmpfs (rw,relatime)\n\n# Check filesystem usage\ndf -h\n\n# /dev/mmcblk0p3 on / should show squashfs, read-only\n# /dev/mmcblk0p4 on /www/upload/files should show ext4, read-write\n# tmpfs on /var and /tmp should show RAM usage\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#test-read-only-root","title":"Test Read-Only Root","text":"<pre><code># Try to create a file in root (should fail)\ntouch /test.txt\n# touch: /test.txt: Read-only file system\n\n# Verify root is read-only\nmount | grep \"on / \"\n# /dev/mmcblk0p3 on / type squashfs (ro,relatime)\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#test-write-to-data-partition","title":"Test Write to Data Partition","text":"<pre><code># Create test file\necho \"Persistent data test\" &gt; /www/upload/files/test.txt\n\n# Read it back\ncat /www/upload/files/test.txt\n\n# Reboot\nreboot\n\n# After reboot, verify file persists\ncat /www/upload/files/test.txt\n# Persistent data test    &lt;-- File survived reboot!\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#test-tmpfs-volatility","title":"Test Tmpfs Volatility","text":"<pre><code># Create file in tmpfs\necho \"Volatile log entry\" &gt; /var/log/test.log\ncat /var/log/test.log\n\n# Reboot\nreboot\n\n# After reboot, check if file exists\ncat /var/log/test.log\n# cat: can't open '/var/log/test.log': No such file or directory  &lt;-- Gone!\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Kernel and DTB copied to SD card partition 2</li> <li>[ ] U-Boot configured to load from SD card</li> <li>[ ] Kernel command line set with <code>root=/dev/mmcblk0p3 rootwait ro</code></li> <li>[ ] System boots successfully from SquashFS root</li> <li>[ ] Root filesystem mounted read-only</li> <li>[ ] Data partition mounted at <code>/www/upload/files</code> (read-write)</li> <li>[ ] Tmpfs mounted at <code>/tmp</code> and <code>/var</code></li> <li>[ ] Persistent data survives reboot</li> <li>[ ] Tmpfs data is volatile (lost on reboot)</li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-7-testing-web-interface","title":"Section 7: Testing Web Interface","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-http-server","title":"Verify HTTP Server","text":"<pre><code># On BeaglePlay, check httpd is running\nps | grep httpd\n\n# Expected:\n#  1234 root     /usr/sbin/httpd -h /www/\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#test-upload-functionality","title":"Test Upload Functionality","text":"<p>From your workstation browser:</p> <ol> <li> <p>Navigate to <code>http://192.168.0.100/index.html</code></p> </li> <li> <p>Upload a test image using the web interface</p> </li> <li> <p>Verify image appears in listing</p> </li> </ol> <p>On BeaglePlay:</p> <pre><code># Check uploaded file\nls -l /www/upload/files/\n\n# Should show your uploaded image\n# -rw-r--r-- 1 root root 123456 Jan  1 00:12 test-image.jpg\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#check-upload-log","title":"Check Upload Log","text":"<pre><code># View upload log (tmpfs - volatile)\ncat /var/log/upload.log\n\n# Should show upload activity\n# Jan  1 00:12:34 File uploaded: test-image.jpg (123456 bytes)\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#verify-log-volatility","title":"Verify Log Volatility","text":"<pre><code># Note log contents\ncat /var/log/upload.log\n\n# Reboot\nreboot\n\n# After reboot, check log\ncat /var/log/upload.log\n# Should be empty or non-existent\n\n# But uploaded files persist!\nls /www/upload/files/\n# Files still there!\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Web server running and accessible</li> <li>[ ] File upload functionality works</li> <li>[ ] Uploaded files stored on ext4 data partition</li> <li>[ ] Upload log written to tmpfs <code>/var/log</code></li> <li>[ ] Uploaded files persist across reboot</li> <li>[ ] Upload log is volatile (lost on reboot)</li> </ul>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#section-8-switching-boot-modes","title":"Section 8: Switching Boot Modes","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#switch-back-to-tftp-boot-for-development","title":"Switch Back to TFTP Boot (for Development)","text":"<p>During development, NFS/TFTP boot is faster for iteration. Let's keep the ability to switch modes.</p> <p>On U-Boot console:</p> <pre><code># Boot from TFTP/NFS\n=&gt; setenv bootcmd 'run bootcmdtftp'\n=&gt; saveenv\n=&gt; boot\n\n# Or without saving (one-time):\n=&gt; run bootcmdtftp\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#switch-back-to-sd-card-boot","title":"Switch Back to SD Card Boot","text":"<pre><code># Boot from SD card\n=&gt; setenv bootcmd 'run bootcmdsd'\n=&gt; saveenv\n=&gt; boot\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#u-boot-environment-summary","title":"U-Boot Environment Summary","text":"<p>After this lab, your U-Boot environment should have:</p> <pre><code>bootcmdtftp=&lt;TFTP boot commands&gt;   # Development mode\nbootcmdsd=run bootcmdsd            # Production mode\nbootcmd=run bootcmdsd              # Default: SD card boot\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#problem-kernel-panic-not-syncing-vfs-unable-to-mount-root-fs","title":"Problem: Kernel panic - not syncing: VFS: Unable to mount root fs","text":"<p>Symptoms:</p> <pre><code>[    2.123456] VFS: Cannot open root device \"mmcblk0p3\" or unknown-block(179,3)\n[    2.123456] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(179,3)\n</code></pre> <p>Possible causes:</p> <ol> <li>SquashFS support not compiled in kernel:</li> </ol> <pre><code># Verify CONFIG_SQUASHFS=y\ncd $HOME/embedded-linux-beagleplay-labs/kernel/linux\ngrep CONFIG_SQUASHFS .config\n\n# Should show:\n# CONFIG_SQUASHFS=y\n\n# If not, reconfigure and recompile\nmake ARCH=arm64 menuconfig\n# Enable SquashFS\nmake ARCH=arm64 CROSS_COMPILE=aarch64-beagleplay-linux-musl- Image.gz -j$(nproc)\n</code></pre> <ol> <li>Partition 3 is empty or corrupted:</li> </ol> <pre><code># Boot from NFS first, then check partition 3\ndd if=/dev/mmcblk0p3 bs=512 count=1 | hexdump -C\n\n# SquashFS magic: 0x73717368 (hsqs in little-endian)\n# Should see \"hsqs\" in first few bytes\n\n# If not, re-write SquashFS image:\ndd if=/tmp/rootfs.sqfs of=/dev/mmcblk0p3 bs=1M\nsync\n</code></pre> <ol> <li>Wrong partition number in bootargs:</li> </ol> <pre><code># Verify bootargs\n# In U-Boot:\n=&gt; printenv bootargs\n# Should show: root=/dev/mmcblk0p3\n\n# If wrong, correct it:\n=&gt; setenv bootargs 'console=ttyS2,115200 root=/dev/mmcblk0p3 rootwait ro'\n=&gt; saveenv\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#problem-wwwuploadfiles-mount-fails","title":"Problem: /www/upload/files mount fails","text":"<p>Symptoms:</p> <pre><code>mount: mounting /dev/mmcblk0p4 on /www/upload/files failed: No such device\n</code></pre> <p>Solutions:</p> <ol> <li>Ext4 support missing:</li> </ol> <pre><code># Verify ext4 is enabled in kernel\ncat /proc/filesystems | grep ext4\n\n# If not listed, recompile kernel with CONFIG_EXT4_FS=y\n</code></pre> <ol> <li>Partition 4 not formatted:</li> </ol> <pre><code># Check if partition exists\ncat /proc/partitions | grep mmcblk0p4\n\n# Format if needed\nmkfs.ext4 /dev/mmcblk0p4\n</code></pre> <ol> <li>Mount point doesn't exist:</li> </ol> <pre><code># rcS should create mount point:\nmkdir -p /www/upload/files\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#problem-tmpfs-mount-fails","title":"Problem: Tmpfs mount fails","text":"<p>Error:</p> <pre><code>mount: mounting tmpfs on /tmp failed: Invalid argument\n</code></pre> <p>Solution:</p> <pre><code># Verify tmpfs support\ncat /proc/filesystems | grep tmpfs\n\n# Should show:\n# nodev tmpfs\n\n# If missing, enable CONFIG_TMPFS in kernel\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#problem-system-is-read-only-cant-write-anywhere","title":"Problem: System is read-only, can't write anywhere","text":"<p>Symptoms:</p> <pre><code># Even data partition is read-only\ntouch /www/upload/files/test.txt\n# touch: /www/upload/files/test.txt: Read-only file system\n</code></pre> <p>Cause: Data partition mounted read-only.</p> <p>Solution:</p> <pre><code># Remount data partition as read-write\nmount -o remount,rw /dev/mmcblk0p4 /www/upload/files\n\n# Verify\nmount | grep mmcblk0p4\n# Should show (rw,...)\n\n# Fix rcS to mount as rw explicitly:\nmount -t ext4 -o rw /dev/mmcblk0p4 /www/upload/files\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#problem-cannot-update-system-squashfs-is-read-only","title":"Problem: Cannot update system (SquashFS is read-only)","text":"<p>This is intentional! SquashFS root is immutable.</p> <p>To update the system:</p> <ol> <li>Modify rootfs on workstation:</li> </ol> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/blockfs/rootfs\n# Make changes to files/scripts\n</code></pre> <ol> <li>Rebuild SquashFS image:</li> </ol> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/blockfs\nmksquashfs rootfs rootfs.sqfs -comp xz -Xbcj arm\n</code></pre> <ol> <li>Write new image to partition 3:</li> </ol> <pre><code># From workstation (SD card reader):\nsudo dd if=rootfs.sqfs of=/dev/sdb3 bs=1M status=progress\nsync\n\n# Or from BeaglePlay (boot from NFS first):\ndd if=/tmp/rootfs.sqfs of=/dev/mmcblk0p3 bs=1M\nsync\n</code></pre> <ol> <li>Reboot and test</li> </ol> <p>This workflow ensures system integrity - accidental changes can't corrupt the root filesystem.</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#advanced-challenges","title":"Advanced Challenges","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#challenge-1-implement-overlay-filesystem","title":"Challenge 1: Implement Overlay Filesystem","text":"<p>Combine read-only SquashFS root with read-write tmpfs overlay, allowing temporary system modifications without modifying the base SquashFS.</p> <p>Hint: Use <code>overlayfs</code></p> <pre><code># In rcS:\nmount -t overlay overlay -o lowerdir=/,upperdir=/tmp/upper,workdir=/tmp/work /mnt/overlay\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#challenge-2-add-swap-partition","title":"Challenge 2: Add Swap Partition","text":"<p>Create a swap partition on the SD card for emergency memory relief.</p> <p>Steps: 1. Create partition 5 with fdisk (512MB) 2. Format as swap: <code>mkswap /dev/mmcblk0p5</code> 3. Enable in rcS: <code>swapon /dev/mmcblk0p5</code></p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#challenge-3-implement-etc-overlay","title":"Challenge 3: Implement /etc Overlay","text":"<p>Make <code>/etc</code> writable while keeping <code>/</code> read-only, allowing runtime configuration changes.</p> <p>Approach: - Copy <code>/etc</code> to <code>/www/upload/files/etc</code> (persistent) - Use bind mount or overlay to make <code>/etc</code> writable</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#challenge-4-partition-alignment-optimization","title":"Challenge 4: Partition Alignment Optimization","text":"<p>Optimize partition boundaries for SD card erase block size.</p> <pre><code># Find preferred erase size\ncat /sys/bus/mmc/devices/mmc0:0001/preferred_erase_size\n\n# Align partitions to multiples of this size\n# Use fdisk with sector calculations\n</code></pre>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#challenge-5-read-only-root-with-persistent-logs","title":"Challenge 5: Read-Only Root with Persistent Logs","text":"<p>Implement persistent logging despite read-only root:</p> <p>Approach: - Store logs on data partition: <code>/www/upload/files/logs/</code> - Bind mount or symlink <code>/var/log</code> to persistent location - Rotate logs to prevent partition filling</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#what-youve-learned","title":"What You've Learned","text":"<p>By completing this lab, you've mastered:</p> <p>\u2705 Filesystem Kernel Support: - Configured ext4 filesystem support - Enabled SquashFS with multiple compression algorithms - Enabled tmpfs for volatile RAM storage</p> <p>\u2705 Partition Management: - Used fdisk to create new partitions - Preserved bootloader partitions - Aligned partitions properly on SD card</p> <p>\u2705 ext4 Filesystem: - Created ext4 filesystems with labels - Mounted and tested read-write access - Used ext4 for persistent user data</p> <p>\u2705 SquashFS: - Created compressed SquashFS images - Understood compression options (xz, lzo, lz4) - Wrote SquashFS directly to partition - Booted from read-only SquashFS root</p> <p>\u2705 Tmpfs: - Mounted tmpfs for volatile storage - Used tmpfs for <code>/tmp</code> and <code>/var</code> - Understood tmpfs lifecycle (RAM-based, lost on reboot)</p> <p>\u2705 System Integration: - Migrated from NFS to block storage boot - Modified startup scripts for automatic mounting - Configured U-Boot for SD card boot - Implemented proper separation: system vs. user data</p> <p>\u2705 Boot Configuration: - Stored kernel and DTB on ext4 partition - Configured kernel command line (<code>root=</code>, <code>rootwait</code>, <code>ro</code>) - Managed multiple boot modes (TFTP vs. SD card)</p> <p>\u2705 Storage Architecture Best Practices: - Read-only root filesystem (SquashFS) for system integrity - Read-write data partition (ext4) for user files - Volatile storage (tmpfs) for temporary data and logs - Clear separation of concerns</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#going-further","title":"Going Further","text":""},{"location":"labs/embedded-linux/lab07-block-filesystems/#recommended-reading","title":"Recommended Reading","text":"<p>Kernel Documentation: - <code>Documentation/filesystems/ext4.txt</code> - ext4 filesystem - <code>Documentation/filesystems/squashfs.txt</code> - SquashFS details - <code>Documentation/filesystems/tmpfs.txt</code> - Tmpfs usage</p> <p>Storage: - <code>Documentation/mmc/</code> - MMC/SD card subsystem</p> <p>Articles: - \"SquashFS vs ext4: When to use which\" - Embedded Linux design patterns - \"Optimizing SD card usage in embedded Linux\" - Partition alignment, wear leveling</p>"},{"location":"labs/embedded-linux/lab07-block-filesystems/#next-steps","title":"Next Steps","text":"<p>In Lab 8: Buildroot, you'll: - Automate the entire build process with Buildroot - Generate root filesystem images automatically - Build external kernel modules with Buildroot - Configure and customize package selection - Create reproducible embedded Linux systems</p> <p>Estimated Completion Time: 3-4 hours</p> <p>Difficulty: \u2b50\u2b50\u2b50\u2606\u2606 (Intermediate)</p> <p>Prerequisites Met: \u2705 Lab 6 (Hardware Devices)</p> <p>Leads to: Lab 8 (Buildroot System Integration)</p>"},{"location":"labs/embedded-linux/lab08-buildroot/","title":"Lab 8: System Integration with Buildroot","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about root filesystems:</p> <p>\"A root filesystem is where all your files live. Think of it as the contents of your towel bag - essential utilities, helpful tools, and the occasional item whose purpose you've completely forgotten but you're certain you'll need eventually.\"</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#objectives","title":"Objectives","text":"<p>Master automated embedded Linux system building with Buildroot:</p> <ul> <li>Understand Buildroot architecture and workflow</li> <li>Configure Buildroot for BeaglePlay (ARM64 Cortex-A53)</li> <li>Integrate custom external toolchain</li> <li>Build kernel with custom patches and configuration</li> <li>Select and configure packages (BusyBox, alsa-utils, mpd)</li> <li>Create custom Buildroot packages for out-of-tree drivers</li> <li>Use root filesystem overlays for customization</li> <li>Generate reproducible system images</li> <li>Analyze package dependencies</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 7 (Block Filesystems)</li> <li>Custom toolchain from Lab 1</li> <li>Kernel configuration from Lab 4</li> <li>Nunchuk driver from Lab 6</li> <li>Understanding of embedded Linux components</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#lab-duration","title":"Lab Duration","text":"<p>Approximately 4-5 hours</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#buildroot-architecture","title":"Buildroot Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Buildroot Workflow                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nInput Configuration:\n  - .config (generated by make menuconfig)\n  - board/&lt;vendor&gt;/&lt;board&gt;/\n      \u251c\u2500\u2500 linux.config (kernel config)\n      \u251c\u2500\u2500 *.patch (kernel patches)\n      \u2514\u2500\u2500 rootfs-overlay/ (filesystem customization)\n\n              \u2193 make\n\nDownload Phase:\n  - Fetch packages from upstream (dl/ directory)\n  - Verify checksums\n\n              \u2193\n\nBuild Phase (output/build/):\n  - Extract packages\n  - Apply patches\n  - Configure (./configure, cmake, meson)\n  - Compile (make, ninja)\n  - Install to staging/ (headers, libraries)\n  - Install to target/ (binaries, stripped)\n\n              \u2193\n\nImage Generation (output/images/):\n  - rootfs.tar (tarball)\n  - Image.gz (kernel)\n  - *.dtb (device trees)\n  - Optional: SD card images, initramfs\n\n              \u2193\n\nDeployment:\n  - Extract to NFS root\n  - Write to SD card\n  - TFTP boot\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#environment-setup","title":"Environment Setup","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#working-directory","title":"Working Directory","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs\nmkdir -p buildroot-lab\ncd buildroot-lab\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#clone-buildroot","title":"Clone Buildroot","text":"<pre><code># Clone official Buildroot repository\ngit clone https://git.buildroot.net/buildroot\ncd buildroot\n\n# Checkout stable LTS release\ngit checkout 2024.02.x\n\n# Note: Use LTS releases for production systems\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-1-board-specific-files","title":"Section 1: Board-Specific Files","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#create-board-directory-structure","title":"Create Board Directory Structure","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Create board-specific directory\nmkdir -p board/beagleplay/training\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#copy-kernel-configuration","title":"Copy Kernel Configuration","text":"<pre><code># Copy the kernel config from Lab 4\ncp $HOME/embedded-linux-beagleplay-labs/kernel/linux/.config \\\n   board/beagleplay/training/linux.config\n\n# Verify it's a valid ARM64 config\ngrep \"CONFIG_ARM64=y\" board/beagleplay/training/linux.config\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#copy-kernel-patches","title":"Copy Kernel Patches","text":"<p>We'll include our custom Device Tree from Lab 6.</p> <pre><code># Copy the Device Tree patch\ncp $HOME/embedded-linux-beagleplay-labs/kernel/linux/0001-Custom-DTS-for-Bootlin-lab.patch \\\n   board/beagleplay/training/\n\n# Note: If you didn't create this patch in Lab 6, create it now:\ncd $HOME/embedded-linux-beagleplay-labs/kernel/linux\n\n# Ensure you're on your custom branch\ngit checkout beagleplay-labs\n\n# Create patch from the custom DTS commit\ngit format-patch -1 HEAD -o $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/board/beagleplay/training/\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#prepare-root-filesystem-overlay","title":"Prepare Root Filesystem Overlay","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Create overlay directory\nmkdir -p board/beagleplay/training/rootfs-overlay\n\n# We'll populate this later with custom scripts\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Buildroot cloned and checked out to LTS version</li> <li>[ ] <code>board/beagleplay/training/</code> directory created</li> <li>[ ] Kernel configuration copied</li> <li>[ ] Kernel patch file present</li> <li>[ ] Root filesystem overlay directory created</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-2-buildroot-configuration","title":"Section 2: Buildroot Configuration","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#start-configuration","title":"Start Configuration","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Launch menuconfig\nmake menuconfig\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#target-architecture","title":"Target Architecture","text":"<pre><code>Target options ---&gt;\n    Target Architecture (AArch64 (little endian))\n    Target Architecture Variant (cortex-A53)\n    Floating point strategy (FP-ARMv8)\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#toolchain-configuration","title":"Toolchain Configuration","text":"<p>We'll use our custom toolchain from Lab 1.</p> <pre><code>Toolchain ---&gt;\n    Toolchain type (External toolchain)\n    *** Toolchain External Options ***\n    Toolchain (Custom toolchain)\n    Toolchain origin (Pre-installed toolchain)\n    Toolchain path (/home/&lt;user&gt;/x-tools/aarch64-beagleplay-linux-musl)\n        # Replace &lt;user&gt; with your username\n\n    Toolchain prefix (aarch64-beagleplay-linux-musl)\n\n    External toolchain gcc version (14.x)\n    External toolchain kernel headers series (6.6.x or later)\n    External toolchain C library (musl)\n\n    [*] Toolchain has SSP support?\n    [*] Toolchain has C++ support?\n</code></pre> <p>Important (like knowing where your towel is): Adjust paths to match your actual toolchain location.</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#kernel-configuration","title":"Kernel Configuration","text":"<pre><code>Kernel ---&gt;\n    [*] Linux Kernel\n\n    Kernel version ---&gt;\n        (X) Custom version\n        (6.6.52) Kernel version\n            # Use the version from your Lab 4 kernel\n\n    Custom kernel patches ---&gt;\n        board/beagleplay/training/0001-Custom-DTS-for-Bootlin-lab.patch\n\n    Kernel configuration ---&gt;\n        (X) Using a custom (def)config file\n        (board/beagleplay/training/linux.config) Configuration file path\n\n    Kernel binary format ---&gt;\n        (X) Image.gz\n\n    [*] Build a Device Tree Blob (DTB)\n        (ti/k3-am625-beagleplay-custom) In-tree Device Tree Source file names\n            # Without .dts extension, relative to arch/arm64/boot/dts/\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#target-packages-core-system","title":"Target Packages - Core System","text":"<pre><code>Target packages ---&gt;\n    BusyBox ---&gt;\n        [*] (default) # Keep BusyBox enabled with default config\n\n    Audio and video applications ---&gt;\n        [*] alsa-utils\n            alsa-utils selection ---&gt;\n                [*] speaker-test\n                [ ] Disable all other options\n\n        [*] mpd\n            *** MPD configuration ***\n            Audio support ---&gt;\n                [*] alsa\n            Input format support ---&gt;\n                [*] vorbis\n            Network protocols support ---&gt;\n                [*] tcp sockets\n\n        [*] mpc (MPD client)\n\n    Hardware handling ---&gt;\n        [*] evtest\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#filesystem-images","title":"Filesystem Images","text":"<pre><code>Filesystem images ---&gt;\n    [*] tar the root filesystem\n        Compression method (no compression)\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#system-configuration","title":"System Configuration","text":"<pre><code>System configuration ---&gt;\n    Root filesystem overlay directories ---&gt;\n        board/beagleplay/training/rootfs-overlay\n\n    Root password (leave empty for no password)\n\n    /dev management (Dynamic using devtmpfs only)\n\n    [*] Enable root login with password\n    [ ] Run a getty (login prompt) after boot\n        # We'll use serial console directly\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#save-configuration","title":"Save Configuration","text":"<p>Press <code>Exit</code> repeatedly until asked to save, then select <code>Yes</code>.</p> <p>Verification Checklist:</p> <ul> <li>[ ] Target architecture set to ARM64 Cortex-A53</li> <li>[ ] External toolchain configured with correct path</li> <li>[ ] Kernel version and configuration specified</li> <li>[ ] Custom DTS patch included</li> <li>[ ] Required packages selected (alsa-utils, mpd, mpc, evtest)</li> <li>[ ] Root filesystem overlay path set</li> <li>[ ] Configuration saved to <code>.config</code></li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-3-root-filesystem-overlay","title":"Section 3: Root Filesystem Overlay","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#create-module-loading-script","title":"Create Module Loading Script","text":"<p>Buildroot uses a different init system than our manual setup, so we'll automate module loading.</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/board/beagleplay/training/rootfs-overlay\n\n# Create init.d directory\nmkdir -p etc/init.d\n\n# Create module loading script\ncat &gt; etc/init.d/S03modprobe &lt;&lt; 'EOF'\n#!/bin/sh\n\ncase \"$1\" in\n    start)\n        echo \"Loading kernel modules...\"\n        modprobe snd-usb-audio\n        ;;\n    stop)\n        ;;\n    restart|reload)\n        ;;\n    *)\n        echo \"Usage: $0 {start|stop|restart}\"\n        exit 1\nesac\n\nexit 0\nEOF\n\n# Make executable\nchmod +x etc/init.d/S03modprobe\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#add-mpd-configuration","title":"Add MPD Configuration","text":"<pre><code># Download music files for testing (if not already present)\ncd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/board/beagleplay/training/rootfs-overlay\n\n# Create MPD music directory\nmkdir -p var/lib/mpd/music\n\n# Copy music files from previous labs (or download samples)\n# For this lab, we'll create placeholder structure\n# In production, you'd include actual audio files\n\n# Create MPD configuration\nmkdir -p etc\ncat &gt; etc/mpd.conf &lt;&lt; 'EOF'\nmusic_directory     \"/var/lib/mpd/music\"\nplaylist_directory  \"/var/lib/mpd/playlists\"\ndb_file             \"/var/lib/mpd/database\"\nlog_file            \"/var/log/mpd.log\"\npid_file            \"/var/run/mpd.pid\"\nstate_file          \"/var/lib/mpd/state\"\nsticker_file        \"/var/lib/mpd/sticker.sql\"\n\nbind_to_address     \"any\"\nport                \"6600\"\n\naudio_output {\n    type            \"alsa\"\n    name            \"USB Audio Device\"\n    mixer_type      \"software\"\n}\nEOF\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Module loading script created and executable</li> <li>[ ] MPD configuration file created</li> <li>[ ] Overlay directory structure prepared</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-4-build-the-system","title":"Section 4: Build the System","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#start-the-build","title":"Start the Build","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Start build (this will take 20-60 minutes)\nmake -j$(nproc)\n</code></pre> <p>Expected Progress:</p> <pre><code>&gt;&gt;&gt; host-pkgconf 2.0.3 Downloading\n&gt;&gt;&gt; host-pkgconf 2.0.3 Extracting\n&gt;&gt;&gt; host-pkgconf 2.0.3 Configuring\n&gt;&gt;&gt; host-pkgconf 2.0.3 Building\n&gt;&gt;&gt; host-pkgconf 2.0.3 Installing to host directory\n&gt;&gt;&gt; linux 6.6.52 Downloading\n&gt;&gt;&gt; linux 6.6.52 Extracting\n&gt;&gt;&gt; linux 6.6.52 Patching\n&gt;&gt;&gt; linux 6.6.52 Configuring\n&gt;&gt;&gt; linux 6.6.52 Building\n&gt;&gt;&gt; linux 6.6.52 Installing to images directory\n&gt;&gt;&gt; busybox 1.36.1 Downloading\n...\n&gt;&gt;&gt; Generating filesystem image rootfs.tar\n&gt;&gt;&gt; Generating root filesystem image rootfs.tar\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#explore-build-output","title":"Explore Build Output","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Build directory (extracted and compiled packages)\nls output/build/\n# Shows: busybox-1.36.1/ linux-6.6.52/ mpd-0.23.14/ ...\n\n# Host tools (tools used during build)\nls output/host/\n# Shows: bin/ sbin/ lib/ share/ usr/ ...\n\n# Staging directory (headers, libraries for compilation)\nls output/staging/\n# Shows: usr/include/ usr/lib/ ...\n\n# Target root filesystem (before packaging)\nls output/target/\n# Shows: bin/ etc/ lib/ sbin/ usr/ var/ ...\n\n# Final images\nls output/images/\n# Shows: Image.gz  k3-am625-beagleplay-custom.dtb  rootfs.tar\n</code></pre> <p>Understanding Output Directories:</p> Directory Purpose Size Usage <code>output/build/</code> Source and build trees Large (GB) Package compilation <code>output/host/</code> Host tools Medium (MB) Build tools (pkgconf, genext2fs) <code>output/staging/</code> Development files Medium Headers, libraries for linking <code>output/target/</code> Target filesystem Small (MB) Actual root filesystem content <code>output/images/</code> Final images Small Deployable artifacts <p>Verification Checklist:</p> <ul> <li>[ ] Build completed without errors</li> <li>[ ] <code>output/images/Image.gz</code> exists (kernel)</li> <li>[ ] <code>output/images/k3-am625-beagleplay-custom.dtb</code> exists</li> <li>[ ] <code>output/images/rootfs.tar</code> exists (root filesystem)</li> <li>[ ] Module loading script present in <code>output/target/etc/init.d/</code></li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-5-deploy-and-test","title":"Section 5: Deploy and Test","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#create-nfs-root-directory","title":"Create NFS Root Directory","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab\nmkdir -p nfsroot\n\n# Extract root filesystem\ncd nfsroot\ntar xvf ../buildroot/output/images/rootfs.tar\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#update-nfs-exports","title":"Update NFS Exports","text":"<pre><code># Edit /etc/exports\nsudo vi /etc/exports\n\n# Add line:\n# /home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot *(rw,no_root_squash,no_subtree_check)\n\n# Reload NFS exports\nsudo exportfs -ra\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#update-kernel-and-dtb","title":"Update Kernel and DTB","text":"<pre><code># Copy to TFTP directory\ncp $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/images/Image.gz \\\n   /srv/tftp/\n\ncp $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/images/k3-am625-beagleplay-custom.dtb \\\n   /srv/tftp/\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#boot-beagleplay","title":"Boot BeaglePlay","text":"<p>Update U-Boot to use Buildroot NFS root:</p> <pre><code># On U-Boot console\n=&gt; setenv nfsroot /home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot\n=&gt; setenv bootargs console=ttyS2,115200 root=/dev/nfs ip=192.168.0.100:::::eth0 nfsroot=${serverip}:${nfsroot},nfsvers=3,tcp rw\n=&gt; saveenv\n=&gt; boot\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#verify-system-boot","title":"Verify System Boot","text":"<pre><code># On BeaglePlay, after boot\n\n# Check kernel version\nuname -a\n\n# Check loaded modules\nlsmod | grep snd\n# Should show snd_usb_audio if USB device is plugged in\n\n# Check BusyBox version\nbusybox --help\n\n# Verify package presence\nwhich speaker-test\nwhich evtest\nwhich mpd\nwhich mpc\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] NFS root created from Buildroot tarball</li> <li>[ ] NFS exports updated and reloaded</li> <li>[ ] Kernel and DTB copied to TFTP</li> <li>[ ] BeaglePlay boots from Buildroot root filesystem</li> <li>[ ] USB audio module loads automatically</li> <li>[ ] BusyBox and selected packages present</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-6-test-audio-with-mpd","title":"Section 6: Test Audio with MPD","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#prepare-music-files","title":"Prepare Music Files","text":"<p>First, add actual music files to the overlay (for future builds) or directly to the NFS root:</p> <pre><code># On workstation\ncd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot/var/lib/mpd/music\n\n# Copy OGG/MP3 files (sample music)\n# For testing, you can use free music from:\n# https://freemusicarchive.org/ or\n# https://incompetech.com/\n\n# Example (if you have sample.ogg):\ncp ~/Downloads/sample.ogg .\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#start-mpd-and-test-playback","title":"Start MPD and Test Playback","text":"<pre><code># On BeaglePlay\n\n# Check if MPD is running\nps | grep mpd\n\n# If not running, start it\n/etc/init.d/S95mpd start\n\n# Update MPD database\nmpc update\n\n# Wait a few seconds, then check indexed files\nmpc listall\n\n# Expected output:\n# sample.ogg\n# ...\n\n# Add all files to playlist\nmpc add /\n\n# Start playback\nmpc play\n\n# Control playback\nmpc pause\nmpc next\nmpc volume +10\nmpc volume -5\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#check-mpd-logs","title":"Check MPD Logs","text":"<pre><code># View MPD log\ncat /var/log/mpd.log\n\n# Should show:\n# Jan  1 00:00 : update: added /sample.ogg\n# Jan  1 00:01 : player: played \"sample.ogg\"\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] MPD service running</li> <li>[ ] Music files indexed by MPD</li> <li>[ ] Playback functional with <code>mpc play</code></li> <li>[ ] Volume and navigation controls work</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-7-adding-custom-package-nunchuk-driver","title":"Section 7: Adding Custom Package - Nunchuk Driver","text":"<p>Now we'll create a Buildroot package for our Nunchuk driver.</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#create-package-directory","title":"Create Package Directory","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\nmkdir -p package/nunchuk-driver\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#create-configin","title":"Create Config.in","text":"<pre><code>cat &gt; package/nunchuk-driver/Config.in &lt;&lt; 'EOF'\nconfig BR2_PACKAGE_NUNCHUK_DRIVER\n    bool \"nunchuk-driver\"\n    depends on BR2_LINUX_KERNEL\n    help\n      Linux kernel module for the I2C Nintendo Wii Nunchuk.\n\n      Provides input device interface for Nunchuk joystick\n      and buttons when connected via I2C bus.\n\n      https://github.com/bootlin/training-materials\nEOF\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#create-package-makefile","title":"Create Package Makefile","text":"<pre><code>cat &gt; package/nunchuk-driver/nunchuk-driver.mk &lt;&lt; 'EOF'\n################################################################################\n#\n# nunchuk-driver\n#\n################################################################################\n\nNUNCHUK_DRIVER_VERSION = 1.0\nNUNCHUK_DRIVER_SITE = $(HOME)/embedded-linux-beagleplay-labs/hardware/nunchuk-driver\nNUNCHUK_DRIVER_SITE_METHOD = local\nNUNCHUK_DRIVER_LICENSE = GPL-2.0\n\n$(eval $(kernel-module))\n$(eval $(generic-package))\nEOF\n</code></pre> <p>The Guide notes: Adjust <code>NUNCHUK_DRIVER_SITE</code> to point to your actual driver location.</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#integrate-into-buildroot-menu","title":"Integrate into Buildroot Menu","text":"<pre><code># Edit package/Config.in\nvi package/Config.in\n\n# Find the \"Hardware handling\" menu section\n# Add before \"menu \"Hardware handling\"\":\n\n# Around line 1200-1300 (search for \"menu \"Hardware handling\"\")\n# Add this line just before the nvidia-driver line:\n#     source \"package/nunchuk-driver/Config.in\"\n</code></pre> <p>Using editor:</p> <p>Find this section: <pre><code>menu \"Hardware handling\"\n    source \"package/acsccid/Config.in\"\n    ...\n    source \"package/nvidia-driver/Config.in\"  # Add BEFORE this line\n</code></pre></p> <p>Add: <pre><code>    source \"package/nunchuk-driver/Config.in\"\n</code></pre></p>"},{"location":"labs/embedded-linux/lab08-buildroot/#enable-nunchuk-package","title":"Enable Nunchuk Package","text":"<pre><code># Reconfigure Buildroot\nmake menuconfig\n\n# Navigate to:\n# Target packages ---&gt;\n#     Hardware handling ---&gt;\n#         [*] nunchuk-driver\n\n# Save and exit\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#copy-driver-source","title":"Copy Driver Source","text":"<p>Ensure the driver source is accessible:</p> <pre><code># Verify driver exists\nls $HOME/embedded-linux-beagleplay-labs/hardware/nunchuk-driver/\n\n# Should show: nunchuk.c  Makefile\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#rebuild-with-nunchuk-module","title":"Rebuild with Nunchuk Module","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Rebuild (incremental - much faster)\nmake\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#update-nfs-root","title":"Update NFS Root","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot\n\n# Remove old content\nrm -rf *\n\n# Extract new rootfs\ntar xvf ../buildroot/output/images/rootfs.tar\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#auto-load-nunchuk-module","title":"Auto-Load Nunchuk Module","text":"<p>Update the module loading script:</p> <pre><code># Edit overlay\ncd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/board/beagleplay/training/rootfs-overlay\n\nvi etc/init.d/S03modprobe\n\n# Modify to add nunchuk:\n</code></pre> <pre><code>#!/bin/sh\n\ncase \"$1\" in\n    start)\n        echo \"Loading kernel modules...\"\n        modprobe snd-usb-audio\n        modprobe nunchuk\n        ;;\n    stop)\n        ;;\n    restart|reload)\n        ;;\n    *)\n        echo \"Usage: $0 {start|stop|restart}\"\n        exit 1\nesac\n\nexit 0\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#rebuild-and-test","title":"Rebuild and Test","text":"<pre><code># Rebuild Buildroot\ncd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\nmake\n\n# Update NFS root\ncd ../nfsroot\nrm -rf *\ntar xvf ../buildroot/output/images/rootfs.tar\n\n# Reboot BeaglePlay\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#verify-nunchuk-driver","title":"Verify Nunchuk Driver","text":"<pre><code># On BeaglePlay, after boot\n\n# Check if nunchuk module is loaded\nlsmod | grep nunchuk\n\n# Check I2C device binding\nls -l /sys/bus/i2c/drivers/nunchuk/\n# Should show: 3-0052 -&gt; ../../../../devices/.../i2c-3/3-0052\n\n# Test with evtest\nevtest\n\n# Select Nunchuk device, press buttons to see events\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Nunchuk package created in <code>package/nunchuk-driver/</code></li> <li>[ ] Package integrated into Buildroot menu</li> <li>[ ] Package enabled in configuration</li> <li>[ ] Build includes nunchuk module</li> <li>[ ] Module loads automatically at boot</li> <li>[ ] Nunchuk input device functional</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-8-dependency-analysis","title":"Section 8: Dependency Analysis","text":"<p>Buildroot provides tools to visualize package dependencies.</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#install-graphviz","title":"Install Graphviz","text":"<pre><code># On workstation\nsudo apt install graphviz\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#generate-dependency-graph","title":"Generate Dependency Graph","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Generate graph\nmake graph-depends\n\n# View PDF\nevince output/graphs/graph-depends.pdf\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#analyze-dependencies","title":"Analyze Dependencies","text":"<p>The graph shows why certain packages were built. Key observations:</p> <ul> <li>MPD requires:</li> <li><code>meson</code> (host tool)</li> <li><code>python3</code> (host tool for meson)</li> <li><code>alsa-lib</code></li> <li> <p><code>libvorbis</code> (for OGG support)</p> </li> <li> <p>alsa-utils requires:</p> </li> <li><code>alsa-lib</code></li> <li> <p><code>ncurses</code> (for interactive tools)</p> </li> <li> <p>Nunchuk driver requires:</p> </li> <li>Linux kernel</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#package-size-analysis","title":"Package Size Analysis","text":"<pre><code># Generate package size statistics\nmake graph-size\n\n# View results\nevince output/graphs/graph-size.pdf\n</code></pre> <p>This shows which packages consume the most storage.</p> <p>Verification Checklist:</p> <ul> <li>[ ] Dependency graph generated successfully</li> <li>[ ] Visualized with <code>evince</code> or PDF viewer</li> <li>[ ] Understood major dependency chains</li> </ul>"},{"location":"labs/embedded-linux/lab08-buildroot/#section-9-buildroot-best-practices","title":"Section 9: Buildroot Best Practices","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#external-tree-out-of-tree-configuration","title":"External Tree (Out-of-Tree Configuration)","text":"<p>For production, use an external tree to keep customizations separate:</p> <pre><code># Create external tree\nmkdir -p $HOME/embedded-linux-beagleplay-labs/buildroot-external/beagleplay\n\ncd $HOME/embedded-linux-beagleplay-labs/buildroot-external/beagleplay\n\n# Create external.desc\ncat &gt; external.desc &lt;&lt; 'EOF'\nname: BEAGLEPLAY\ndesc: BeaglePlay custom external tree\nEOF\n\n# Create external.mk\ntouch external.mk\n\n# Create Config.in\ncat &gt; Config.in &lt;&lt; 'EOF'\nsource \"$BR2_EXTERNAL_BEAGLEPLAY_PATH/package/nunchuk-driver/Config.in\"\nEOF\n\n# Move board files\nmv $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/board/beagleplay \\\n   board/\n\n# Move package\nmkdir -p package\nmv $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/package/nunchuk-driver \\\n   package/\n</code></pre> <p>Use external tree:</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Configure with external tree\nmake BR2_EXTERNAL=$HOME/embedded-linux-beagleplay-labs/buildroot-external/beagleplay menuconfig\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#configuration-fragments","title":"Configuration Fragments","text":"<p>For kernel and BusyBox, use configuration fragments instead of full configs:</p> <pre><code># Kernel fragment example\ncat &gt; board/beagleplay/training/linux-fragment.config &lt;&lt; 'EOF'\nCONFIG_GPIO_SYSFS=y\nCONFIG_LEDS_CLASS=y\nCONFIG_LEDS_GPIO=y\nCONFIG_SND_USB_AUDIO=m\nEOF\n</code></pre> <p>Reference in Buildroot menuconfig: <pre><code>Kernel ---&gt;\n    Additional fragments for the kernel configuration\n        (board/beagleplay/training/linux-fragment.config)\n</code></pre></p>"},{"location":"labs/embedded-linux/lab08-buildroot/#defconfig-files","title":"Defconfig Files","text":"<p>Save your configuration as a defconfig:</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\n# Save defconfig\nmake savedefconfig BR2_DEFCONFIG=configs/beagleplay_defconfig\n\n# Later, restore with:\n# make beagleplay_defconfig\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#problem-external-toolchain-not-found","title":"Problem: External toolchain not found","text":"<p>Error:</p> <pre><code>Incorrect selection of the C library\n</code></pre> <p>Solution:</p> <ol> <li>Verify toolchain path:</li> </ol> <pre><code>ls /home/&lt;user&gt;/x-tools/aarch64-beagleplay-linux-musl/bin/\n# Should show: aarch64-beagleplay-linux-musl-gcc ...\n</code></pre> <ol> <li>Check toolchain configuration in menuconfig:</li> <li>Toolchain path matches actual location</li> <li>Toolchain prefix is correct</li> <li> <p>GCC version matches</p> </li> <li> <p>Test toolchain manually:</p> </li> </ol> <pre><code>/home/&lt;user&gt;/x-tools/aarch64-beagleplay-linux-musl/bin/aarch64-beagleplay-linux-musl-gcc --version\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#problem-kernel-build-fails","title":"Problem: Kernel build fails","text":"<p>Error:</p> <pre><code>&gt;&gt;&gt; linux 6.6.52 Building\nERROR: ...\n</code></pre> <p>Solutions:</p> <ol> <li>Missing dependencies:</li> </ol> <pre><code>sudo apt install bc bison flex libssl-dev libncurses-dev\n</code></pre> <ol> <li>Kernel config mismatch:</li> </ol> <p>Verify <code>board/beagleplay/training/linux.config</code> is a valid ARM64 config:</p> <pre><code>grep \"CONFIG_ARM64=y\" board/beagleplay/training/linux.config\n</code></pre> <ol> <li>Patch application failed:</li> </ol> <p>Check if custom DTS patch applies cleanly:</p> <pre><code>cd output/build/linux-6.6.52\npatch -p1 --dry-run &lt; ../../../board/beagleplay/training/0001-Custom-DTS-for-Bootlin-lab.patch\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#problem-package-not-found-in-menu","title":"Problem: Package not found in menu","text":"<p>Symptom: Nunchuk driver doesn't appear in <code>Hardware handling</code> menu.</p> <p>Solution:</p> <ol> <li> <p>Verify <code>package/nunchuk-driver/Config.in</code> exists</p> </li> <li> <p>Check <code>package/Config.in</code> includes the line:</p> </li> </ol> <pre><code>grep \"nunchuk-driver\" package/Config.in\n</code></pre> <p>Should show: <pre><code>    source \"package/nunchuk-driver/Config.in\"\n</code></pre></p> <ol> <li>Regenerate menuconfig cache:</li> </ol> <pre><code>make menuconfig\n# Exit and re-enter\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#problem-module-version-mismatch","title":"Problem: Module version mismatch","text":"<p>Error:</p> <pre><code>insmod: ERROR: could not insert module nunchuk.ko: Invalid module format\n</code></pre> <p>Cause: Module compiled against different kernel version.</p> <p>Solution:</p> <p>Rebuild both kernel and modules:</p> <pre><code>make linux-dirclean\nmake nunchuk-driver-dirclean\nmake\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#problem-nfs-root-is-outdated","title":"Problem: NFS root is outdated","text":"<p>Symptom: Changes don't appear after rebuild.</p> <p>Solution:</p> <p>Always re-extract rootfs.tar:</p> <pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot\nrm -rf *\ntar xvf ../buildroot/output/images/rootfs.tar\n</code></pre>"},{"location":"labs/embedded-linux/lab08-buildroot/#advanced-challenges","title":"Advanced Challenges","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#challenge-1-create-buildroot-defconfig","title":"Challenge 1: Create Buildroot Defconfig","text":"<p>Save your complete configuration as a reusable defconfig for BeaglePlay.</p> <p>Steps: 1. <code>make savedefconfig BR2_DEFCONFIG=configs/beagleplay_training_defconfig</code> 2. Test restoration: <code>make clean &amp;&amp; make beagleplay_training_defconfig &amp;&amp; make</code></p>"},{"location":"labs/embedded-linux/lab08-buildroot/#challenge-2-add-custom-init-system","title":"Challenge 2: Add Custom Init System","text":"<p>Replace BusyBox init with systemd or OpenRC.</p> <p>Hint: <pre><code>System configuration ---&gt;\n    Init system (systemd)\n</code></pre></p> <p>Note: systemd requires glibc, not musl!</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#challenge-3-generate-sd-card-image","title":"Challenge 3: Generate SD Card Image","text":"<p>Configure Buildroot to create a complete SD card image with all partitions.</p> <p>Hint: <pre><code>Filesystem images ---&gt;\n    [*] ext4 root filesystem\n    [ ] tar the root filesystem  # Disable\n    [*] genimage\n</code></pre></p> <p>Create <code>genimage.cfg</code> for partition layout.</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#challenge-4-cross-compile-application","title":"Challenge 4: Cross-Compile Application","text":"<p>Create a custom Buildroot package for the Nunchuk MPD client from Lab 9.</p> <p>Structure: - <code>package/nunchuk-mpd-client/Config.in</code> - <code>package/nunchuk-mpd-client/nunchuk-mpd-client.mk</code> - Use <code>NUNCHUK_MPD_CLIENT_DEPENDENCIES = libmpdclient</code></p>"},{"location":"labs/embedded-linux/lab08-buildroot/#challenge-5-multi-config-build","title":"Challenge 5: Multi-Config Build","text":"<p>Set up configurations for: - Development (NFS root, debug symbols, strace, gdb) - Production (SquashFS, stripped, minimal)</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#what-youve-learned","title":"What You've Learned","text":"<p>By completing this lab, you've mastered:</p> <p>\u2705 Buildroot Architecture: - Understood Buildroot workflow (download \u2192 build \u2192 install \u2192 image) - Navigated output directories (build, host, staging, target, images) - Understood difference between target and staging</p> <p>\u2705 Configuration Management: - Used <code>make menuconfig</code> to configure system - Integrated external toolchain - Configured kernel with custom config and patches - Selected target packages</p> <p>\u2705 Package Management: - Enabled built-in packages (BusyBox, alsa-utils, mpd) - Created custom package for out-of-tree kernel module - Integrated package into Buildroot menu system - Used <code>$(kernel-module)</code> and <code>$(generic-package)</code> infrastructures</p> <p>\u2705 Root Filesystem Customization: - Created root filesystem overlay - Added custom init scripts - Configured services (MPD, module loading) - Managed configuration files</p> <p>\u2705 Build System: - Performed full Buildroot build - Did incremental rebuilds for efficiency - Cleaned specific packages - Generated filesystem images</p> <p>\u2705 Dependency Analysis: - Generated dependency graphs - Analyzed package relationships - Identified build-time vs. runtime dependencies - Understood size contributions</p> <p>\u2705 Integration and Testing: - Deployed Buildroot-generated system via NFS - Tested all components (kernel, modules, packages) - Verified functionality (audio, input devices, modules)</p> <p>\u2705 Best Practices: - Root filesystem overlays for customization - External tree for maintainability - Defconfig files for reproducibility - Configuration fragments for modularity</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#going-further","title":"Going Further","text":""},{"location":"labs/embedded-linux/lab08-buildroot/#recommended-reading","title":"Recommended Reading","text":"<p>Buildroot Documentation: - Buildroot User Manual: <code>docs/manual/manual.html</code> - Package development guide - Buildroot internals</p> <p>Advanced Topics: - Creating custom package infrastructures - Licensing compliance with <code>make legal-info</code> - SDK generation for application developers</p>"},{"location":"labs/embedded-linux/lab08-buildroot/#next-steps","title":"Next Steps","text":"<p>In Lab 9: Application Development and Debugging, you'll: - Cross-compile custom applications - Debug with gdb, gdbserver, strace, ltrace - Use Visual Studio Code for remote debugging - Profile with perf - Implement MPD client controlled by Nunchuk</p> <p>Estimated Completion Time: 4-5 hours</p> <p>Difficulty: \u2b50\u2b50\u2b50\u2b50\u2606 (Advanced)</p> <p>Prerequisites Met: \u2705 Lab 7 (Block Filesystems)</p> <p>Leads to: Lab 9 (Application Development and Debugging)</p>"},{"location":"labs/embedded-linux/lab09-application-development/","title":"Lab 9: Application Development and Debugging","text":""},{"location":"labs/embedded-linux/lab09-application-development/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/embedded-linux/lab09-application-development/#objectives","title":"Objectives","text":"<p>Master cross-platform application development and debugging techniques:</p> <ul> <li>Cross-compile standalone applications for ARM64</li> <li>Use pkg-config for library dependency management</li> <li>Debug applications with strace and ltrace</li> <li>Remote debugging with gdb and gdbserver</li> <li>Visual Studio Code integration for embedded debugging</li> <li>System profiling with perf</li> <li>Implement real-world application: Nunchuk-controlled MPD client</li> <li>Analyze core dumps for post-mortem debugging</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 8 (Buildroot)</li> <li>Running Buildroot system with NFS root</li> <li>USB audio device connected</li> <li>Nunchuk connected to I2C bus</li> <li>Understanding of C programming</li> <li>Basic debugging concepts</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#lab-duration","title":"Lab Duration","text":"<p>Approximately 5-6 hours</p>"},{"location":"labs/embedded-linux/lab09-application-development/#application-architecture","title":"Application Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Nunchuk MPD Client Application                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUser Input (Nunchuk):                   Audio Output:\n  Joystick UP    \u2192 Volume +5%             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  Joystick DOWN  \u2192 Volume -5%             \u2502  USB Audio  \u2502\n  Joystick LEFT  \u2192 Previous track         \u2502   Device    \u2502\n  Joystick RIGHT \u2192 Next track             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Z button       \u2192 Pause/Play                    \u2502\n  C button       \u2192 Quit client                   \u2502\n                                           \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2193                                 \u2502    MPD     \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2502  (Server)  \u2502\n  \u2502  Input Layer    \u2502                      \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u2502 /dev/input/eventX\u2502                           \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                            \u2502\n           \u2502                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2193                              \u2502  libmpdclient\u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502   (Library)  \u2502\n  \u2502 Nunchuk Client  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524              \u2502\n  \u2502  Application    \u2502  MPD Protocol      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u2502  (nunchuk-mpd-  \u2502  (Port 6600)\n  \u2502   client)       \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nLibraries:\n- libmpdclient: MPD client library\n- libc (musl): C standard library\n\nSystem Calls:\n- open(), read(), write() \u2192 Input device access\n- socket(), connect(), send(), recv() \u2192 MPD communication\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#environment-setup","title":"Environment Setup","text":""},{"location":"labs/embedded-linux/lab09-application-development/#working-directory","title":"Working Directory","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs\nmkdir -p appdev\ncd appdev\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#verify-buildroot-system","title":"Verify Buildroot System","text":"<p>Ensure your BeaglePlay is booted with the Buildroot NFS root from Lab 8:</p> <pre><code># On BeaglePlay\nmount | grep nfs\n\n# Verify MPD and Nunchuk\nps | grep mpd\nlsmod | grep nunchuk\nls /dev/input/event*\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#section-1-third-party-library-integration","title":"Section 1: Third-Party Library Integration","text":""},{"location":"labs/embedded-linux/lab09-application-development/#understanding-library-dependencies","title":"Understanding Library Dependencies","text":"<p>Our application depends on <code>libmpdclient</code> to communicate with MPD. Buildroot hasn't built this yet.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#add-libmpdclient-to-buildroot","title":"Add libmpdclient to Buildroot","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\nmake menuconfig\n</code></pre> <p>Enable libmpdclient:</p> <pre><code>Target packages ---&gt;\n    Audio and video applications ---&gt;\n        [*] libmpdclient\n</code></pre> <p>Save and exit.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#rebuild-buildroot","title":"Rebuild Buildroot","text":"<pre><code># Incremental build (only libmpdclient and dependencies)\nmake\n\n# Update NFS root\ncd ../nfsroot\nrm -rf *\ntar xvf ../buildroot/output/images/rootfs.tar\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#verify-library-installation","title":"Verify Library Installation","text":"<pre><code># On BeaglePlay (after reboot)\nls -l /usr/lib/libmpdclient.*\n\n# Expected:\n# lrwxrwxrwx ... libmpdclient.so -&gt; libmpdclient.so.2\n# lrwxrwxrwx ... libmpdclient.so.2 -&gt; libmpdclient.so.2.22\n# -rwxr-xr-x ... libmpdclient.so.2.22\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] libmpdclient added to Buildroot configuration</li> <li>[ ] Buildroot rebuilt with libmpdclient</li> <li>[ ] NFS root updated</li> <li>[ ] Library files present on target in <code>/usr/lib/</code></li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-2-cross-compiling-with-pkg-config","title":"Section 2: Cross-Compiling with pkg-config","text":""},{"location":"labs/embedded-linux/lab09-application-development/#create-application-source","title":"Create Application Source","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/appdev\n\n# Create nunchuk-mpd-client.c\nvi nunchuk-mpd-client.c\n</code></pre> <p>nunchuk-mpd-client.c:</p> <pre><code>/* nunchuk-mpd-client.c - Control MPD playback with Nunchuk */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;linux/input.h&gt;\n#include &lt;mpd/client.h&gt;\n#include &lt;dirent.h&gt;\n\n#define INPUT_DEVICE_PREFIX \"/dev/input/event\"\n\n/* Find Nunchuk input device */\nstatic int find_nunchuk_device(void) {\n    DIR *dir;\n    struct dirent *entry;\n    char device_path[256];\n    char device_name[256];\n    int fd;\n\n    dir = opendir(\"/dev/input\");\n    if (!dir) {\n        perror(\"Failed to open /dev/input\");\n        return -1;\n    }\n\n    while ((entry = readdir(dir)) != NULL) {\n        if (strncmp(entry-&gt;d_name, \"event\", 5) != 0)\n            continue;\n\n        snprintf(device_path, sizeof(device_path), \"/dev/input/%s\", entry-&gt;d_name);\n\n        fd = open(device_path, O_RDONLY);\n        if (fd &lt; 0)\n            continue;\n\n        if (ioctl(fd, EVIOCGNAME(sizeof(device_name)), device_name) &gt;= 0) {\n            if (strstr(device_name, \"Nunchuk\") != NULL) {\n                closedir(dir);\n                printf(\"Found Nunchuk at %s\\n\", device_path);\n                return fd;\n            }\n        }\n\n        close(fd);\n    }\n\n    closedir(dir);\n    fprintf(stderr, \"ERROR: didn't manage to find the Nunchuk device in /dev/input. \"\n                    \"Is the Nunchuk driver loaded?\\n\");\n    return -1;\n}\n\nint main(int argc, char *argv[]) {\n    struct input_event ev;\n    int nunchuk_fd;\n    struct mpd_connection *conn;\n    int joystick_x_prev = 0;\n    int joystick_y_prev = 0;\n\n    printf(\"Nunchuk MPD Client starting...\\n\");\n\n    /* Find and open Nunchuk device */\n    nunchuk_fd = find_nunchuk_device();\n    if (nunchuk_fd &lt; 0) {\n        return EXIT_FAILURE;\n    }\n\n    /* Connect to MPD */\n    conn = mpd_connection_new(\"localhost\", 6600, 0);\n    if (conn == NULL) {\n        fprintf(stderr, \"Failed to create MPD connection\\n\");\n        close(nunchuk_fd);\n        return EXIT_FAILURE;\n    }\n\n    if (mpd_connection_get_error(conn) != MPD_ERROR_SUCCESS) {\n        fprintf(stderr, \"MPD connection error: %s\\n\",\n                mpd_connection_get_error_message(conn));\n        mpd_connection_free(conn);\n        close(nunchuk_fd);\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Connected to MPD. Use Nunchuk to control playback:\\n\");\n    printf(\"  Joystick UP:    Volume +5%%\\n\");\n    printf(\"  Joystick DOWN:  Volume -5%%\\n\");\n    printf(\"  Joystick LEFT:  Previous track\\n\");\n    printf(\"  Joystick RIGHT: Next track\\n\");\n    printf(\"  Z button:       Pause/Play\\n\");\n    printf(\"  C button:       Quit\\n\\n\");\n\n    /* Event loop */\n    while (1) {\n        ssize_t bytes = read(nunchuk_fd, &amp;ev, sizeof(ev));\n        if (bytes != sizeof(ev)) {\n            perror(\"read\");\n            break;\n        }\n\n        /* Process only key and absolute axis events */\n        if (ev.type == EV_KEY &amp;&amp; ev.value == 1) {  /* Button press */\n            if (ev.code == BTN_Z) {\n                /* Z button: toggle pause/play */\n                printf(\"Z pressed: Toggle playback\\n\");\n                mpd_run_toggle_pause(conn);\n            } else if (ev.code == BTN_C) {\n                /* C button: quit */\n                printf(\"C pressed: Quitting\\n\");\n                break;\n            }\n        } else if (ev.type == EV_ABS) {  /* Joystick movement */\n            struct mpd_status *status;\n            int volume;\n\n            if (ev.code == ABS_Y) {\n                /* Joystick Y axis: volume control */\n                if (ev.value &lt; 100 &amp;&amp; joystick_y_prev &gt;= 100) {\n                    /* DOWN */\n                    status = mpd_run_status(conn);\n                    if (status) {\n                        volume = mpd_status_get_volume(status);\n                        mpd_status_free(status);\n\n                        volume -= 5;\n                        if (volume &lt; 0) volume = 0;\n\n                        mpd_run_set_volume(conn, volume);\n                        printf(\"Volume down: %d%%\\n\", volume);\n                    }\n                } else if (ev.value &gt; 150 &amp;&amp; joystick_y_prev &lt;= 150) {\n                    /* UP */\n                    status = mpd_run_status(conn);\n                    if (status) {\n                        volume = mpd_status_get_volume(status);\n                        mpd_status_free(status);\n\n                        volume += 5;\n                        if (volume &gt; 100) volume = 100;\n\n                        mpd_run_set_volume(conn, volume);\n                        printf(\"Volume up: %d%%\\n\", volume);\n                    }\n                }\n                joystick_y_prev = ev.value;\n            } else if (ev.code == ABS_X) {\n                /* Joystick X axis: track navigation */\n                if (ev.value &lt; 80 &amp;&amp; joystick_x_prev &gt;= 80) {\n                    /* LEFT */\n                    printf(\"Previous track\\n\");\n                    mpd_run_previous(conn);\n                } else if (ev.value &gt; 180 &amp;&amp; joystick_x_prev &lt;= 180) {\n                    /* RIGHT */\n                    printf(\"Next track\\n\");\n                    mpd_run_next(conn);\n                }\n                joystick_x_prev = ev.value;\n            }\n        }\n\n        /* Check for MPD errors */\n        if (mpd_connection_get_error(conn) != MPD_ERROR_SUCCESS) {\n            fprintf(stderr, \"MPD error: %s\\n\",\n                    mpd_connection_get_error_message(conn));\n            mpd_connection_clear_error(conn);\n        }\n    }\n\n    /* Cleanup */\n    mpd_connection_free(conn);\n    close(nunchuk_fd);\n\n    printf(\"Client terminated.\\n\");\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#configure-pkg-config-for-cross-compilation","title":"Configure pkg-config for Cross-Compilation","text":"<pre><code># Set PKG_CONFIG_LIBDIR to point to target libraries\nexport PKG_CONFIG_LIBDIR=$HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging/usr/lib/pkgconfig\n\n# Set PKG_CONFIG_SYSROOT_DIR\nexport PKG_CONFIG_SYSROOT_DIR=$HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging\n\n# Test pkg-config\npkg-config --cflags --libs libmpdclient\n\n# Expected output:\n# -I/home/&lt;user&gt;/.../output/staging/usr/include -L/home/&lt;user&gt;/.../output/staging/usr/lib -lmpdclient\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#cross-compile-the-application","title":"Cross-Compile the Application","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/appdev\n\n# Set cross-compiler\nexport PATH=$HOME/x-tools/aarch64-beagleplay-linux-musl/bin:$PATH\n\n# Compile\naarch64-beagleplay-linux-musl-gcc \\\n    -o nunchuk-mpd-client \\\n    nunchuk-mpd-client.c \\\n    $(pkg-config --cflags --libs libmpdclient)\n\n# Verify it's ARM64\nfile nunchuk-mpd-client\n\n# Expected:\n# nunchuk-mpd-client: ELF 64-bit LSB executable, ARM aarch64, ...\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#deploy-to-target","title":"Deploy to Target","text":"<pre><code># Copy to NFS root\ncp nunchuk-mpd-client $HOME/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot/root/\n\n# Strip to reduce size\naarch64-beagleplay-linux-musl-strip $HOME/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot/root/nunchuk-mpd-client\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#test-on-target","title":"Test on Target","text":"<pre><code># On BeaglePlay\n\n# Ensure MPD is running and has music\nmpc update\nmpc add /\nmpc play\n\n# Run client\n/root/nunchuk-mpd-client\n\n# Use Nunchuk to control playback!\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] Application source code created</li> <li>[ ] pkg-config configured for cross-compilation</li> <li>[ ] Application compiled successfully for ARM64</li> <li>[ ] Binary deployed to NFS root</li> <li>[ ] Application runs on target</li> <li>[ ] Nunchuk controls work (volume, track navigation, pause, quit)</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-3-debugging-with-strace","title":"Section 3: Debugging with strace","text":"<p>If the application doesn't work, let's debug it systematically.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#add-strace-to-buildroot","title":"Add strace to Buildroot","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\nmake menuconfig\n</code></pre> <p>Enable strace:</p> <pre><code>Target packages ---&gt;\n    Debugging, profiling and benchmark ---&gt;\n        [*] strace\n</code></pre> <p>Save, rebuild, update NFS root.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#trace-system-calls","title":"Trace System Calls","text":"<pre><code># On BeaglePlay\n\n# Run application through strace\nstrace /root/nunchuk-mpd-client\n</code></pre> <p>Expected Output (partial):</p> <pre><code>execve(\"/root/nunchuk-mpd-client\", [\"/root/nunchuk-mpd-client\"], ...) = 0\n...\nopenat(AT_FDCWD, \"/dev/input\", O_RDONLY|O_DIRECTORY) = 3\ngetdents64(3, /* entries */, 1024) = ...\nopenat(AT_FDCWD, \"/dev/input/event0\", O_RDONLY) = 4\nioctl(4, EVIOCGNAME(256), \"gpio-keys\") = 10\nclose(4) = 0\nopenat(AT_FDCWD, \"/dev/input/event5\", O_RDONLY) = 4\nioctl(4, EVIOCGNAME(256), \"Wii Nunchuk\") = 12\nsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 5\nconnect(5, {sa_family=AF_INET, sin_port=htons(6600), sin_addr=inet_addr(\"127.0.0.1\")}, 16) = 0\n...\nread(4, ..., 24) = 24   # Reading from Nunchuk\nwrite(5, \"noidle\\n\", 7) = 7   # Writing to MPD\n</code></pre> <p>Key Observations:</p> <ul> <li><code>openat(\"/dev/input\", ...)</code>: Scanning for input devices</li> <li><code>ioctl(EVIOCGNAME, ...)</code>: Querying device names</li> <li><code>socket(...AF_INET...)</code> + <code>connect(...)</code>: MPD connection</li> <li><code>read(4, ...)</code>: Reading Nunchuk events</li> <li><code>write(5, ...)</code>: Sending MPD commands</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#common-issues-detected-by-strace","title":"Common Issues Detected by strace","text":"<p>Problem: Can't find Nunchuk</p> <pre><code>openat(AT_FDCWD, \"/dev/input\", O_RDONLY|O_DIRECTORY) = -1 ENOENT (No such file or directory)\n</code></pre> <p>Solution: Mount devtmpfs or create <code>/dev/input</code></p> <p>Problem: Permission denied</p> <pre><code>openat(AT_FDCWD, \"/dev/input/event5\", O_RDONLY) = -1 EACCES (Permission denied)\n</code></pre> <p>Solution: Run as root or adjust permissions</p> <p>Problem: MPD connection refused</p> <pre><code>connect(5, {sa_family=AF_INET, ...}, 16) = -1 ECONNREFUSED (Connection refused)\n</code></pre> <p>Solution: Start MPD service</p> <p>Verification Checklist:</p> <ul> <li>[ ] strace installed via Buildroot</li> <li>[ ] Application traced successfully</li> <li>[ ] System calls visible and understood</li> <li>[ ] Used strace to diagnose issues</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-4-debugging-with-ltrace","title":"Section 4: Debugging with ltrace","text":""},{"location":"labs/embedded-linux/lab09-application-development/#add-ltrace-to-buildroot","title":"Add ltrace to Buildroot","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\nmake menuconfig\n</code></pre> <p>Enable ltrace:</p> <pre><code>Target packages ---&gt;\n    Debugging, profiling and benchmark ---&gt;\n        [*] ltrace\n</code></pre> <p>Rebuild and update NFS root.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#trace-library-calls","title":"Trace Library Calls","text":"<pre><code># On BeaglePlay\nltrace /root/nunchuk-mpd-client\n</code></pre> <p>Expected Output (partial):</p> <pre><code>mpd_connection_new(\"localhost\", 6600, 0) = 0x...\nmpd_connection_get_error(0x...) = MPD_ERROR_SUCCESS\nmpd_run_status(0x...) = 0x...\nmpd_status_get_volume(0x...) = 75\nmpd_status_free(0x...)\nmpd_run_set_volume(0x..., 80) = 1\nmpd_run_toggle_pause(0x...) = 1\nmpd_run_next(0x...) = 1\nmpd_connection_free(0x...)\n</code></pre> <p>Key Observations:</p> <ul> <li>All <code>mpd_*</code> function calls from libmpdclient are visible</li> <li>Return values shown (helpful for debugging)</li> <li>Can see actual parameters passed</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#debug-a-crash-with-ltrace","title":"Debug a Crash with ltrace","text":"<p>Let's intentionally introduce a bug to see ltrace in action.</p> <p>Modified code (buggy version):</p> <pre><code>/* In main(), after creating connection */\nmpd_connection_free(conn);  /* BUG: Free too early! */\n\n/* Then later when trying to use conn... */\nmpd_run_toggle_pause(conn);  /* CRASH: Use-after-free */\n</code></pre> <p>Run with ltrace:</p> <pre><code>ltrace /root/nunchuk-mpd-client\n</code></pre> <p>Output shows:</p> <pre><code>mpd_connection_free(0x12345678) = &lt;void&gt;\n...\nmpd_run_toggle_pause(0x12345678) = +++ killed by SIGSEGV +++\n</code></pre> <p>This clearly shows the sequence: connection freed, then accessed \u2192 crash!</p> <p>Verification Checklist:</p> <ul> <li>[ ] ltrace installed via Buildroot</li> <li>[ ] Library calls traced successfully</li> <li>[ ] Used ltrace to understand call sequence</li> <li>[ ] Debugged library-related issues</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-5-remote-debugging-with-gdb-and-gdbserver","title":"Section 5: Remote Debugging with gdb and gdbserver","text":""},{"location":"labs/embedded-linux/lab09-application-development/#add-gdb-and-gdbserver-to-buildroot","title":"Add gdb and gdbserver to Buildroot","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\nmake menuconfig\n</code></pre> <p>Enable debugging tools:</p> <pre><code>Target packages ---&gt;\n    Debugging, profiling and benchmark ---&gt;\n        [*] gdb\n            [*] gdbserver\n            [*] full debugger\n</code></pre> <p>Toolchain options:</p> <pre><code>Toolchain ---&gt;\n    [*] Build cross gdb for the host\n        # This gives you aarch64-linux-gdb on your workstation\n</code></pre> <p>Rebuild and update NFS root.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#compile-application-with-debug-symbols","title":"Compile Application with Debug Symbols","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/appdev\n\n# Compile with -g flag (debug symbols)\naarch64-beagleplay-linux-musl-gcc \\\n    -g \\\n    -o nunchuk-mpd-client-debug \\\n    nunchuk-mpd-client.c \\\n    $(pkg-config --cflags --libs libmpdclient)\n\n# Deploy non-stripped version\ncp nunchuk-mpd-client-debug $HOME/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot/root/\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#start-gdbserver-on-target","title":"Start gdbserver on Target","text":"<pre><code># On BeaglePlay\ngdbserver :2345 /root/nunchuk-mpd-client-debug\n\n# gdbserver listens on TCP port 2345\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#connect-from-host-with-gdb","title":"Connect from Host with gdb","text":"<pre><code># On workstation\ncd $HOME/embedded-linux-beagleplay-labs/appdev\n\n# Use cross-gdb\naarch64-beagleplay-linux-musl-gdb nunchuk-mpd-client-debug\n</code></pre> <p>In gdb:</p> <pre><code>(gdb) set sysroot /home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging\n\n(gdb) target remote 192.168.0.100:2345\n\n(gdb) break main\nBreakpoint 1 at 0x...: file nunchuk-mpd-client.c, line 50.\n\n(gdb) continue\nContinuing.\n\nBreakpoint 1, main (argc=1, argv=0x...) at nunchuk-mpd-client.c:50\n50          printf(\"Nunchuk MPD Client starting...\\n\");\n\n(gdb) next\n51          nunchuk_fd = find_nunchuk_device();\n\n(gdb) step\nfind_nunchuk_device () at nunchuk-mpd-client.c:15\n15          dir = opendir(\"/dev/input\");\n\n(gdb) print device_path\n$1 = \"\"\n\n(gdb) continue\nContinuing.\n</code></pre> <p>Common gdb Commands:</p> Command Description <code>break &lt;function&gt;</code> Set breakpoint <code>break &lt;file&gt;:&lt;line&gt;</code> Set breakpoint at line <code>continue</code> Resume execution <code>next</code> Step over (next line) <code>step</code> Step into function <code>print &lt;var&gt;</code> Print variable value <code>backtrace</code> Show call stack <code>info locals</code> Show local variables <code>quit</code> Exit gdb <p>Verification Checklist:</p> <ul> <li>[ ] gdb and gdbserver added to Buildroot</li> <li>[ ] Cross-gdb available on workstation</li> <li>[ ] Application compiled with <code>-g</code> flag</li> <li>[ ] gdbserver started on target</li> <li>[ ] Connected from host gdb</li> <li>[ ] Set breakpoints and stepped through code</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-6-visual-studio-code-remote-debugging","title":"Section 6: Visual Studio Code Remote Debugging","text":""},{"location":"labs/embedded-linux/lab09-application-development/#install-vs-code-extensions","title":"Install VS Code Extensions","text":"<p>On your workstation:</p> <pre><code>code --install-extension ms-vscode.cpptools\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#prepare-target-for-vs-code-debugging","title":"Prepare Target for VS Code Debugging","text":"<pre><code># On BeaglePlay\n\n# Start gdbserver in multi mode (persistent)\ngdbserver --multi :3333\n\n# This allows VS Code to launch and attach to programs\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#create-vs-code-configuration","title":"Create VS Code Configuration","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/appdev\n\nmkdir -p .vscode\n</code></pre> <p>Create .vscode/launch.json:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Debug on BeaglePlay\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"/root/nunchuk-mpd-client-debug\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"/root\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"/home/&lt;user&gt;/x-tools/aarch64-beagleplay-linux-musl/bin/aarch64-beagleplay-linux-musl-gdb\",\n            \"miDebuggerServerAddress\": \"192.168.0.100:3333\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                },\n                {\n                    \"description\": \"Set sysroot\",\n                    \"text\": \"set sysroot /home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging\"\n                }\n            ],\n            \"preLaunchTask\": \"upload\",\n            \"logging\": {\n                \"moduleLoad\": false,\n                \"trace\": false\n            }\n        }\n    ]\n}\n</code></pre> <p>Create .vscode/tasks.json:</p> <pre><code>{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"build\",\n            \"type\": \"shell\",\n            \"command\": \"aarch64-beagleplay-linux-musl-gcc\",\n            \"args\": [\n                \"-g\",\n                \"-o\",\n                \"nunchuk-mpd-client-debug\",\n                \"nunchuk-mpd-client.c\",\n                \"$(PKG_CONFIG_LIBDIR=/home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging/usr/lib/pkgconfig pkg-config --cflags --libs libmpdclient)\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            }\n        },\n        {\n            \"label\": \"upload\",\n            \"type\": \"shell\",\n            \"command\": \"cp\",\n            \"args\": [\n                \"nunchuk-mpd-client-debug\",\n                \"/home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/nfsroot/root/\"\n            ],\n            \"dependsOn\": \"build\"\n        }\n    ]\n}\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#debug-in-vs-code","title":"Debug in VS Code","text":"<ol> <li>Open <code>appdev</code> folder in VS Code:</li> </ol> <pre><code>code $HOME/embedded-linux-beagleplay-labs/appdev\n</code></pre> <ol> <li> <p>Open <code>nunchuk-mpd-client.c</code></p> </li> <li> <p>Set breakpoint (click left of line number)</p> </li> <li> <p>Press <code>F5</code> or Run \u2192 Start Debugging</p> </li> <li> <p>VS Code will:</p> </li> <li>Build the application</li> <li>Upload to target</li> <li>Start debugging session</li> <li> <p>Break at your breakpoint</p> </li> <li> <p>Use debugging controls:</p> </li> <li>Continue (F5)</li> <li>Step Over (F10)</li> <li>Step Into (F11)</li> <li>View variables in sidebar</li> <li>Watch expressions</li> </ol> <p>Verification Checklist:</p> <ul> <li>[ ] VS Code C/C++ extension installed</li> <li>[ ] gdbserver running in multi mode on target</li> <li>[ ] VS Code launch.json and tasks.json created</li> <li>[ ] Successfully debugged application from VS Code</li> <li>[ ] Set breakpoints and inspected variables</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-7-post-mortem-analysis-with-core-dumps","title":"Section 7: Post-Mortem Analysis with Core Dumps","text":""},{"location":"labs/embedded-linux/lab09-application-development/#enable-core-dumps","title":"Enable Core Dumps","text":"<pre><code># On BeaglePlay\n\n# Set core file pattern\necho \"/tmp/core.%p\" &gt; /proc/sys/kernel/core_pattern\n\n# Remove core file size limit\nulimit -c unlimited\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#introduce-a-crash","title":"Introduce a Crash","text":"<p>Modify the application to crash:</p> <pre><code>/* In main(), after successful operations */\nchar *bad_ptr = NULL;\n*bad_ptr = 'X';  /* Deliberate NULL pointer dereference */\n</code></pre> <p>Recompile, deploy, and run.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#collect-core-dump","title":"Collect Core Dump","text":"<pre><code># On BeaglePlay\n/root/nunchuk-mpd-client-debug\n\n# After crash:\nls -l /tmp/core.*\n\n# core.1234 (where 1234 is the PID)\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#analyze-core-dump","title":"Analyze Core Dump","text":"<pre><code># Copy core dump to workstation (via NFS or scp)\ncp /tmp/core.1234 /tmp/\n\n# On workstation\ncd $HOME/embedded-linux-beagleplay-labs/appdev\n\naarch64-beagleplay-linux-musl-gdb \\\n    nunchuk-mpd-client-debug \\\n    /tmp/core.1234\n</code></pre> <p>In gdb:</p> <pre><code>(gdb) set sysroot /home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging\n\n(gdb) backtrace\n#0  0x0000aaaaaaaabc12 in main () at nunchuk-mpd-client.c:123\n#1  0x0000fffff7e12abc in __libc_start_main () from /lib/libc.so.6\n#2  0x0000aaaaaaaab890 in _start ()\n\n(gdb) frame 0\n#0  0x0000aaaaaaaabc12 in main () at nunchuk-mpd-client.c:123\n123         *bad_ptr = 'X';  /* Crash here! */\n\n(gdb) print bad_ptr\n$1 = 0x0 &lt;null&gt;\n\n(gdb) info locals\n# Shows all local variables at crash time\n\n(gdb) bt full\n# Full backtrace with all variables in all frames\n</code></pre> <p>This shows exactly where and why the crash occurred, without running the program!</p> <p>Verification Checklist:</p> <ul> <li>[ ] Core dumps enabled on target</li> <li>[ ] Crashed application generated core dump</li> <li>[ ] Core dump analyzed with gdb on workstation</li> <li>[ ] Identified crash location and cause</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#section-8-system-profiling-with-perf","title":"Section 8: System Profiling with perf","text":""},{"location":"labs/embedded-linux/lab09-application-development/#add-perf-to-buildroot","title":"Add perf to Buildroot","text":"<pre><code>cd $HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot\n\nmake menuconfig\n</code></pre> <p>Enable perf:</p> <pre><code>Kernel ---&gt;\n    Linux Kernel Tools ---&gt;\n        [*] perf\n</code></pre> <p>Rebuild and update.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#profile-application","title":"Profile Application","text":"<pre><code># On BeaglePlay\n\n# Record application activity\nperf record -g /root/nunchuk-mpd-client-debug\n\n# Use Nunchuk for 30 seconds, then quit (C button)\n\n# View report\nperf report\n</code></pre> <p>Expected Output:</p> <pre><code>Samples: 1K of event 'cycles:u', Event count (approx.): 123456789\n  Overhead  Command   Shared Object      Symbol\n+   42.15%  nunchuk   libc.so.6          [.] read\n+   18.32%  nunchuk   libmpdclient.so.2  [.] mpd_run_status\n+   12.45%  nunchuk   nunchuk-mpd-client [.] main\n+    8.21%  nunchuk   libc.so.6          [.] recv\n...\n</code></pre> <p>Interpretation:</p> <ul> <li>42% of time spent in <code>read()</code> (waiting for Nunchuk events)</li> <li>18% in MPD library calls</li> <li>12% in our main loop</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#system-wide-profiling","title":"System-Wide Profiling","text":"<pre><code># On BeaglePlay\n\n# Ensure music is playing\nmpc play\n\n# Profile entire system for 30 seconds\nperf record -a -g sleep 30\n\n# Generate report\nperf report\n\n# Shows kernel and userspace activity\n# Press Enter on symbols to see caller graphs\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#live-profiling","title":"Live Profiling","text":"<pre><code># On BeaglePlay (via SSH for better display)\n\n# Real-time top-like profiler\nperf top\n\n# Shows live CPU usage by function\n# Useful for finding hot spots\n</code></pre> <p>Verification Checklist:</p> <ul> <li>[ ] perf compiled and installed via Buildroot</li> <li>[ ] Application profiled with <code>perf record</code></li> <li>[ ] Profile viewed with <code>perf report</code></li> <li>[ ] System-wide profiling performed</li> <li>[ ] Understood CPU time distribution</li> </ul>"},{"location":"labs/embedded-linux/lab09-application-development/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"labs/embedded-linux/lab09-application-development/#problem-pkg-config-cant-find-libmpdclient","title":"Problem: pkg-config can't find libmpdclient","text":"<p>Error:</p> <pre><code>Package libmpdclient was not found in the pkg-config search path\n</code></pre> <p>Solution:</p> <pre><code>export PKG_CONFIG_LIBDIR=$HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging/usr/lib/pkgconfig\nexport PKG_CONFIG_SYSROOT_DIR=$HOME/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging\n\n# Verify\npkg-config --libs libmpdclient\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#problem-gdb-cant-find-libraries","title":"Problem: gdb can't find libraries","text":"<p>Symptoms:</p> <pre><code>(gdb) continue\nwarning: Could not load shared library symbols for libmpdclient.so.2.\n</code></pre> <p>Solution:</p> <p>Set sysroot in gdb:</p> <pre><code>(gdb) set sysroot /home/&lt;user&gt;/embedded-linux-beagleplay-labs/buildroot-lab/buildroot/output/staging\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#problem-gdbserver-connection-refused","title":"Problem: gdbserver connection refused","text":"<p>Error:</p> <pre><code>192.168.0.100:2345: Connection refused.\n</code></pre> <p>Solutions:</p> <ol> <li>gdbserver not running on target:</li> </ol> <pre><code># On BeaglePlay\ngdbserver :2345 /root/nunchuk-mpd-client-debug\n</code></pre> <ol> <li>Firewall blocking port:</li> </ol> <p>Disable firewall on target or open port 2345.</p> <ol> <li>Wrong IP address:</li> </ol> <p>Verify target IP:</p> <pre><code># On BeaglePlay\nip addr show eth0\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#problem-segmentation-fault-without-useful-info","title":"Problem: Segmentation fault without useful info","text":"<p>Symptoms:</p> <pre><code>Program received signal SIGSEGV, Segmentation fault.\n0x0000fffff7fc1234 in ?? ()\n</code></pre> <p>Cause: Application not compiled with debug symbols.</p> <p>Solution:</p> <pre><code># Recompile with -g\naarch64-beagleplay-linux-musl-gcc -g -o app app.c $(pkg-config --cflags --libs libmpdclient)\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#problem-perf-record-permission-denied","title":"Problem: perf record permission denied","text":"<p>Error:</p> <pre><code>perf_event_open(..., PERF_FLAG_FD_CLOEXEC) failed with unexpected error 1 (Operation not permitted)\n</code></pre> <p>Solution:</p> <pre><code># On BeaglePlay\necho -1 &gt; /proc/sys/kernel/perf_event_paranoid\n</code></pre> <p>Or run as root.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#advanced-challenges","title":"Advanced Challenges","text":""},{"location":"labs/embedded-linux/lab09-application-development/#challenge-1-add-logging-infrastructure","title":"Challenge 1: Add Logging Infrastructure","text":"<p>Implement syslog-based logging for the application.</p> <p>Requirements: - Log MPD commands to syslog - Different log levels (debug, info, error) - Use <code>syslog()</code> from libc</p>"},{"location":"labs/embedded-linux/lab09-application-development/#challenge-2-implement-signal-handling","title":"Challenge 2: Implement Signal Handling","text":"<p>Add graceful shutdown on SIGINT (Ctrl+C).</p> <p>Hint:</p> <pre><code>#include &lt;signal.h&gt;\n\nvolatile sig_atomic_t running = 1;\n\nvoid signal_handler(int signum) {\n    running = 0;\n}\n\nint main() {\n    signal(SIGINT, signal_handler);\n\n    while (running) {\n        /* Main loop */\n    }\n\n    /* Cleanup */\n}\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#challenge-3-memory-leak-detection-with-valgrind","title":"Challenge 3: Memory Leak Detection with Valgrind","text":"<p>Add Valgrind to Buildroot and detect memory leaks.</p> <p>Enable in Buildroot:</p> <pre><code>Target packages ---&gt;\n    Debugging, profiling and benchmark ---&gt;\n        [*] valgrind\n</code></pre> <p>Run:</p> <pre><code>valgrind --leak-check=full /root/nunchuk-mpd-client\n</code></pre>"},{"location":"labs/embedded-linux/lab09-application-development/#challenge-4-create-buildroot-package","title":"Challenge 4: Create Buildroot Package","text":"<p>Integrate the Nunchuk MPD client as a Buildroot package.</p> <p>Structure: - <code>package/nunchuk-mpd-client/Config.in</code> - <code>package/nunchuk-mpd-client/nunchuk-mpd-client.mk</code> - Use <code>$(eval $(cmake-package))</code> or custom Makefile</p>"},{"location":"labs/embedded-linux/lab09-application-development/#challenge-5-implement-auto-restart-with-systemd","title":"Challenge 5: Implement Auto-Restart with systemd","text":"<p>If using systemd (requires glibc Buildroot config), create a service unit to auto-restart the client on crash.</p>"},{"location":"labs/embedded-linux/lab09-application-development/#what-youve-learned","title":"What You've Learned","text":"<p>By completing this lab, you've mastered:</p> <p>\u2705 Cross-Compilation: - Used pkg-config for library dependency management - Cross-compiled applications for ARM64 - Managed library paths with <code>PKG_CONFIG_LIBDIR</code> and <code>PKG_CONFIG_SYSROOT_DIR</code> - Deployed to target via NFS</p> <p>\u2705 Application Development: - Implemented real-world embedded application - Used third-party libraries (libmpdclient) - Integrated with hardware (Nunchuk input device) - Controlled services (MPD playback)</p> <p>\u2705 System Call Debugging: - Used strace to trace system calls - Diagnosed file access, network, and permission issues - Understood kernel-userspace interaction</p> <p>\u2705 Library Call Debugging: - Used ltrace to trace library function calls - Debugged library usage and sequence issues - Identified use-after-free and API misuse</p> <p>\u2705 Remote Debugging: - Set up gdbserver on embedded target - Connected from host gdb - Set breakpoints, stepped through code, inspected variables - Used cross-gdb with sysroot configuration</p> <p>\u2705 IDE Integration: - Configured Visual Studio Code for embedded debugging - Created launch and task configurations - Debugged visually with breakpoints and variable inspection</p> <p>\u2705 Post-Mortem Analysis: - Enabled core dump generation - Analyzed crashes without reproducing - Extracted crash location and variable states from core files</p> <p>\u2705 Performance Profiling: - Used perf for application profiling - Performed system-wide profiling - Identified performance hotspots - Understood CPU time distribution</p> <p>\u2705 Best Practices: - Separate debug and release builds - Strip production binaries - Keep debug symbols on development host - Use appropriate tools for different debugging scenarios</p>"},{"location":"labs/embedded-linux/lab09-application-development/#going-further","title":"Going Further","text":""},{"location":"labs/embedded-linux/lab09-application-development/#recommended-reading","title":"Recommended Reading","text":"<p>Books: - Advanced Linux Programming - Library usage, debugging - Linux System Programming - System calls, I/O, signals - The Art of Debugging with GDB, DDD, and Eclipse</p> <p>Online Resources: - GDB manual: https://sourceware.org/gdb/documentation/ - perf wiki: https://perf.wiki.kernel.org/ - Brendan Gregg's performance tools: http://www.brendangregg.com/</p>"},{"location":"labs/embedded-linux/lab09-application-development/#next-steps","title":"Next Steps","text":"<p>Continue to Yocto Labs: - Lab 10: Yocto Project introduction and environment setup - Lab 11: Writing custom Yocto layers and recipes - Lab 12: Image customization and deployment - Lab 13: SDK generation and application development workflow</p> <p>Or explore Linux Debugging track: - Lab 14: Kernel debugging techniques - Lab 15: Kernel crash analysis and oops interpretation - Lab 16: Tracing with ftrace and trace-cmd - Lab 17: Dynamic debugging and printk</p> <p>Estimated Completion Time: 5-6 hours</p> <p>Difficulty: \u2b50\u2b50\u2b50\u2b50\u2606 (Advanced)</p> <p>Prerequisites Met: \u2705 Lab 8 (Buildroot)</p> <p>Leads to: Yocto Labs (10-13) or Debugging Labs (14-17)</p> <p>Congratulations! You've completed all 9 Embedded Linux labs and built a complete embedded system from scratch!</p>"},{"location":"labs/yocto/","title":"Yocto Project Labs - Index","text":"<p>Target Platform: BeaglePlay (TI AM62x Cortex-A53) Total Labs: 5 Estimated Time: 25-30 hours Difficulty: Intermediate</p>"},{"location":"labs/yocto/#overview","title":"Overview","text":"<p>This series of labs teaches the Yocto Project / OpenEmbedded build system for creating custom embedded Linux distributions. All labs are adapted for BeaglePlay with original examples.</p>"},{"location":"labs/yocto/#coming-soon","title":"Coming Soon","text":"<p>Yocto Project labs are currently in development. These labs will cover:</p> <ul> <li>Lab 10: First Yocto Build</li> <li>Lab 11: Custom Recipes</li> <li>Lab 12: Custom Layers</li> <li>Lab 13: BSP Development</li> <li>Lab 14: SDK and devtool</li> </ul> <p>Prerequisites: Complete Embedded Linux Labs 1-9 first.</p> <p>Status: In Development Expected completion: Q1 2026</p>"},{"location":"labs/yocto/lab10-yocto-first-build/","title":"Lab 10: First Yocto Project Build","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about Yocto:</p> <p>\"The Yocto Project is a build system of such staggering complexity that it makes the Infinite Improbability Drive look straightforward. However, once you understand it (which will take approximately 42 tries), it's actually quite brilliant.\"</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#objectives","title":"Objectives","text":"<p>Master the fundamentals of the Yocto Project build system by setting up a complete OpenEmbedded environment and building your first custom Linux distribution for the BeaglePlay.</p> <p>What You'll Learn: - Set up the Yocto Project/OpenEmbedded build environment - Understand BitBake and layer architecture - Configure machine-specific builds for TI AM62x (BeaglePlay) - Build a minimal root filesystem image - Deploy and boot a Yocto-generated image</p> <p>Time Required: 3-4 hours</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#prerequisites","title":"Prerequisites","text":"<p>Hardware: - BeaglePlay board (TI AM62x Cortex-A53) - microSD card (16GB+ recommended) - USB-C cable for power - USB-to-Serial adapter (3.3V UART) - Serial terminal software (picocom, minicom)</p> <p>Software: - Ubuntu 22.04+ or compatible Linux distribution - At least 50GB free disk space (recommend 100GB+) - Internet connection for downloading layers</p> <p>Knowledge: - Completed embedded Linux track (Labs 1-9) - Understanding of cross-compilation - Familiarity with Git and Python</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#1-understanding-yocto-project","title":"1. Understanding Yocto Project","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#11-what-is-yocto","title":"1.1 What is Yocto?","text":"<p>The Yocto Project is an open-source collaboration project providing templates, tools, and methods for creating custom Linux-based systems regardless of the hardware architecture.</p> <p>Key Components: - Poky: Reference distribution and build system - OpenEmbedded-Core: Core metadata and recipes - BitBake: Task execution engine (Python-based) - Layers: Modular metadata organization</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#12-why-use-yocto","title":"1.2 Why Use Yocto?","text":"<p>Advantages over manual approaches: - Reproducibility: Builds are deterministic and traceable - Scalability: Manage hundreds of packages efficiently - Customization: Full control over every component - Community: Thousands of ready-to-use recipes - Maintenance: Upstream tracking and security updates</p> <p>Comparison with Buildroot: - More complex but more flexible - Recipe-based vs. makefile-based - Better for complex products with long lifecycles</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#13-yocto-architecture","title":"1.3 Yocto Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 BitBake Engine                  \u2502\n\u2502         (Task Scheduler &amp; Executor)             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502               \u2502               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  meta        \u2502 \u2502 meta-oe    \u2502 \u2502 meta-ti    \u2502\n\u2502  (Poky core) \u2502 \u2502 (packages) \u2502 \u2502 (BSP)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502               \u2502               \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502     Build Directory           \u2502\n        \u2502  - conf/                      \u2502\n        \u2502  - tmp/                       \u2502\n        \u2502  - downloads/                 \u2502\n        \u2502  - sstate-cache/              \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Layer Structure: - meta: Core OpenEmbedded recipes - meta-poky: Poky-specific configurations - meta-yocto-bsp: Reference BSP for QEMU and generic boards - meta-ti: Texas Instruments BSP (AM62x support) - meta-openembedded: Community packages (python, networking, etc.) - meta-arm: ARM-specific toolchains and recipes</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#2-system-setup","title":"2. System Setup","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#21-prerequisites-check","title":"2.1 Prerequisites Check","text":"<p>Verify disk space: <pre><code>df -h $HOME\n# Need at least 50GB free, 100GB+ recommended\n</code></pre></p> <p>Check Ubuntu version: <pre><code>lsb_release -a\n# Should be Ubuntu 22.04 or 24.04\n</code></pre></p> <p>Verify no eCryptFS encryption: <pre><code>mount | grep ecryptfs\n# Should return nothing - eCryptFS breaks long filenames\n</code></pre></p> <p>If your home directory uses eCryptFS, create the Yocto workspace on an unencrypted partition.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#22-install-build-dependencies","title":"2.2 Install Build Dependencies","text":"<pre><code>sudo apt update\nsudo apt install -y \\\n    gawk wget git diffstat unzip texinfo gcc build-essential \\\n    chrpath socat cpio python3 python3-pip python3-pexpect \\\n    xz-utils debianutils iputils-ping python3-git python3-jinja2 \\\n    python3-subunit zstd liblz4-tool file locales libacl1 \\\n    libssl-dev libgmp-dev libmpc-dev lz4 zlib1g-dev\n</code></pre> <p>What these packages do: - gawk, diffstat, texinfo: Build system utilities - python3-: BitBake dependencies - chrpath, patchelf: Binary manipulation - socat: Networking tools for BitBake - zstd, lz4*: Compression for package caching</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#23-configure-git","title":"2.3 Configure Git","text":"<pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n</code></pre> <p>Yocto tracks all changes via Git - proper configuration is essential.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#24-ubuntu-2404-apparmor-workaround","title":"2.4 Ubuntu 24.04 AppArmor Workaround","text":"<p>Ubuntu 24.04 restricts unprivileged user namespaces via AppArmor, which breaks BitBake's network isolation.</p> <p>Temporary fix (reboot required): <pre><code>echo 0 | sudo tee /proc/sys/kernel/apparmor_restrict_unprivileged_userns\n</code></pre></p> <p>Persistent fix: <pre><code>echo 'kernel.apparmor_restrict_unprivileged_userns = 0' | \\\n    sudo tee /etc/sysctl.d/99-bitbake.conf\nsudo sysctl --system\n</code></pre></p> <p>Verify: <pre><code>cat /proc/sys/kernel/apparmor_restrict_unprivileged_userns\n# Should output: 0\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#3-setting-up-the-yocto-environment","title":"3. Setting Up the Yocto Environment","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#31-create-workspace","title":"3.1 Create Workspace","text":"<pre><code>mkdir -p ~/yocto-labs\ncd ~/yocto-labs\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#32-download-poky","title":"3.2 Download Poky","text":"<p>Clone the Scarthgap LTS release (Yocto 5.0): <pre><code>git clone https://git.yoctoproject.org/git/poky\ncd poky\ngit checkout -b scarthgap-5.0.4 scarthgap-5.0.4\ncd ..\n</code></pre></p> <p>Why Scarthgap? - LTS release (supported until April 2026) - TI AM62x well-supported - Stable BSP layer ecosystem</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#33-download-required-layers","title":"3.3 Download Required Layers","text":"<p>meta-openembedded (community packages): <pre><code>git clone -b scarthgap \\\n    https://git.openembedded.org/meta-openembedded\n</code></pre></p> <p>meta-arm (ARM toolchains): <pre><code>git clone https://git.yoctoproject.org/git/meta-arm\ncd meta-arm\ngit checkout -b yocto-5.0.1 yocto-5.0.1\ncd ..\n</code></pre></p> <p>meta-ti (BeaglePlay BSP): <pre><code>git clone https://git.yoctoproject.org/git/meta-ti\ncd meta-ti\ngit checkout -b scarthgap-10.01.03 10.01.03\ncd ..\n</code></pre></p> <p>Verify layer versions: <pre><code>cd ~/yocto-labs\nfor layer in poky meta-openembedded meta-arm meta-ti; do\n    echo \"=== $layer ===\"\n    cd $layer\n    git describe --tags\n    cd ..\ndone\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#34-understand-layer-structure","title":"3.4 Understand Layer Structure","text":"<p>Explore Poky: <pre><code>cd ~/yocto-labs/poky\nls -l\n</code></pre></p> <p>Output: <pre><code>meta/           # Core OpenEmbedded recipes\nmeta-poky/      # Poky distribution policy\nmeta-yocto-bsp/ # Reference BSPs (QEMU)\nbitbake/        # BitBake build engine\nscripts/        # Utility scripts\noe-init-build-env  # Environment setup script\n</code></pre></p> <p>Explore meta-ti: <pre><code>cd ~/yocto-labs/meta-ti\nls -l\n</code></pre></p> <p>Output: <pre><code>meta-ti-bsp/    # Board support (BeaglePlay)\nmeta-ti-extras/ # Additional TI packages\nrecipes-*/      # Recipe directories\nconf/           # Layer and machine configurations\n</code></pre></p> <p>Check BeaglePlay machine config: <pre><code>cat meta-ti-bsp/conf/machine/beagleplay.conf | head -30\n</code></pre></p> <p>You'll see AM62x-specific settings: SoC family, kernel provider, bootloader configurations.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#4-initializing-the-build-environment","title":"4. Initializing the Build Environment","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#41-source-the-environment-script","title":"4.1 Source the Environment Script","text":"<pre><code>cd ~/yocto-labs\nsource poky/oe-init-build-env\n</code></pre> <p>What this does: - Creates <code>build/</code> directory - Generates <code>conf/local.conf</code> and <code>conf/bblayers.conf</code> - Sets up BitBake environment variables - Changes directory to <code>build/</code></p> <p>You're now in: <code>~/yocto-labs/build/</code></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#42-verify-environment","title":"4.2 Verify Environment","text":"<pre><code>echo $BUILDDIR\n# Output: /home/user/yocto-labs/build\n\nwhich bitbake\n# Output: /home/user/yocto-labs/poky/bitbake/bin/bitbake\n</code></pre> <p>Important (like knowing where your towel is): You must source <code>oe-init-build-env</code> in every new shell session.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#43-understand-build-directory-structure","title":"4.3 Understand Build Directory Structure","text":"<pre><code>ls -l ~/yocto-labs/build/\n</code></pre> <p>Output: <pre><code>conf/           # Configuration files\ntmp/            # Build artifacts (created during build)\ndownloads/      # Downloaded source tarballs\nsstate-cache/   # Shared state cache (build acceleration)\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#5-configuring-the-build","title":"5. Configuring the Build","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#51-configure-target-machine","title":"5.1 Configure Target Machine","text":"<p>Edit local.conf: <pre><code>nano conf/local.conf\n</code></pre></p> <p>Find the MACHINE variable (around line 33): <pre><code>#MACHINE ??= \"qemux86-64\"\n</code></pre></p> <p>Change to BeaglePlay: <pre><code>MACHINE ??= \"beagleplay\"\n</code></pre></p> <p>Add disk space optimization (optional but recommended): <pre><code># Remove work directories after build to save space\nINHERIT += \"rm_work\"\n\n# Keep sources for debugging\nRM_WORK_EXCLUDE += \"linux-ti-staging u-boot-ti-staging\"\n</code></pre></p> <p>Add parallel build settings: <pre><code># Use all CPU cores (adjust based on your system)\nBB_NUMBER_THREADS ?= \"${@oe.utils.cpu_count()}\"\nPARALLEL_MAKE ?= \"-j ${@oe.utils.cpu_count()}\"\n</code></pre></p> <p>Save and exit (Ctrl+O, Enter, Ctrl+X).</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#52-configure-layers","title":"5.2 Configure Layers","text":"<p>Edit bblayers.conf: <pre><code>nano conf/bblayers.conf\n</code></pre></p> <p>You'll see: <pre><code>BBLAYERS ?= \" \\\n  /home/user/yocto-labs/poky/meta \\\n  /home/user/yocto-labs/poky/meta-poky \\\n  /home/user/yocto-labs/poky/meta-yocto-bsp \\\n  \"\n</code></pre></p> <p>Add required layers: <pre><code>BBLAYERS ?= \" \\\n  /home/user/yocto-labs/poky/meta \\\n  /home/user/yocto-labs/poky/meta-poky \\\n  /home/user/yocto-labs/poky/meta-yocto-bsp \\\n  /home/user/yocto-labs/meta-openembedded/meta-oe \\\n  /home/user/yocto-labs/meta-openembedded/meta-python \\\n  /home/user/yocto-labs/meta-openembedded/meta-networking \\\n  /home/user/yocto-labs/meta-arm/meta-arm \\\n  /home/user/yocto-labs/meta-arm/meta-arm-toolchain \\\n  /home/user/yocto-labs/meta-ti/meta-ti-bsp \\\n  /home/user/yocto-labs/meta-ti/meta-ti-extras \\\n  \"\n</code></pre></p> <p>Important (like knowing where your towel is): Use absolute paths. Replace <code>/home/user/</code> with your actual home directory path.</p> <p>Quick way to get absolute paths: <pre><code># Generate layer paths automatically\ncd ~/yocto-labs\nfor layer in \\\n    meta-openembedded/meta-oe \\\n    meta-openembedded/meta-python \\\n    meta-openembedded/meta-networking \\\n    meta-arm/meta-arm \\\n    meta-arm/meta-arm-toolchain \\\n    meta-ti/meta-ti-bsp \\\n    meta-ti/meta-ti-extras; do\n    realpath $layer\ndone\n</code></pre></p> <p>Copy the output and paste into <code>BBLAYERS</code>.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#53-verify-configuration","title":"5.3 Verify Configuration","text":"<p>Check layer dependencies: <pre><code>bitbake-layers show-layers\n</code></pre></p> <p>Expected output: <pre><code>layer                 path                                      priority\n==========================================================================\nmeta                  /home/user/yocto-labs/poky/meta           5\nmeta-poky             /home/user/yocto-labs/poky/meta-poky      5\nmeta-yocto-bsp        /home/user/yocto-labs/poky/meta-yocto-bsp 5\nmeta-oe               /home/user/yocto-labs/meta-openembedded/meta-oe  6\nmeta-python           /home/user/yocto-labs/meta-openembedded/meta-python  7\nmeta-networking       /home/user/yocto-labs/meta-openembedded/meta-networking  5\nmeta-arm              /home/user/yocto-labs/meta-arm/meta-arm   5\nmeta-arm-toolchain    /home/user/yocto-labs/meta-arm/meta-arm-toolchain  5\nmeta-ti-bsp           /home/user/yocto-labs/meta-ti/meta-ti-bsp  6\nmeta-ti-extras        /home/user/yocto-labs/meta-ti/meta-ti-extras  7\n</code></pre></p> <p>Check for dependency issues: <pre><code>bitbake-layers check-layers\n</code></pre></p> <p>Should return no errors.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#6-building-your-first-image","title":"6. Building Your First Image","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#61-understand-bitbake-images","title":"6.1 Understand BitBake Images","text":"<p>Common image targets: - core-image-minimal: Bare minimum (console only, ~10MB rootfs) - core-image-base: Basic with networking - core-image-full-cmdline: All console tools - core-image-sato: Graphical desktop (large)</p> <p>We'll build core-image-minimal for this first build.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#62-start-the-build","title":"6.2 Start the Build","text":"<pre><code>cd ~/yocto-labs/build\nbitbake core-image-minimal\n</code></pre> <p>Expected output: <pre><code>Loading cache: 100% |##################################| Time: 0:00:05\nLoaded 4321 entries from dependency cache.\nParsing recipes: 100% |################################| Time: 0:00:38\nParsing of 2456 .bb files complete (2450 cached, 6 parsed). 4328 targets, 412 skipped, 0 masked, 0 errors.\nNOTE: Resolving any missing task queue dependencies\n...\nNOTE: Tasks Summary: Attempted 3284 tasks of which 0 didn't need to be rerun and all succeeded.\n</code></pre></p> <p>First build will take 1-3 hours depending on: - CPU cores (more is better) - Internet speed (downloads ~5GB) - Disk speed (SSD recommended)</p> <p>What's happening: 1. BitBake parses all recipes and dependencies 2. Downloads source tarballs to <code>downloads/</code> 3. Unpacks, patches, configures, compiles packages 4. Generates rootfs and bootable image 5. Caches intermediate results in <code>sstate-cache/</code></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#63-monitor-build-progress","title":"6.3 Monitor Build Progress","text":"<p>Open another terminal and monitor: <pre><code># Watch disk usage\nwatch -n 5 'df -h ~/yocto-labs/build/tmp'\n\n# Monitor currently running tasks\ntail -f ~/yocto-labs/build/tmp/log/cooker/beagleplay/console-latest.log\n</code></pre></p> <p>Common tasks you'll see: - <code>do_fetch</code>: Download sources - <code>do_unpack</code>: Extract archives - <code>do_patch</code>: Apply patches - <code>do_configure</code>: Run ./configure or cmake - <code>do_compile</code>: Build the package - <code>do_install</code>: Install to staging area - <code>do_package</code>: Create binary packages - <code>do_rootfs</code>: Assemble root filesystem</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#64-handle-build-errors","title":"6.4 Handle Build Errors","text":"<p>If build fails: <pre><code># Check error log\ncat tmp/log/cooker/beagleplay/console-latest.log | grep ERROR\n\n# Clean specific package and retry\nbitbake -c cleansstate &lt;package-name&gt;\nbitbake &lt;package-name&gt;\n\n# Full clean (last resort)\nbitbake -c cleanall &lt;package-name&gt;\n</code></pre></p> <p>Common issues: - Network timeouts: Retry the build - Disk full: Free up space, adjust <code>tmp/</code> location - Missing dependencies: Update host packages</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#7-analyzing-build-results","title":"7. Analyzing Build Results","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#71-locate-build-artifacts","title":"7.1 Locate Build Artifacts","text":"<pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\nls -lh\n</code></pre> <p>Key files: <pre><code>core-image-minimal-beagleplay.rootfs.tar.xz   # Root filesystem archive\ncore-image-minimal-beagleplay.rootfs.wic.xz   # Complete SD card image\nImage-beagleplay.bin                          # Kernel binary\ntiboot3.bin                                   # R5 SPL bootloader\ntispl.bin                                     # ARM Trusted Firmware + U-Boot SPL\nu-boot.img                                    # U-Boot proper\n</code></pre></p> <p>Symlinks point to timestamped versions: <pre><code>ls -l Image-beagleplay.bin\n# Output: Image-beagleplay.bin -&gt; Image--5.10.168+git0+&lt;hash&gt;-r8a-beagleplay-&lt;timestamp&gt;.bin\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#72-examine-image-contents","title":"7.2 Examine Image Contents","text":"<p>Extract rootfs to inspect: <pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\nmkdir -p /tmp/rootfs-inspect\ntar -xf core-image-minimal-beagleplay.rootfs.tar.xz -C /tmp/rootfs-inspect\n</code></pre></p> <p>Explore: <pre><code>ls -l /tmp/rootfs-inspect/\n# Output: bin/ boot/ dev/ etc/ home/ lib/ media/ mnt/ proc/ run/ sbin/ sys/ tmp/ usr/ var/\n\ndu -sh /tmp/rootfs-inspect/\n# Output: ~12M (very minimal!)\n</code></pre></p> <p>Check installed packages: <pre><code>cat /tmp/rootfs-inspect/usr/lib/opkg/status | grep \"^Package:\"\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#73-understand-wic-image-format","title":"7.3 Understand WIC Image Format","text":"<p>WIC (Wic Image Creator) is Yocto's partition image tool.</p> <p>Inspect partition layout: <pre><code>xz -dc core-image-minimal-beagleplay.rootfs.wic.xz &gt; /tmp/image.wic\nfdisk -l /tmp/image.wic\n</code></pre></p> <p>Expected output: <pre><code>Device                                      Boot  Start     End Sectors  Size Id Type\n/tmp/image.wic1                             *      8192  139263  131072   64M  c W95 FAT32 (LBA)\n/tmp/image.wic2                                  147456 1196031 1048576  512M 83 Linux\n</code></pre></p> <p>Partition structure: - Partition 1 (boot): FAT32, contains kernel + Device Tree + bootloader - Partition 2 (rootfs): ext4, root filesystem</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#74-check-build-statistics","title":"7.4 Check Build Statistics","text":"<pre><code>bitbake -g core-image-minimal\ncat pn-buildlist | wc -l\n# Output: ~400 packages built\n</code></pre> <p>View dependency graph: <pre><code>bitbake -g core-image-minimal -u depexp\n# Opens graphical dependency explorer (requires X11)\n</code></pre></p> <p>Build time report: <pre><code>cat tmp/log/cooker/beagleplay/console-latest.log | grep \"Build Configuration\"\ncat tmp/log/cooker/beagleplay/console-latest.log | grep \"Tasks Summary\"\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#8-preparing-the-sd-card","title":"8. Preparing the SD Card","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#81-identify-sd-card-device","title":"8.1 Identify SD Card Device","text":"<p>Insert SD card and check device name: <pre><code>lsblk\n</code></pre></p> <p>Output: <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nsda           8:0    0 465.8G  0 disk \n\u2514\u2500sda1        8:1    0 465.8G  0 part /\nsdb           8:16   1  14.9G  0 disk        &lt;-- SD card\n\u2514\u2500sdb1        8:17   1  14.9G  0 part /media/user/SDCARD\n</code></pre></p> <p>Your SD card is <code>/dev/sdb</code> (may be different on your system).</p> <p>WARNING: Double-check! Writing to wrong device destroys data.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#82-unmount-existing-partitions","title":"8.2 Unmount Existing Partitions","text":"<pre><code>sudo umount /dev/sdb*\n# Ignore errors if not mounted\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#83-flash-the-image","title":"8.3 Flash the Image","text":"<p>Write WIC image to SD card: <pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\n\nxz -dc core-image-minimal-beagleplay.rootfs.wic.xz | \\\n    sudo dd of=/dev/sdb conv=fdatasync bs=4M status=progress\n</code></pre></p> <p>Explanation: - <code>xz -dc</code>: Decompress XZ archive to stdout - <code>dd</code>: Write raw data to block device - <code>conv=fdatasync</code>: Flush write cache (ensure data integrity) - <code>bs=4M</code>: Write in 4MB blocks (faster) - <code>status=progress</code>: Show transfer progress</p> <p>Wait for completion (takes 1-2 minutes).</p> <p>Sync filesystems: <pre><code>sudo sync\n</code></pre></p> <p>Safely remove SD card: <pre><code>sudo eject /dev/sdb\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#9-serial-console-setup","title":"9. Serial Console Setup","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#91-connect-serial-adapter","title":"9.1 Connect Serial Adapter","text":"<p>BeaglePlay UART pins (3-pin header next to USB-C): <pre><code>Pin 1 (closest to USB-C): TX (Board transmit)\nPin 2 (middle):           RX (Board receive)\nPin 3 (far from USB-C):   GND (Ground)\n</code></pre></p> <p>USB-to-Serial adapter connection: - Adapter RX \u2192 BeaglePlay TX (Pin 1) - Adapter TX \u2192 BeaglePlay RX (Pin 2) - Adapter GND \u2192 BeaglePlay GND (Pin 3)</p> <p>Rule: TX connects to RX, RX connects to TX.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#92-configure-serial-permissions","title":"9.2 Configure Serial Permissions","text":"<pre><code># Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# Apply group change (logout/login or use newgrp)\nnewgrp dialout\n</code></pre> <p>Verify: <pre><code>groups | grep dialout\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#93-install-and-use-picocom","title":"9.3 Install and Use picocom","text":"<pre><code>sudo apt install picocom\n</code></pre> <p>Connect to serial console: <pre><code>picocom -b 115200 /dev/ttyUSB0\n</code></pre></p> <p>Exit picocom: Press <code>Ctrl+A</code> then <code>Ctrl+X</code></p> <p>If <code>/dev/ttyUSB0</code> doesn't exist: <pre><code>dmesg | grep tty\n# Look for: usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#10-booting-the-image","title":"10. Booting the Image","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#101-power-on-sequence","title":"10.1 Power On Sequence","text":"<ol> <li>Insert SD card into BeaglePlay</li> <li>Press and hold USR button (near LEDs)</li> <li>Connect USB-C power cable while holding button</li> <li>Release USR button after 2 seconds</li> </ol> <p>This forces boot from SD card instead of eMMC.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#102-observe-boot-logs","title":"10.2 Observe Boot Logs","text":"<p>You should see in picocom:</p> <p>Stage 1: R5 SPL (tiboot3.bin): <pre><code>U-Boot SPL 2023.04 (Nov 20 2024)\nSYSFW ABI: 3.1 (firmware rev 0x0009 '9.1.8--v09.01.08')\nTrying to boot from MMC1\n</code></pre></p> <p>Stage 2: TF-A + A53 SPL (tispl.bin): <pre><code>NOTICE:  BL31: v2.9(release):v2.9.0\nNOTICE:  BL31: Built : 10:23:45, Nov 20 2024\n</code></pre></p> <p>Stage 3: U-Boot (u-boot.img): <pre><code>U-Boot 2023.04 (Nov 20 2024)\nSoC:   AM62X SR1.0 HS-FS\nModel: BeagleBoard.org BeaglePlay\nHit any key to stop autoboot:  0\n</code></pre></p> <p>Stage 4: Linux Kernel: <pre><code>[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n[    0.000000] Linux version 5.10.168-ti-g12345678 (oe-user@oe-host) (aarch64-oe-linux-gcc ...)\n...\n[    5.234567] Run /sbin/init as init process\n</code></pre></p> <p>Stage 5: Login Prompt: <pre><code>Poky (Yocto Project Reference Distro) 5.0.4 beagleplay /dev/ttyS2\n\nbeagleplay login:\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#103-login","title":"10.3 Login","text":"<p>Username: <code>root</code> (no password by default)</p> <pre><code>beagleplay login: root\nroot@beagleplay:~#\n</code></pre> <p>Congratulations! You've successfully built and booted a Yocto-based Linux system.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#11-exploring-the-system","title":"11. Exploring the System","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#111-basic-system-information","title":"11.1 Basic System Information","text":"<pre><code># Kernel version\nuname -a\n# Output: Linux beagleplay 5.10.168-ti-g12345678 #1 SMP PREEMPT Wed Nov 20 10:23:45 UTC 2024 aarch64 GNU/Linux\n\n# CPU info\ncat /proc/cpuinfo | grep \"model name\"\n\n# Memory\nfree -h\n\n# Disk usage\ndf -h\n\n# Running processes\nps aux\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#112-test-network-if-available","title":"11.2 Test Network (if available)","text":"<pre><code># Show network interfaces\nip link show\n\n# Bring up Ethernet (if cable connected)\nip link set dev eth0 up\nudhcpc -i eth0\n\n# Test connectivity\nping -c 3 8.8.8.8\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#113-explore-installed-packages","title":"11.3 Explore Installed Packages","text":"<pre><code># List installed packages\nopkg list-installed\n\n# Count packages\nopkg list-installed | wc -l\n# Output: ~50 packages in minimal image\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#114-check-storage","title":"11.4 Check Storage","text":"<pre><code># Partition layout\ncat /proc/partitions\n\n# Mount points\nmount\n\n# Root filesystem type\nmount | grep \"on / \"\n# Output: /dev/mmcblk0p2 on / type ext4 (rw,relatime)\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#12-troubleshooting","title":"12. Troubleshooting","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#121-build-issues","title":"12.1 Build Issues","text":"<p>Problem: <code>ERROR: Nothing PROVIDES &lt;package&gt;</code></p> <p>Solution: Missing layer dependency. Add the layer containing the package to <code>bblayers.conf</code>.</p> <p>Problem: <code>ERROR: Fetcher failure for URL: 'https://...'</code></p> <p>Solution: Network issue or upstream server down. Check internet connection, retry build. If persistent, check recipe's <code>SRC_URI</code>.</p> <p>Problem: <code>ERROR: Task do_compile failed</code></p> <p>Solution: Compilation error. Check: <pre><code>cat tmp/work/&lt;architecture&gt;/&lt;package&gt;/&lt;version&gt;/temp/log.do_compile\n</code></pre> May need to patch the recipe or update the package version.</p> <p>Problem: Disk space full</p> <p>Solution: <pre><code># Clean all build artifacts\nbitbake -c cleanall core-image-minimal\n\n# Remove old downloads\nrm -rf downloads/*\n\n# Clear sstate cache\nrm -rf sstate-cache/*\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#122-boot-issues","title":"12.2 Boot Issues","text":"<p>Problem: \"Waiting for root device /dev/mmcblk0p2...\"</p> <p>Solution: U-Boot can't find rootfs partition. Check: - SD card properly flashed - Boot partition contains correct files - U-Boot environment variables (printenv in U-Boot)</p> <p>Problem: Kernel panic or immediate reboot</p> <p>Solution: - Kernel/Device Tree mismatch - Corrupted image - reflash SD card - Check Device Tree blob loaded: <code>cat /proc/device-tree/model</code></p> <p>Problem: No serial output</p> <p>Solution: - Verify TX/RX crossed correctly - Check baud rate (should be 115200) - Try different USB port - Test serial adapter with loopback (connect TX to RX)</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#123-yocto-specific-issues","title":"12.3 Yocto-Specific Issues","text":"<p>Problem: Changes to <code>local.conf</code> not taking effect</p> <p>Solution: BitBake caches configuration. Force re-parse: <pre><code>bitbake -c cleanall &lt;package&gt;\n# Or delete tmp/cache/\n</code></pre></p> <p>Problem: Layer version mismatch errors</p> <p>Solution: Ensure all layers use same Yocto release: <pre><code>cd ~/yocto-labs\nfor d in poky meta-*; do\n    cd $d\n    echo \"=== $d ===\"\n    git branch -v\n    cd ..\ndone\n</code></pre></p> <p>All should show <code>scarthgap</code> or <code>yocto-5.0.*</code>.</p> <p>Problem: Python errors during parsing</p> <p>Solution: Virtual environment conflict. Start fresh shell: <pre><code># Exit any Python venv\ndeactivate\n\n# Source Yocto environment cleanly\ncd ~/yocto-labs\nsource poky/oe-init-build-env\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#13-going-further","title":"13. Going Further","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#131-rebuild-after-changes","title":"13.1 Rebuild After Changes","text":"<p>After modifying local.conf: <pre><code>bitbake core-image-minimal\n</code></pre></p> <p>BitBake is smart - only rebuilds changed components.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#132-build-different-images","title":"13.2 Build Different Images","text":"<p>Larger image with networking tools: <pre><code>bitbake core-image-base\n</code></pre></p> <p>Full command-line tools: <pre><code>bitbake core-image-full-cmdline\n</code></pre></p> <p>Custom image (we'll create this in Lab 16): <pre><code>bitbake my-custom-image\n</code></pre></p>"},{"location":"labs/yocto/lab10-yocto-first-build/#133-explore-bitbake-commands","title":"13.3 Explore BitBake Commands","text":"<pre><code># Show all available images\nbitbake-layers show-recipes \"*-image-*\"\n\n# Show recipe dependencies\nbitbake -g core-image-minimal\ndot -Tpng task-depends.dot -o task-depends.png\n\n# Show recipe details\nbitbake-layers show-recipes busybox\nbitbake -e busybox | grep \"^SRC_URI=\"\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#134-speed-up-subsequent-builds","title":"13.4 Speed Up Subsequent Builds","text":"<p>Use shared downloads and sstate cache: <pre><code># Edit conf/local.conf\nDL_DIR = \"/opt/yocto-shared/downloads\"\nSSTATE_DIR = \"/opt/yocto-shared/sstate-cache\"\n\n# Create shared directories\nsudo mkdir -p /opt/yocto-shared/{downloads,sstate-cache}\nsudo chown -R $USER:$USER /opt/yocto-shared\n</code></pre></p> <p>This allows multiple build directories to share cached data.</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#14-cleaning-up","title":"14. Cleaning Up","text":""},{"location":"labs/yocto/lab10-yocto-first-build/#141-preserve-build-environment","title":"14.1 Preserve Build Environment","text":"<p>DO NOT delete these: - <code>build/conf/</code> - Your configuration - <code>build/downloads/</code> - Source tarballs (reused) - <code>build/sstate-cache/</code> - Build cache (huge time saver)</p> <p>Safe to delete: - <code>build/tmp/</code> - Regenerated on next build - <code>build/cache/</code> - Regenerated on parsing</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#142-clean-specific-packages","title":"14.2 Clean Specific Packages","text":"<pre><code># Remove task outputs but keep downloads\nbitbake -c clean &lt;package&gt;\n\n# Remove shared state cache for package\nbitbake -c cleansstate &lt;package&gt;\n\n# Complete clean (removes downloads too)\nbitbake -c cleanall &lt;package&gt;\n</code></pre>"},{"location":"labs/yocto/lab10-yocto-first-build/#143-disk-space-management","title":"14.3 Disk Space Management","text":"<p>Check space usage: <pre><code>du -sh ~/yocto-labs/build/{tmp,downloads,sstate-cache}\n</code></pre></p> <p>Typical sizes after first build: - <code>tmp/</code>: 20-40GB - <code>downloads/</code>: 5-10GB - <code>sstate-cache/</code>: 10-20GB</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#15-key-takeaways","title":"15. Key Takeaways","text":"<p>What You Accomplished: 1. \u2705 Set up complete Yocto/OpenEmbedded environment 2. \u2705 Configured build for BeaglePlay (TI AM62x) 3. \u2705 Built minimal Linux distribution from source 4. \u2705 Generated bootable SD card image 5. \u2705 Successfully booted custom Linux on hardware</p> <p>Yocto Fundamentals Learned: - Layers: Modular metadata organization - BitBake: Recipe-based build system - Machine configuration: Hardware-specific settings - WIC images: Partition layout and bootable media - Shared state caching: Build acceleration</p> <p>Next Steps: - Lab 11: Advanced Yocto configuration and customization - Lab 12: Add custom applications to images - Lab 13: Create your own meta-layer - Lab 14: Extend existing recipes with bbappend - Lab 15: Define custom machine configurations</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#16-verification-checklist","title":"16. Verification Checklist","text":"<p>Before proceeding to Lab 11, verify:</p> <ul> <li>[ ] Yocto environment sources without errors</li> <li>[ ] <code>bitbake-layers show-layers</code> shows all 10 layers</li> <li>[ ] <code>bitbake core-image-minimal</code> completes successfully</li> <li>[ ] SD card image generated (~200MB compressed)</li> <li>[ ] BeaglePlay boots to login prompt from SD card</li> <li>[ ] Serial console accessible via <code>/dev/ttyUSB0</code></li> <li>[ ] Root login works (no password)</li> <li>[ ] Basic commands work (ls, ps, mount)</li> <li>[ ] Kernel version shows Yocto build</li> <li>[ ] Build directory preserved for next lab</li> </ul> <p>Build time: ~2 hours first build, ~10 minutes incremental Disk usage: ~60GB total Success criteria: Booting to shell on BeaglePlay hardware</p>"},{"location":"labs/yocto/lab10-yocto-first-build/#17-additional-resources","title":"17. Additional Resources","text":"<p>Official Documentation: - Yocto Project Quick Build: https://docs.yoctoproject.org/brief-yoctoprojectqs/ - BitBake User Manual: https://docs.yoctoproject.org/bitbake/ - Yocto Dev Manual: https://docs.yoctoproject.org/dev-manual/</p> <p>TI-Specific: - meta-ti Layer: https://git.yoctoproject.org/meta-ti/ - AM62x Technical Reference: https://www.ti.com/product/AM625 - BeaglePlay Documentation: https://docs.beagleboard.org/latest/boards/beagleplay/</p> <p>Community: - Yocto Mailing Lists: https://lists.yoctoproject.org/ - #yocto IRC on Libera.Chat - BeagleBoard Forums: https://forum.beagleboard.org/</p> <p>End of Lab 10</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>You now have a functional Yocto build environment and understand the fundamentals of embedded Linux distribution creation. The next labs will teach you how to customize and extend this foundation to create production-ready systems.</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/","title":"Lab 11: Advanced Yocto Configuration","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about Yocto:</p> <p>\"The Yocto Project is a build system of such staggering complexity that it makes the Infinite Improbability Drive look straightforward. However, once you understand it (which will take approximately 42 tries), it's actually quite brilliant.\"</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#objectives","title":"Objectives","text":"<p>Master advanced BitBake configuration techniques, package management, and network-based development workflows to accelerate iteration cycles.</p> <p>What You'll Learn: - Customize package selection with <code>IMAGE_INSTALL</code> - Configure preferred package providers - Set up NFS root filesystem for rapid testing - Use TFTP for kernel/bootloader development - Optimize BitBake build performance - Understand BitBake task execution model</p> <p>Time Required: 2-3 hours (or approximately 42 minutes in improbable circumstances)</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 10: First Yocto Project Build</p> <p>Hardware: - BeaglePlay with SD card (from Lab 10) - Ethernet cable - Development workstation with Ethernet port (or USB-Ethernet adapter)</p> <p>Software: - Working Yocto build environment - <code>core-image-minimal</code> successfully built</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#1-understanding-yocto-configuration","title":"1. Understanding Yocto Configuration","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#11-configuration-hierarchy","title":"1.1 Configuration Hierarchy","text":"<p>Yocto's configuration comes from multiple sources with defined precedence:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  BitBake Variables (Highest)        \u2502\n\u2502  1. Environment (BB_ENV_PASSTHROUGH) \u2502\n\u2502  2. local.conf                       \u2502\n\u2502  3. auto.conf                        \u2502\n\u2502  4. Machine config (.conf)           \u2502\n\u2502  5. Distribution config (poky.conf)  \u2502\n\u2502  6. Layer config (layer.conf)        \u2502\n\u2502  7. Recipe (.bb) files               \u2502\n\u2502  8. Default values (Lowest)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Assignment operators: - <code>=</code>: Simple assignment (evaluated when accessed) - <code>:=</code>: Immediate expansion - <code>+=</code>: Append with space - <code>=+</code>: Prepend with space - <code>.=</code>: Append without space - <code>=.</code>: Prepend without space - <code>??=</code>: Weak default (only if not set) - <code>?=</code>: Default (overridable)</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#12-key-configuration-files","title":"1.2 Key Configuration Files","text":"<p><code>conf/local.conf</code>: <pre><code># Build-specific settings\nMACHINE = \"beagleplay\"\nDL_DIR = \"${TOPDIR}/downloads\"\nSSTATE_DIR = \"${TOPDIR}/sstate-cache\"\nDISTRO = \"poky\"\nPACKAGE_CLASSES = \"package_ipk\"\nIMAGE_INSTALL:append = \" dropbear strace\"\n</code></pre></p> <p><code>conf/bblayers.conf</code>: <pre><code># Layer inclusion\nBBLAYERS ?= \" \\\n  ${TOPDIR}/../poky/meta \\\n  ${TOPDIR}/../meta-ti/meta-ti-bsp \\\n  ...\n\"\n</code></pre></p> <p>Why two files? - <code>bblayers.conf</code>: What layers to use (rarely changes) - <code>local.conf</code>: Build customization (frequently modified)</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#13-variable-exploration","title":"1.3 Variable Exploration","text":"<p>View all variables for a recipe: <pre><code>bitbake -e core-image-minimal | less\n</code></pre></p> <p>Search for specific variable: <pre><code>bitbake -e core-image-minimal | grep \"^IMAGE_INSTALL=\"\n</code></pre></p> <p>Show where variable is set: <pre><code>bitbake -e core-image-minimal | grep -A 5 \"^# IMAGE_INSTALL\"\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#2-customizing-package-selection","title":"2. Customizing Package Selection","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#21-understanding-image_install","title":"2.1 Understanding IMAGE_INSTALL","text":"<p><code>IMAGE_INSTALL</code> controls which packages go into the final rootfs.</p> <p>View default packages: <pre><code>cd ~/yocto-labs/build\nbitbake -e core-image-minimal | grep \"^IMAGE_INSTALL=\"\n</code></pre></p> <p>Output (example): <pre><code>IMAGE_INSTALL=\"packagegroup-core-boot packagegroup-base-extended dropbear\"\n</code></pre></p> <p>Package groups are meta-packages that pull in multiple related packages.</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#22-add-packages-to-image","title":"2.2 Add Packages to Image","text":"<p>Edit local.conf: <pre><code>nano conf/local.conf\n</code></pre></p> <p>Add Dropbear SSH server: <pre><code># Append to IMAGE_INSTALL (note the space before dropbear)\nIMAGE_INSTALL:append = \" dropbear\"\n</code></pre></p> <p>Why <code>:append</code> instead of <code>+=</code>? - <code>:append</code> is applied after all parsing (can't be overridden) - <code>+=</code> can be overridden by recipes - Leading space in <code>:append</code> is critical (avoids \"packagedropbear\")</p> <p>Add multiple packages: <pre><code>IMAGE_INSTALL:append = \" \\\n    dropbear \\\n    strace \\\n    htop \\\n    nano \\\n    mtd-utils \\\n    i2c-tools \\\n    can-utils \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#23-rebuild-with-new-packages","title":"2.3 Rebuild with New Packages","text":"<pre><code>bitbake core-image-minimal\n</code></pre> <p>BitBake is intelligent: - Only rebuilds rootfs assembly - Reuses previously built packages - Downloads new package sources as needed</p> <p>Build takes ~5-10 minutes (not full rebuild).</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#24-verify-package-inclusion","title":"2.4 Verify Package Inclusion","text":"<p>After build completes: <pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\ntar -tf core-image-minimal-beagleplay.rootfs.tar.xz | grep -E \"(dropbear|strace|htop)\"\n</code></pre></p> <p>Expected output: <pre><code>./usr/sbin/dropbear\n./usr/bin/strace\n./usr/bin/htop\n...\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#25-remove-packages","title":"2.5 Remove Packages","text":"<p>Use <code>IMAGE_INSTALL:remove</code>: <pre><code>IMAGE_INSTALL:remove = \"packagegroup-core-boot-dev\"\n</code></pre></p> <p>Or override completely: <pre><code>IMAGE_INSTALL = \"packagegroup-core-boot dropbear\"\n</code></pre></p> <p>\u26a0\ufe0f  WARNING (in large, friendly letters): Complete override breaks things - use <code>:append</code>/<code>:remove</code> instead.</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#3-setting-up-network-boot-nfs-root","title":"3. Setting Up Network Boot (NFS Root)","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#31-why-nfs-root","title":"3.1 Why NFS Root?","text":"<p>Benefits: - No reflashing: Changes visible immediately - Fast iteration: Edit \u2192 sync \u2192 reboot (seconds) - Easy debugging: Full access to rootfs from host - Unlimited space: No SD card size constraints</p> <p>When to use: - Active development - Kernel/driver debugging - Application testing</p> <p>When NOT to use: - Production deployment - Performance benchmarking (network overhead) - Testing storage-specific features</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#32-install-nfs-server","title":"3.2 Install NFS Server","text":"<p>On development workstation: <pre><code>sudo apt install nfs-kernel-server\n</code></pre></p> <p>Create NFS export directory: <pre><code>sudo mkdir -p /nfs/beagleplay\nsudo chown -R $USER:$USER /nfs/beagleplay\nchmod 755 /nfs/beagleplay\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#33-configure-nfs-exports","title":"3.3 Configure NFS Exports","text":"<p>Edit <code>/etc/exports</code>: <pre><code>sudo nano /etc/exports\n</code></pre></p> <p>Add export entry: <pre><code>/nfs/beagleplay *(rw,sync,no_root_squash,no_subtree_check)\n</code></pre></p> <p>Explanation: - <code>*</code>: Allow any client (use <code>192.168.0.0/24</code> for security) - <code>rw</code>: Read-write access - <code>sync</code>: Synchronous writes (safer but slower) - <code>no_root_squash</code>: Don't map root UID to nobody - <code>no_subtree_check</code>: Faster, less safe (OK for development)</p> <p>Apply changes: <pre><code>sudo exportfs -ra\n</code></pre></p> <p>Verify export: <pre><code>sudo exportfs -v\n# Output: /nfs/beagleplay &lt;world&gt;(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,no_all_squash)\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#34-extract-rootfs-to-nfs","title":"3.4 Extract Rootfs to NFS","text":"<p>Clean NFS directory: <pre><code>sudo rm -rf /nfs/beagleplay/*\n</code></pre></p> <p>Extract latest build: <pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\nsudo tar -xf core-image-minimal-beagleplay.rootfs.tar.xz -C /nfs/beagleplay\n</code></pre></p> <p>Verify extraction: <pre><code>ls -l /nfs/beagleplay/\n# Output: bin boot dev etc home lib media mnt proc run sbin sys tmp usr var\n</code></pre></p> <p>Fix permissions: <pre><code>sudo chown -R root:root /nfs/beagleplay\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#35-configure-network-interface","title":"3.5 Configure Network Interface","text":"<p>Find your Ethernet interface: <pre><code>ip link show\n</code></pre></p> <p>Output (example): <pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; ...\n2: wlp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; ...  # WiFi\n3: enp0s25: &lt;BROADCAST,MULTICAST&gt; ...              # Wired Ethernet (DOWN)\n4: enx00e04c534458: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; ... # USB Ethernet\n</code></pre></p> <p>Your wired interface is likely <code>enp0s25</code> or <code>enx...</code></p> <p>Configure static IP using NetworkManager CLI: <pre><code>nmcli con add type ethernet \\\n    ifname enp0s25 \\\n    con-name beagleplay-eth \\\n    ip4 192.168.0.1/24\n</code></pre></p> <p>Activate connection: <pre><code>nmcli con up beagleplay-eth\n</code></pre></p> <p>Verify IP: <pre><code>ip addr show enp0s25\n# Should show: inet 192.168.0.1/24 ...\n</code></pre></p> <p>Alternative: Manual configuration (if nmcli fails): <pre><code>sudo ip addr add 192.168.0.1/24 dev enp0s25\nsudo ip link set enp0s25 up\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#4-configuring-beagleplay-for-nfs-boot","title":"4. Configuring BeaglePlay for NFS Boot","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#41-update-sd-card-boot-configuration","title":"4.1 Update SD Card Boot Configuration","text":"<p>Mount SD card boot partition: <pre><code># Insert SD card, check device name\nlsblk\n# Assuming /dev/sdb1 is boot partition\nsudo mount /dev/sdb1 /mnt\n</code></pre></p> <p>Edit extlinux.conf: <pre><code>sudo nano /mnt/extlinux/extlinux.conf\n</code></pre></p> <p>Original: <pre><code>LABEL Linux\n  KERNEL /Image\n  FDT /k3-am625-beagleplay.dtb\n  APPEND root=/dev/mmcblk0p2 rootwait rw console=ttyS2,115200n8\n</code></pre></p> <p>Modified for NFS: <pre><code>LABEL Linux\n  KERNEL /Image\n  FDT /k3-am625-beagleplay.dtb\n  APPEND root=/dev/nfs rw console=ttyS2,115200n8 nfsroot=192.168.0.1:/nfs/beagleplay,nfsvers=3,tcp ip=192.168.0.100:::::eth0\n</code></pre></p> <p>Kernel command line breakdown: - <code>root=/dev/nfs</code>: Use NFS instead of local partition - <code>nfsroot=192.168.0.1:/nfs/beagleplay,nfsvers=3,tcp</code>: NFS server and options - <code>ip=192.168.0.100:::::eth0</code>: Static IP (format: <code>client-ip:server-ip:gw-ip:netmask:hostname:device:autoconf</code>) - <code>console=ttyS2,115200n8</code>: Serial console</p> <p>Save and unmount: <pre><code>sudo sync\nsudo umount /mnt\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#42-connect-hardware","title":"4.2 Connect Hardware","text":"<p>Physical setup: 1. Connect Ethernet cable: BeaglePlay \u2194 Workstation (or switch) 2. Insert SD card into BeaglePlay 3. Connect serial console 4. Power on BeaglePlay</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#43-verify-nfs-boot","title":"4.3 Verify NFS Boot","text":"<p>Open serial console: <pre><code>picocom -b 115200 /dev/ttyUSB0\n</code></pre></p> <p>You should see during boot: <pre><code>[    2.456789] IP-Config: Complete:\n[    2.456790]      device=eth0, hwaddr=xx:xx:xx:xx:xx:xx, ipaddr=192.168.0.100\n[    2.789012] VFS: Mounted root (nfs filesystem) on device 0:18.\n</code></pre></p> <p>Verify NFS mount: <pre><code># At BeaglePlay shell\nmount | grep nfs\n# Output: 192.168.0.1:/nfs/beagleplay on / type nfs (rw,relatime,vers=3,...)\n</code></pre></p> <p>Test read-write access: <pre><code>touch /home/test-nfs-write\nls -l /home/\n</code></pre></p> <p>On workstation, verify file appeared: <pre><code>ls -l /nfs/beagleplay/home/\n# Should show test-nfs-write\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#5-rapid-development-workflow","title":"5. Rapid Development Workflow","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#51-modify-rootfs-without-rebuild","title":"5.1 Modify Rootfs Without Rebuild","text":"<p>Example: Add a test script</p> <p>On workstation: <pre><code>cat &gt; /nfs/beagleplay/usr/bin/hello-beagleplay &lt;&lt; 'EOF'\n#!/bin/sh\necho \"Hello from BeaglePlay!\"\necho \"IP: $(ip addr show eth0 | grep inet | awk '{print $2}')\"\necho \"Uptime: $(uptime)\"\nEOF\n\nchmod +x /nfs/beagleplay/usr/bin/hello-beagleplay\n</code></pre></p> <p>On BeaglePlay (reboot or just sync): <pre><code>hello-beagleplay\n</code></pre></p> <p>Output: <pre><code>Hello from BeaglePlay!\nIP: 192.168.0.100/24\nUptime: 14:32:45 up 3 min, load average: 0.12, 0.08, 0.03\n</code></pre></p> <p>No rebuild, no reflash - instant!</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#52-test-package-changes","title":"5.2 Test Package Changes","text":"<p>After rebuilding with new packages: <pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\nsudo rm -rf /nfs/beagleplay/*\nsudo tar -xf core-image-minimal-beagleplay.rootfs.tar.xz -C /nfs/beagleplay\nsudo chown -R root:root /nfs/beagleplay\n</code></pre></p> <p>Reboot BeaglePlay: <pre><code># On BeaglePlay console\nreboot\n</code></pre></p> <p>New packages available in ~30 seconds.</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#53-debugging-with-nfs-root","title":"5.3 Debugging with NFS Root","text":"<p>Install gdbserver in image: <pre><code># Edit local.conf\nIMAGE_INSTALL:append = \" gdbserver\"\nbitbake core-image-minimal\n</code></pre></p> <p>Extract to NFS, reboot BeaglePlay</p> <p>Cross-compile test program on host: <pre><code>source ~/yocto-labs/poky/oe-init-build-env\nbitbake core-image-minimal -c populate_sdk\n</code></pre></p> <p>Wait for SDK build, then install: <pre><code>cd ~/yocto-labs/build/tmp/deploy/sdk\n./poky-glibc-x86_64-core-image-minimal-cortexa53-beagleplay-toolchain-5.0.4.sh\n# Install to: /opt/poky/5.0.4\n</code></pre></p> <p>Write test program: <pre><code>cat &gt; /tmp/test.c &lt;&lt; 'EOF'\n#include &lt;stdio.h&gt;\nint main() {\n    for (int i = 0; i &lt; 10; i++) {\n        printf(\"Count: %d\\n\", i);\n    }\n    return 0;\n}\nEOF\n</code></pre></p> <p>Cross-compile: <pre><code>source /opt/poky/5.0.4/environment-setup-cortexa53-poky-linux\n$CC -g /tmp/test.c -o /nfs/beagleplay/tmp/test\n</code></pre></p> <p>Run on BeaglePlay with gdbserver: <pre><code>gdbserver :2345 /tmp/test\n</code></pre></p> <p>Debug from host: <pre><code>$GDB /nfs/beagleplay/tmp/test\n(gdb) target remote 192.168.0.100:2345\n(gdb) break main\n(gdb) continue\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#6-preferred-package-providers","title":"6. Preferred Package Providers","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#61-understanding-virtual-packages","title":"6.1 Understanding Virtual Packages","text":"<p>Virtual packages represent functionality, not specific implementations.</p> <p>Examples: - <code>virtual/kernel</code>: Provided by <code>linux-ti-staging</code>, <code>linux-yocto</code>, <code>linux-mainline</code>, etc. - <code>virtual/bootloader</code>: Provided by <code>u-boot</code>, <code>barebox</code>, etc. - <code>virtual/libc</code>: Provided by <code>glibc</code>, <code>musl</code>, <code>uclibc-ng</code></p> <p>Check current provider: <pre><code>bitbake -vn virtual/kernel\n</code></pre></p> <p>Output: <pre><code>NOTE: selecting linux-ti-staging to satisfy virtual/kernel due to PREFERRED_PROVIDERS\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#62-change-preferred-provider","title":"6.2 Change Preferred Provider","text":"<p>Switch kernel provider in local.conf: <pre><code>nano conf/local.conf\n</code></pre></p> <p>Add: <pre><code>PREFERRED_PROVIDER_virtual/kernel = \"linux-yocto\"\n</code></pre></p> <p>Verify change: <pre><code>bitbake -vn virtual/kernel\n# Output: NOTE: selecting linux-yocto to satisfy virtual/kernel due to PREFERRED_PROVIDERS\n</code></pre></p> <p>For BeaglePlay, stick with <code>linux-ti-staging</code> (TI-optimized kernel).</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#63-version-preferences","title":"6.3 Version Preferences","text":"<p>Pin specific version: <pre><code>PREFERRED_VERSION_linux-ti-staging = \"6.1%\"\n</code></pre></p> <p>Check available versions: <pre><code>bitbake-layers show-recipes linux-ti-staging\n</code></pre></p> <p>Output: <pre><code>linux-ti-staging:\n  meta-ti-bsp        6.1.83+gitAUTOINC+abcdef1234\n  meta-ti-bsp        6.6.32+gitAUTOINC+987654fedc\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#7-bitbake-deep-dive","title":"7. BitBake Deep Dive","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#71-task-execution-model","title":"7.1 Task Execution Model","text":"<p>Every recipe has tasks: <pre><code>do_fetch       \u2192 Download sources\ndo_unpack      \u2192 Extract archives\ndo_patch       \u2192 Apply patches\ndo_configure   \u2192 Run ./configure or cmake\ndo_compile     \u2192 Build the software\ndo_install     \u2192 Install to staging area\ndo_package     \u2192 Create binary packages (RPM/DEB/IPK)\ndo_package_write_* \u2192 Write package files\ndo_populate_sysroot \u2192 Install to sysroot for other recipes\n</code></pre></p> <p>List all tasks for a recipe: <pre><code>bitbake -c listtasks virtual/kernel\n</code></pre></p> <p>Output: <pre><code>do_build\ndo_fetch\ndo_unpack\ndo_patch\ndo_configure\ndo_menuconfig  # Special: interactive kernel config\ndo_compile\ndo_install\n...\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#72-execute-specific-tasks","title":"7.2 Execute Specific Tasks","text":"<p>Configure kernel interactively: <pre><code>bitbake -c menuconfig virtual/kernel\n</code></pre></p> <p>Opens kernel menuconfig in terminal.</p> <p>Save config, then rebuild: <pre><code>bitbake -c compile -f virtual/kernel  # Force recompile\nbitbake core-image-minimal            # Rebuild image with new kernel\n</code></pre></p> <p>Other useful task commands: <pre><code># Clean package (remove outputs but keep downloads)\nbitbake -c clean &lt;package&gt;\n\n# Clean shared state\nbitbake -c cleansstate &lt;package&gt;\n\n# Clean everything including downloads\nbitbake -c cleanall &lt;package&gt;\n\n# Fetch all sources without building\nbitbake --runall=fetch core-image-minimal\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#73-dependency-graphing","title":"7.3 Dependency Graphing","text":"<p>Generate task dependency graph: <pre><code>bitbake -g core-image-minimal\n</code></pre></p> <p>Creates files: - <code>pn-buildlist</code>: List of recipes to build - <code>task-depends.dot</code>: Task-level dependencies (massive) - <code>pn-depends.dot</code>: Recipe-level dependencies</p> <p>View recipe dependencies visually: <pre><code>sudo apt install graphviz\ndot -Tpng pn-depends.dot -o pn-depends.png\nxdg-open pn-depends.png\n</code></pre></p> <p>Filter to specific package: <pre><code>bitbake -g dropbear\ndot -Tpng pn-depends.dot -o dropbear-deps.png\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#74-dry-run-analysis","title":"7.4 Dry Run Analysis","text":"<p>Show what would be built without building: <pre><code>bitbake -vn core-image-minimal\n</code></pre></p> <p>Useful for: - Verifying <code>PREFERRED_PROVIDER</code> changes - Checking if changes trigger rebuilds - Debugging recipe selection issues</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#8-performance-optimization","title":"8. Performance Optimization","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#81-parallel-build-tuning","title":"8.1 Parallel Build Tuning","text":"<p>Edit local.conf: <pre><code>nano conf/local.conf\n</code></pre></p> <p>Add (adjust based on your CPU): <pre><code># Number of BitBake tasks to run in parallel\nBB_NUMBER_THREADS = \"8\"\n\n# Number of make jobs per package (-j flag)\nPARALLEL_MAKE = \"-j 8\"\n\n# Limit parallel tasks for specific packages (memory-intensive builds)\nPARALLEL_MAKE:pn-gcc = \"-j 4\"\nPARALLEL_MAKE:pn-llvm = \"-j 4\"\n</code></pre></p> <p>Guidelines: - <code>BB_NUMBER_THREADS</code>: Number of CPU cores - <code>PARALLEL_MAKE</code>: 1.5\u00d7 to 2\u00d7 CPU cores (if enough RAM) - Monitor with <code>htop</code> - adjust if thrashing</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#82-shared-state-cache","title":"8.2 Shared State Cache","text":"<p>Shared state (sstate-cache) stores intermediate build results.</p> <p>Benefits: - Rebuild from cache instead of source - Share between build directories - Dramatically speeds up CI/CD</p> <p>Configure shared cache: <pre><code># In local.conf\nSSTATE_DIR = \"/opt/yocto-shared/sstate-cache\"\n</code></pre></p> <p>Create directory: <pre><code>sudo mkdir -p /opt/yocto-shared/sstate-cache\nsudo chown -R $USER:$USER /opt/yocto-shared\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#83-download-directory","title":"8.3 Download Directory","text":"<p>Share downloads between projects: <pre><code># In local.conf\nDL_DIR = \"/opt/yocto-shared/downloads\"\n</code></pre></p> <p>Create directory: <pre><code>sudo mkdir -p /opt/yocto-shared/downloads\nsudo chown -R $USER:$USER /opt/yocto-shared\n</code></pre></p> <p>Saves bandwidth and time - sources downloaded once, reused forever.</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#84-remove-work-directories","title":"8.4 Remove Work Directories","text":"<p>Clean intermediate files to save disk: <pre><code># In local.conf\nINHERIT += \"rm_work\"\n\n# Exclude packages you might debug\nRM_WORK_EXCLUDE += \"linux-ti-staging u-boot-ti-staging\"\n</code></pre></p> <p>Saves 30-50GB but slows rebuilds (can't resume from intermediate steps).</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#85-use-buildhistory","title":"8.5 Use Buildhistory","text":"<p>Track what changed between builds: <pre><code># In local.conf\nINHERIT += \"buildhistory\"\nBUILDHISTORY_COMMIT = \"1\"\n</code></pre></p> <p>Creates Git repository tracking: - Package versions - Installed files - Image sizes - Dependency changes</p> <p>View history: <pre><code>cd ~/yocto-labs/build/buildhistory\ngit log --oneline\ngit diff HEAD~1 HEAD\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#9-network-boot-with-tftp","title":"9. Network Boot with TFTP","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#91-install-tftp-server","title":"9.1 Install TFTP Server","text":"<pre><code>sudo apt install tftpd-hpa\n</code></pre> <p>Configure: <pre><code>sudo nano /etc/default/tftpd-hpa\n</code></pre></p> <p>Content: <pre><code>TFTP_USERNAME=\"tftp\"\nTFTP_DIRECTORY=\"/srv/tftp\"\nTFTP_ADDRESS=\":69\"\nTFTP_OPTIONS=\"--secure\"\n</code></pre></p> <p>Create directory: <pre><code>sudo mkdir -p /srv/tftp\nsudo chown -R tftp:tftp /srv/tftp\nsudo chmod 755 /srv/tftp\n</code></pre></p> <p>Restart service: <pre><code>sudo systemctl restart tftpd-hpa\nsudo systemctl status tftpd-hpa\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#92-copy-kernel-and-device-tree","title":"9.2 Copy Kernel and Device Tree","text":"<pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\n\n# Copy kernel\nsudo cp Image /srv/tftp/\n\n# Copy Device Tree\nsudo cp k3-am625-beagleplay.dtb /srv/tftp/\n\n# Set permissions\nsudo chmod 644 /srv/tftp/*\n</code></pre>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#93-configure-u-boot-for-tftp","title":"9.3 Configure U-Boot for TFTP","text":"<p>Boot BeaglePlay, stop at U-Boot prompt (press space during countdown).</p> <p>Set network parameters: <pre><code>setenv ipaddr 192.168.0.100\nsetenv serverip 192.168.0.1\nsetenv gatewayip 192.168.0.1\n</code></pre></p> <p>Set boot command: <pre><code>setenv bootcmd 'tftp ${loadaddr} Image; tftp ${fdtaddr} k3-am625-beagleplay.dtb; booti ${loadaddr} - ${fdtaddr}'\n</code></pre></p> <p>Set kernel arguments: <pre><code>setenv bootargs 'root=/dev/nfs rw console=ttyS2,115200n8 nfsroot=192.168.0.1:/nfs/beagleplay,nfsvers=3,tcp ip=192.168.0.100:::::eth0'\n</code></pre></p> <p>Save and boot: <pre><code>saveenv\nboot\n</code></pre></p> <p>Now BeaglePlay boots: 1. Bootloader from SD card 2. Kernel via TFTP 3. Rootfs via NFS</p> <p>Ultimate development setup: - Kernel changes: Copy to <code>/srv/tftp/</code>, reboot - Rootfs changes: Edit in <code>/nfs/beagleplay/</code>, reboot or sync - No SD card reflashing ever</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#10-package-management","title":"10. Package Management","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#101-image-package-formats","title":"10.1 Image Package Formats","text":"<p>Yocto supports three package formats: - RPM: Red Hat Package Manager (default for Fedora-based) - DEB: Debian packages (default for Debian/Ubuntu-based) - IPK: Itsy Package Management (default for embedded, used by opkg)</p> <p>Set package format: <pre><code># In local.conf\nPACKAGE_CLASSES = \"package_ipk\"\n</code></pre></p> <p>For BeaglePlay, IPK is recommended (lightweight).</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#102-runtime-package-management","title":"10.2 Runtime Package Management","text":"<p>Enable package management on target: <pre><code># In local.conf\nEXTRA_IMAGE_FEATURES += \"package-management\"\n</code></pre></p> <p>This adds <code>opkg</code> to the image.</p> <p>Rebuild: <pre><code>bitbake core-image-minimal\n</code></pre></p> <p>On BeaglePlay: <pre><code>opkg update\nopkg list\nopkg install htop\n</code></pre></p> <p>Host package feed: <pre><code>cd ~/yocto-labs/build/tmp/deploy/ipk/\npython3 -m http.server 8000\n</code></pre></p> <p>Configure opkg on target: <pre><code># On BeaglePlay\ncat &gt; /etc/opkg/base-feeds.conf &lt;&lt; EOF\nsrc/gz all http://192.168.0.1:8000/all\nsrc/gz cortexa53 http://192.168.0.1:8000/cortexa53\nsrc/gz beagleplay http://192.168.0.1:8000/beagleplay\nEOF\n\nopkg update\nopkg install strace\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#103-package-inspection","title":"10.3 Package Inspection","text":"<p>List package contents: <pre><code>opkg files busybox\n</code></pre></p> <p>Show package info: <pre><code>opkg info dropbear\n</code></pre></p> <p>Search for files: <pre><code>opkg search /usr/bin/ssh\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#11-troubleshooting","title":"11. Troubleshooting","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#111-nfs-boot-issues","title":"11.1 NFS Boot Issues","text":"<p>Problem: <code>VFS: Unable to mount root fs via NFS</code></p> <p>Solutions: <pre><code># On workstation: verify NFS export\nsudo exportfs -v\n\n# Verify network connectivity (ping from U-Boot)\nping 192.168.0.1\n\n# Check kernel NFS support\nzcat /proc/config.gz | grep NFS\n# Should show: CONFIG_NFS_FS=y, CONFIG_ROOT_NFS=y\n</code></pre></p> <p>Problem: NFS mount succeeds but rootfs is empty</p> <p>Solution: <pre><code># Check extraction\nls -la /nfs/beagleplay/\n# Should contain bin/, etc/, usr/, not just empty directories\n\n# Re-extract\nsudo rm -rf /nfs/beagleplay/*\nsudo tar -xpf ~/yocto-labs/build/tmp/deploy/images/beagleplay/core-image-minimal-beagleplay.rootfs.tar.xz -C /nfs/beagleplay\n</code></pre></p> <p>Problem: Permission denied errors on NFS</p> <p>Solution: <pre><code># Fix ownership\nsudo chown -R root:root /nfs/beagleplay\n\n# Check exports has no_root_squash\nsudo cat /etc/exports\n# Should have: /nfs/beagleplay *(rw,sync,no_root_squash,no_subtree_check)\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#112-tftp-boot-issues","title":"11.2 TFTP Boot Issues","text":"<p>Problem: <code>TFTP error: file not found</code></p> <p>Solutions: <pre><code># Verify TFTP server running\nsudo systemctl status tftpd-hpa\n\n# Check file permissions\nls -l /srv/tftp/Image\n# Should be readable by all (644)\n\n# Test from command line\ntftp 192.168.0.1\ntftp&gt; get Image\ntftp&gt; quit\n</code></pre></p> <p>Problem: TFTP timeout</p> <p>Solutions: <pre><code># Check firewall\nsudo ufw status\nsudo ufw allow 69/udp\n\n# Verify server IP\nip addr show\n\n# Test with tcpdump\nsudo tcpdump -i enp0s25 port 69\n# Boot BeaglePlay and watch for TFTP requests\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#113-bitbake-issues","title":"11.3 BitBake Issues","text":"<p>Problem: <code>ERROR: Nothing PROVIDES 'package-name'</code></p> <p>Solution: <pre><code># Search for package\nbitbake-layers show-recipes | grep package-name\n\n# If not found, add layer containing it\nbitbake-layers show-layers\n# Check which layers have the package on layers.openembedded.org\n</code></pre></p> <p>Problem: Build fails with \"No space left on device\"</p> <p>Solution: <pre><code># Check disk space\ndf -h ~/yocto-labs/build/tmp\n\n# Clean up\nbitbake -c cleansstate core-image-minimal\nrm -rf ~/yocto-labs/build/tmp/work/*\n\n# Or enable rm_work in local.conf\n</code></pre></p> <p>Problem: <code>ERROR: Multiple .bb files are due to be built which each provide &lt;package&gt;</code></p> <p>Solution: <pre><code># Multiple recipes provide same package\n# Use PREFERRED_PROVIDER\nnano conf/local.conf\n\n# Add:\nPREFERRED_PROVIDER_&lt;package&gt; = \"recipe-name\"\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#12-going-further","title":"12. Going Further","text":""},{"location":"labs/yocto/lab11-yocto-advanced-config/#121-advanced-image_install-techniques","title":"12.1 Advanced IMAGE_INSTALL Techniques","text":"<p>Conditional package inclusion: <pre><code>IMAGE_INSTALL:append:beagleplay = \" ti-utils\"\nIMAGE_INSTALL:append:qemux86-64 = \" qemu-guest-agent\"\n</code></pre></p> <p>Feature-based inclusion: <pre><code>EXTRA_IMAGE_FEATURES += \"debug-tweaks ssh-server-dropbear\"\n</code></pre></p> <p>Package groups: <pre><code>IMAGE_INSTALL:append = \" \\\n    packagegroup-core-full-cmdline \\\n    packagegroup-core-buildessential \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#122-create-custom-package-group","title":"12.2 Create Custom Package Group","text":"<p>Create recipe <code>recipes-core/packagegroups/packagegroup-beagleplay-dev.bb</code>: <pre><code>DESCRIPTION = \"Development tools for BeaglePlay\"\nLICENSE = \"MIT\"\n\ninherit packagegroup\n\nRDEPENDS:${PN} = \" \\\n    htop \\\n    strace \\\n    gdbserver \\\n    i2c-tools \\\n    can-utils \\\n    mtd-utils \\\n\"\n</code></pre></p> <p>Use in image: <pre><code>IMAGE_INSTALL:append = \" packagegroup-beagleplay-dev\"\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#123-license-compliance","title":"12.3 License Compliance","text":"<p>Generate license manifest: <pre><code># In local.conf\nINHERIT += \"archiver\"\nCOPYLEFT_LICENSE_INCLUDE = \"*\"\nARCHIVER_MODE[src] = \"original\"\n</code></pre></p> <p>Rebuild: <pre><code>bitbake core-image-minimal\n</code></pre></p> <p>License files in: <pre><code>tmp/deploy/licenses/core-image-minimal-beagleplay-*/\n</code></pre></p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#13-key-takeaways","title":"13. Key Takeaways","text":"<p>What You Accomplished: 1. \u2705 Mastered BitBake configuration hierarchy 2. \u2705 Customized image with <code>IMAGE_INSTALL</code> 3. \u2705 Set up NFS root filesystem for rapid development 4. \u2705 Configured TFTP boot for kernel iteration 5. \u2705 Understood BitBake task execution model 6. \u2705 Optimized build performance</p> <p>Advanced Skills Gained: - Package provider selection - Network boot workflows - BitBake command-line tools - Performance tuning - Package management on target</p> <p>Development Workflow Established: <pre><code>Edit code \u2192 Build \u2192 Extract to NFS \u2192 Reboot (30 seconds)\n</code></pre></p> <p>Next Steps: - Lab 12: Add custom applications with recipes - Lab 13: Create custom Yocto layers - Lab 14: Extend recipes with bbappend - Lab 15: Define custom machine configurations</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#14-verification-checklist","title":"14. Verification Checklist","text":"<p>Before proceeding to Lab 12, verify:</p> <ul> <li>[ ] <code>IMAGE_INSTALL</code> customization works (packages added)</li> <li>[ ] NFS server running and exporting <code>/nfs/beagleplay</code></li> <li>[ ] BeaglePlay boots with NFS root successfully</li> <li>[ ] Network configured (192.168.0.1 host, 192.168.0.100 target)</li> <li>[ ] TFTP server operational (optional but recommended)</li> <li>[ ] Can modify rootfs and see changes on target without rebuild</li> <li>[ ] <code>bitbake -c menuconfig virtual/kernel</code> works</li> <li>[ ] Shared state cache configured for faster rebuilds</li> <li>[ ] Build completes in &lt;15 minutes for incremental changes</li> </ul> <p>Build time: ~10 minutes incremental, ~2 hours full rebuild Development cycle: &lt;1 minute (edit \u2192 sync \u2192 reboot) Success criteria: Working NFS boot with custom packages</p>"},{"location":"labs/yocto/lab11-yocto-advanced-config/#15-additional-resources","title":"15. Additional Resources","text":"<p>BitBake Documentation: - User Manual: https://docs.yoctoproject.org/bitbake/ - Variable Glossary: https://docs.yoctoproject.org/ref-manual/variables.html - Task Manual: https://docs.yoctoproject.org/overview-manual/concepts.html#tasks</p> <p>Yocto Configuration: - Dev Manual - Customizing Images: https://docs.yoctoproject.org/dev-manual/customizing-images.html - Mega Manual (searchable): https://docs.yoctoproject.org/singleindex.html</p> <p>Network Boot: - Linux NFS Root: https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt - U-Boot TFTP: https://docs.u-boot.org/en/latest/usage/cmd/tftp.html</p> <p>End of Lab 11</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>You now have an optimized Yocto development environment with network boot capabilities, enabling rapid iteration and efficient debugging. The next labs will teach you how to add your own applications and create reusable layers.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/","title":"Lab 12: Add Custom Application","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#objectives","title":"Objectives","text":"<p>Learn how to write Yocto recipes for custom applications, integrate third-party software, and handle build dependencies.</p> <p>What You'll Learn: - Write BitBake recipes from scratch - Handle source downloads and checksums - Manage build dependencies - Cross-compile applications with Makefiles - Integrate applications into rootfs images - Debug recipe build failures</p> <p>Time Required: 2-3 hours (or approximately 42 minutes in improbable circumstances)</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 10: First Yocto Project Build - Lab 11: Advanced Yocto Configuration</p> <p>Skills: - Understanding of Makefiles - Basic C programming knowledge - Familiarity with BitBake syntax</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#1-understanding-yocto-recipes","title":"1. Understanding Yocto Recipes","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#11-what-is-a-recipe","title":"1.1 What is a Recipe?","text":"<p>A recipe (<code>.bb</code> file) tells BitBake how to: 1. Fetch source code 2. Apply patches 3. Configure the build 4. Compile the software 5. Install binaries 6. Package results</p> <p>Recipe naming convention: <pre><code>&lt;package-name&gt;_&lt;version&gt;.bb\n</code></pre></p> <p>Examples: - <code>busybox_1.36.1.bb</code> - <code>dropbear_2022.83.bb</code> - <code>ninvaders_0.1.1.bb</code></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#12-recipe-anatomy","title":"1.2 Recipe Anatomy","text":"<p>Minimal recipe structure: <pre><code># Metadata\nSUMMARY = \"Brief description\"\nDESCRIPTION = \"Longer description\"\nHOMEPAGE = \"https://project.org\"\nLICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://LICENSE;md5=...\"\n\n# Source location\nSRC_URI = \"https://example.com/app-${PV}.tar.gz\"\nSRC_URI[sha256sum] = \"...\"\n\n# Dependencies\nDEPENDS = \"ncurses\"\n\n# Build tasks (usually inherited or default)\ninherit autotools  # or cmake, meson, etc.\n\n# Custom tasks if needed\ndo_install:append() {\n    install -d ${D}${bindir}\n    install -m 0755 myapp ${D}${bindir}/\n}\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#13-common-recipe-variables","title":"1.3 Common Recipe Variables","text":"Variable Purpose Example <code>PN</code> Package name <code>ninvaders</code> <code>PV</code> Package version <code>0.1.1</code> <code>S</code> Source directory <code>${WORKDIR}/ninvaders-${PV}</code> <code>D</code> Destination (install root) <code>/path/to/image/</code> <code>WORKDIR</code> Recipe work directory <code>tmp/work/.../ninvaders/0.1.1/</code> <code>B</code> Build directory Usually same as <code>${S}</code> <code>bindir</code> Binary install path <code>/usr/bin</code> <code>libdir</code> Library install path <code>/usr/lib</code> <p>Variable expansion: - <code>${VAR}</code>: Reference variable - <code>${@python_code}</code>: Inline Python</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#2-project-selection-ninvaders","title":"2. Project Selection: nInvaders","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#21-about-ninvaders","title":"2.1 About nInvaders","text":"<p>nInvaders is a terminal-based Space Invaders clone using ncurses.</p> <p>Project details: - Homepage: https://ninvaders.sourceforge.net/ - License: GPL-2.0 - Language: C - Build system: Make - Dependencies: ncurses library</p> <p>Why this project? - Simple enough to understand - Real-world build challenges (cross-compilation) - Demonstrates dependency handling - Fun to test!</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#22-investigate-upstream-source","title":"2.2 Investigate Upstream Source","text":"<p>Download and inspect: <pre><code>cd /tmp\nwget http://downloads.sourceforge.net/ninvaders/ninvaders-0.1.1.tar.gz\ntar -xzf ninvaders-0.1.1.tar.gz\ncd ninvaders-0.1.1\n</code></pre></p> <p>Check files: <pre><code>ls -l\n# Output: COPYING  Makefile  README  aliens.c  aliens.h  globals.h  nInvaders.c  nInvaders.h  ufo.c  view.c\n</code></pre></p> <p>Review license: <pre><code>head -20 COPYING\n# GPL-2.0\n</code></pre></p> <p>Examine Makefile: <pre><code>cat Makefile\n</code></pre></p> <p>Key observations: <pre><code>CC = gcc\nCFLAGS = -O2\nLIBS = -lncurses\n\nall: nInvaders\n\nnInvaders: $(OBJS)\n    $(CC) $(CFLAGS) -o nInvaders $(OBJS) $(LIBS)\n\ninstall: nInvaders\n    cp nInvaders /usr/bin\n</code></pre></p> <p>Issues for cross-compilation: - Hardcoded <code>gcc</code> (should use <code>${CC}</code> from environment) - Install path not configurable (<code>/usr/bin</code> hardcoded) - No <code>DESTDIR</code> support</p> <p>We'll fix these in the recipe.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#3-creating-the-recipe-structure","title":"3. Creating the Recipe Structure","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#31-recipe-location","title":"3.1 Recipe Location","text":"<p>Recipes belong in layers. For now, we'll add to <code>meta-poky</code> (not recommended for production, but simple for learning).</p> <p>Create recipe directory: <pre><code>cd ~/yocto-labs/poky\nmkdir -p meta-poky/recipes-extended/ninvaders\n</code></pre></p> <p>Why <code>recipes-extended</code>? - Yocto convention for non-core packages - Other common directories: <code>recipes-core</code>, <code>recipes-kernel</code>, <code>recipes-graphics</code>, <code>recipes-connectivity</code></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#32-create-recipe-file","title":"3.2 Create Recipe File","text":"<pre><code>cd ~/yocto-labs/poky/meta-poky/recipes-extended/ninvaders\nnano ninvaders_0.1.1.bb\n</code></pre> <p>Start with minimal metadata: <pre><code>SUMMARY = \"nInvaders - ncurses-based Space Invaders clone\"\nDESCRIPTION = \"A terminal-based Space Invaders game using the ncurses library. \\\nControl your ship and defend against descending aliens!\"\nHOMEPAGE = \"https://ninvaders.sourceforge.net/\"\nLICENSE = \"GPL-2.0-only\"\n\nSRC_URI = \"http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz\"\n</code></pre></p> <p>Save and try to build: <pre><code>cd ~/yocto-labs/build\nbitbake ninvaders\n</code></pre></p> <p>Expected error: <pre><code>ERROR: ninvaders-0.1.1-r0 do_fetch: Fetcher failure: Unable to get checksum for ninvaders SRC_URI entry ninvaders-0.1.1.tar.gz: file could not be found\n</code></pre></p> <p>BitBake won't download without checksum verification (security feature).</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#4-adding-checksums","title":"4. Adding Checksums","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#41-generate-sha256-checksum","title":"4.1 Generate SHA256 Checksum","text":"<p>On your workstation: <pre><code>wget http://downloads.sourceforge.net/ninvaders/ninvaders-0.1.1.tar.gz\nsha256sum ninvaders-0.1.1.tar.gz\n</code></pre></p> <p>Output (example): <pre><code>0e20b62aa8fe4a8e8ec977a5b3834f0648dd606c20c0aae903d9a96fc2aba16c  ninvaders-0.1.1.tar.gz\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#42-update-recipe-with-checksum","title":"4.2 Update Recipe with Checksum","text":"<p>Edit <code>ninvaders_0.1.1.bb</code>: <pre><code>SUMMARY = \"nInvaders - ncurses-based Space Invaders clone\"\nDESCRIPTION = \"A terminal-based Space Invaders game using the ncurses library. \\\nControl your ship and defend against descending aliens!\"\nHOMEPAGE = \"https://ninvaders.sourceforge.net/\"\nLICENSE = \"GPL-2.0-only\"\n\nSRC_URI = \"http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz\"\nSRC_URI[sha256sum] = \"0e20b62aa8fe4a8e8ec977a5b3834f0648dd606c20c0aae903d9a96fc2aba16c\"\n</code></pre></p> <p>Try building again: <pre><code>bitbake ninvaders\n</code></pre></p> <p>New error: <pre><code>ERROR: ninvaders-0.1.1-r0 do_populate_lic: QA Issue: ninvaders: LIC_FILES_CHKSUM not specified for /path/to/sources\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#43-add-license-checksum","title":"4.3 Add License Checksum","text":"<p>License files must also be checksummed to detect license changes.</p> <p>Check license file in extracted source: <pre><code>cd ~/yocto-labs/build/tmp/work/cortexa53-poky-linux/ninvaders/0.1.1-r0/ninvaders-0.1.1\ncat COPYING | head -5\n</code></pre></p> <p>Generate checksum: <pre><code>md5sum COPYING\n# Output: 8ca43cbc842c2336e835926c2166c28b  COPYING\n</code></pre></p> <p>Update recipe: <pre><code>LICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=8ca43cbc842c2336e835926c2166c28b\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#5-handling-dependencies","title":"5. Handling Dependencies","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#51-identify-runtime-dependencies","title":"5.1 Identify Runtime Dependencies","text":"<p>nInvaders uses ncurses for terminal graphics.</p> <p>Two types of dependencies: - DEPENDS: Build-time (headers, libraries needed during compilation) - RDEPENDS: Runtime (binaries/libraries needed on target)</p> <p>For ncurses: <pre><code>DEPENDS = \"ncurses\"\n</code></pre></p> <p>BitBake will build ncurses before ninvaders.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#52-full-recipe-so-far","title":"5.2 Full Recipe So Far","text":"<pre><code>SUMMARY = \"nInvaders - ncurses-based Space Invaders clone\"\nDESCRIPTION = \"A terminal-based Space Invaders game using the ncurses library. \\\nControl your ship and defend against descending aliens!\"\nHOMEPAGE = \"https://ninvaders.sourceforge.net/\"\nLICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=8ca43cbc842c2336e835926c2166c28b\"\n\nDEPENDS = \"ncurses\"\n\nSRC_URI = \"http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz\"\nSRC_URI[sha256sum] = \"0e20b62aa8fe4a8e8ec977a5b3834f0648dd606c20c0aae903d9a96fc2aba16c\"\n</code></pre> <p>Try building: <pre><code>bitbake -c cleanall ninvaders\nbitbake ninvaders\n</code></pre></p> <p>New error: <pre><code>ERROR: ninvaders-0.1.1-r0 do_compile: oe_runmake failed\n...\nmultiple definition of `skill_level'\naliens.o:(.bss+0x674): first defined here\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#6-fixing-compilation-issues","title":"6. Fixing Compilation Issues","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#61-understanding-the-error","title":"6.1 Understanding the Error","text":"<p>GCC 10+ enforces stricter rules: - Multiple definitions of global variables across compilation units now error (previously just warnings) - nInvaders code has this issue (old codebase)</p> <p>Solution: Use <code>-fcommon</code> flag to revert to old behavior.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#62-add-cflags-override","title":"6.2 Add CFLAGS Override","text":"<p>Update recipe: <pre><code>SUMMARY = \"nInvaders - ncurses-based Space Invaders clone\"\nDESCRIPTION = \"A terminal-based Space Invaders game using the ncurses library. \\\nControl your ship and defend against descending aliens!\"\nHOMEPAGE = \"https://ninvaders.sourceforge.net/\"\nLICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=8ca43cbc842c2336e835926c2166c28b\"\n\nDEPENDS = \"ncurses\"\n\nSRC_URI = \"http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz\"\nSRC_URI[sha256sum] = \"0e20b62aa8fe4a8e8ec977a5b3834f0648dd606c20c0aae903d9a96fc2aba16c\"\n\n# Fix for GCC 10+ multiple definition errors\nCFLAGS:append = \" -fcommon\"\n</code></pre></p> <p>Try again: <pre><code>bitbake -c cleanall ninvaders\nbitbake ninvaders\n</code></pre></p> <p>New error: <pre><code>ERROR: ninvaders-0.1.1-r0 do_install: Function failed: do_install\n...\nmake: *** No rule to make target 'install'.  Stop.\n</code></pre></p> <p>BitBake expects an <code>install</code> target, but nInvaders Makefile only has manual install.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#7-custom-install-task","title":"7. Custom Install Task","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#71-override-do_install","title":"7.1 Override do_install","text":"<p>The <code>do_install</code> task copies built files to staging area (<code>${D}</code>).</p> <p>Add to recipe: <pre><code>do_install() {\n    # Create binary directory\n    install -d ${D}${bindir}\n\n    # Install the nInvaders binary\n    install -m 0755 ${B}/nInvaders ${D}${bindir}/ninvaders\n}\n</code></pre></p> <p>Explanation: - <code>install -d</code>: Create directory - <code>${D}</code>: Destination root (rootfs staging area) - <code>${bindir}</code>: <code>/usr/bin</code> (standard binary path) - <code>install -m 0755</code>: Copy with executable permissions - <code>${B}/nInvaders</code>: Source (built binary in build directory) - Rename <code>nInvaders</code> \u2192 <code>ninvaders</code> (lowercase, Linux convention)</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#72-full-working-recipe","title":"7.2 Full Working Recipe","text":"<pre><code>SUMMARY = \"nInvaders - ncurses-based Space Invaders clone\"\nDESCRIPTION = \"A terminal-based Space Invaders game using the ncurses library. \\\nControl your ship and defend against descending aliens!\"\nHOMEPAGE = \"https://ninvaders.sourceforge.net/\"\nLICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=8ca43cbc842c2336e835926c2166c28b\"\n\nDEPENDS = \"ncurses\"\n\nSRC_URI = \"http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz\"\nSRC_URI[sha256sum] = \"0e20b62aa8fe4a8e8ec977a5b3834f0648dd606c20c0aae903d9a96fc2aba16c\"\n\n# Fix for GCC 10+ multiple definition errors\nCFLAGS:append = \" -fcommon\"\n\ndo_install() {\n    install -d ${D}${bindir}\n    install -m 0755 ${B}/nInvaders ${D}${bindir}/ninvaders\n}\n</code></pre> <p>Build: <pre><code>bitbake -c cleanall ninvaders\nbitbake ninvaders\n</code></pre></p> <p>Should succeed!</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#8-integrating-into-image","title":"8. Integrating into Image","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#81-add-to-image_install","title":"8.1 Add to IMAGE_INSTALL","text":"<p>Edit <code>conf/local.conf</code>: <pre><code>nano conf/local.conf\n</code></pre></p> <p>Add ninvaders: <pre><code>IMAGE_INSTALL:append = \" ninvaders\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#82-rebuild-root-filesystem","title":"8.2 Rebuild Root Filesystem","text":"<pre><code>bitbake core-image-minimal\n</code></pre> <p>Only rebuilds rootfs assembly - fast (1-2 minutes).</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#83-deploy-to-nfs","title":"8.3 Deploy to NFS","text":"<pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\nsudo rm -rf /nfs/beagleplay/*\nsudo tar -xf core-image-minimal-beagleplay.rootfs.tar.xz -C /nfs/beagleplay\nsudo chown -R root:root /nfs/beagleplay\n</code></pre> <p>Verify binary is included: <pre><code>find /nfs/beagleplay -name ninvaders\n# Output: /nfs/beagleplay/usr/bin/ninvaders\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#9-testing-on-target","title":"9. Testing on Target","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#91-boot-beagleplay-with-nfs-root","title":"9.1 Boot BeaglePlay with NFS Root","text":"<p>Boot sequence: 1. Power on BeaglePlay 2. Wait for login prompt 3. Login as <code>root</code></p> <p>Verify ninvaders is installed: <pre><code>which ninvaders\n# Output: /usr/bin/ninvaders\n\nninvaders --version\n# May not have --version, just run it\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#92-run-ninvaders","title":"9.2 Run nInvaders","text":"<pre><code>ninvaders\n</code></pre> <p>You should see: <pre><code>  _   _   ___                     _               \n | \\ | | |_ _|  _ __  __   ____ _| |   ___   _ _ \n |  \\| |  | |  | '_ \\ \\ \\ / / _` | |  / _ \\ | '_|\n | |\\  |  | |  | | | | \\ V / (_| | | |  __/ |\n |_| \\_| |___| |_| |_|  \\_/ \\__,_|_|  \\___| |_|\n\nPress SPACE to start, Q to quit\n</code></pre></p> <p>Controls: - Arrow keys: Move ship - Space: Fire - Q: Quit</p> <p>Play the game! \ud83c\udfae</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#10-recipe-debugging","title":"10. Recipe Debugging","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#101-explore-work-directory","title":"10.1 Explore Work Directory","text":"<p>Recipe work directory: <pre><code>cd ~/yocto-labs/build/tmp/work/cortexa53-poky-linux/ninvaders/0.1.1-r0\nls -l\n</code></pre></p> <p>Structure: <pre><code>ninvaders-0.1.1/    # Extracted sources (S variable)\ntemp/               # Build logs and scripts\nimage/              # Installed files (D variable)\npackage/            # Packaged files\ndeploy-debs/        # Binary packages (if using DEB)\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#102-check-build-logs","title":"10.2 Check Build Logs","text":"<p>Compilation log: <pre><code>cat temp/log.do_compile\n</code></pre></p> <p>Shows full compiler output - useful for debugging build failures.</p> <p>Install log: <pre><code>cat temp/log.do_install\n</code></pre></p> <p>All task logs: <pre><code>ls temp/log.do_*\n# Output: log.do_compile  log.do_configure  log.do_fetch  log.do_install  log.do_package  ...\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#103-examine-task-scripts","title":"10.3 Examine Task Scripts","text":"<p>BitBake generates shell scripts for each task: <pre><code>cat temp/run.do_compile\n</code></pre></p> <p>Shows exactly what commands BitBake runs - great for debugging.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#104-manual-build-testing","title":"10.4 Manual Build Testing","text":"<p>Enter devshell (interactive build environment): <pre><code>bitbake -c devshell ninvaders\n</code></pre></p> <p>Opens new terminal in build directory with all environment variables set.</p> <p>Manually test commands: <pre><code># In devshell\nmake clean\nmake\nls -l nInvaders\n</code></pre></p> <p>Exit when done: <pre><code>exit\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#11-advanced-recipe-techniques","title":"11. Advanced Recipe Techniques","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#111-add-build-optimizations","title":"11.1 Add Build Optimizations","text":"<p>Customize Makefile variables: <pre><code>EXTRA_OEMAKE = \"'CC=${CC}' 'CFLAGS=${CFLAGS}' 'LDFLAGS=${LDFLAGS}'\"\n</code></pre></p> <p>This ensures cross-compilation toolchain is used.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#112-apply-patches","title":"11.2 Apply Patches","text":"<p>If you need to patch source code:</p> <p>Create patch file: <pre><code>cd ~/yocto-labs/poky/meta-poky/recipes-extended/ninvaders\nmkdir files\nnano files/0001-fix-install-path.patch\n</code></pre></p> <p>Add patch to SRC_URI: <pre><code>SRC_URI = \" \\\n    http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz \\\n    file://0001-fix-install-path.patch \\\n\"\n</code></pre></p> <p>BitBake automatically applies patches in <code>do_patch</code> task.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#113-add-configuration-options","title":"11.3 Add Configuration Options","text":"<p>Use autotools classes for configure-based projects: <pre><code>inherit autotools\n</code></pre></p> <p>For CMake projects: <pre><code>inherit cmake\n</code></pre></p> <p>For Meson projects: <pre><code>inherit meson\n</code></pre></p> <p>nInvaders uses plain Makefile - no inheritance needed.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#114-package-multiple-binaries","title":"11.4 Package Multiple Binaries","text":"<p>If application has multiple binaries: <pre><code>do_install() {\n    install -d ${D}${bindir}\n    install -m 0755 ${B}/ninvaders ${D}${bindir}/\n    install -m 0755 ${B}/ninvaders-server ${D}${bindir}/\n}\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#115-install-additional-files","title":"11.5 Install Additional Files","text":"<p>Install documentation: <pre><code>do_install:append() {\n    install -d ${D}${docdir}/${PN}\n    install -m 0644 ${S}/README ${D}${docdir}/${PN}/\n}\n</code></pre></p> <p>Install configuration files: <pre><code>do_install:append() {\n    install -d ${D}${sysconfdir}\n    install -m 0644 ${S}/config.conf ${D}${sysconfdir}/ninvaders.conf\n}\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#12-recipe-best-practices","title":"12. Recipe Best Practices","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#121-mandatory-variables","title":"12.1 Mandatory Variables","text":"<p>Always define: - <code>SUMMARY</code>: Short description - <code>HOMEPAGE</code>: Project URL - <code>LICENSE</code>: SPDX identifier - <code>LIC_FILES_CHKSUM</code>: License file checksum</p> <p>Recommended: - <code>DESCRIPTION</code>: Detailed description - <code>SECTION</code>: Package category (games, utils, libs) - <code>AUTHOR</code>: Package maintainer</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#122-naming-conventions","title":"12.2 Naming Conventions","text":"<p>Recipe files: - <code>package-name_version.bb</code> - Use lowercase - Separate words with hyphens</p> <p>Version examples: - <code>ninvaders_0.1.1.bb</code> (specific version) - <code>ninvaders_git.bb</code> (tracking Git HEAD) - <code>ninvaders_1.0+gitAUTOINC.bb</code> (Git with auto-version)</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#123-license-identifiers","title":"12.3 License Identifiers","text":"<p>Use SPDX standard: - <code>GPL-2.0-only</code> (not <code>GPLv2</code>) - <code>MIT</code> - <code>Apache-2.0</code> - <code>BSD-3-Clause</code></p> <p>Multiple licenses: <pre><code>LICENSE = \"GPL-2.0-only &amp; MIT\"\nLIC_FILES_CHKSUM = \" \\\n    file://COPYING.GPL;md5=... \\\n    file://LICENSE.MIT;md5=... \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#124-source-uri-best-practices","title":"12.4 Source URI Best Practices","text":"<p>Prefer HTTPS over HTTP: <pre><code>SRC_URI = \"https://example.com/package-${PV}.tar.gz\"\n</code></pre></p> <p>Use mirrors for reliability: <pre><code>SRC_URI = \" \\\n    https://example.com/package-${PV}.tar.gz \\\n    https://mirror.example.org/package-${PV}.tar.gz \\\n\"\n</code></pre></p> <p>Git repositories: <pre><code>SRC_URI = \"git://github.com/user/project.git;protocol=https;branch=main\"\nSRCREV = \"abc123def456...\"  # Specific commit\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#13-troubleshooting","title":"13. Troubleshooting","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#131-build-failures","title":"13.1 Build Failures","text":"<p>Problem: <code>ERROR: &lt;package&gt; do_compile failed</code></p> <p>Solutions: <pre><code># Check compilation log\ncat tmp/work/.../temp/log.do_compile\n\n# Enter devshell to test manually\nbitbake -c devshell &lt;package&gt;\n\n# Clean and rebuild\nbitbake -c cleanall &lt;package&gt;\nbitbake &lt;package&gt;\n</code></pre></p> <p>Problem: Cross-compilation uses host compiler</p> <p>Solution: <pre><code># Ensure Makefile uses BitBake's CC\nEXTRA_OEMAKE = \"'CC=${CC}'\"\n\n# Or fix Makefile with patch\n</code></pre></p> <p>Problem: Library not found during linking</p> <p>Solution: <pre><code># Add library to DEPENDS\nDEPENDS = \"ncurses openssl zlib\"\n\n# Manually specify linker flags if needed\nLDFLAGS:append = \" -lmylib\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#132-checksum-mismatches","title":"13.2 Checksum Mismatches","text":"<p>Problem: <code>Checksum mismatch for &lt;file&gt;</code></p> <p>Solutions: <pre><code># Upstream changed tarball - recalculate\nwget &lt;url&gt;\nsha256sum &lt;file&gt;\n\n# Update SRC_URI[sha256sum]\n</code></pre></p> <p>Problem: License checksum mismatch</p> <p>Solution: <pre><code># License file changed - update\ncd tmp/work/.../package-version/package-version/\nmd5sum LICENSE\n\n# Update LIC_FILES_CHKSUM\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#133-installation-issues","title":"13.3 Installation Issues","text":"<p>Problem: <code>ERROR: &lt;package&gt; do_install failed</code></p> <p>Solutions: <pre><code># Check if Makefile has install target\ngrep -n install Makefile\n\n# If not, implement custom do_install\ndo_install() {\n    install -d ${D}${bindir}\n    install -m 0755 ${B}/binary ${D}${bindir}/\n}\n</code></pre></p> <p>Problem: Installed files missing from package</p> <p>Solution: <pre><code># Check what was installed\nls tmp/work/.../image/\n\n# Check package contents\nbitbake -e &lt;package&gt; | grep \"^FILES:\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#14-going-further","title":"14. Going Further","text":""},{"location":"labs/yocto/lab12-yocto-custom-app/#141-create-recipe-for-another-application","title":"14.1 Create Recipe for Another Application","text":"<p>Try packaging a different application:</p> <p>Example: htop (system monitor) - Homepage: https://htop.dev/ - Build system: Autotools - Dependencies: ncurses</p> <p>Hints: <pre><code>inherit autotools pkgconfig\nDEPENDS = \"ncurses\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#142-package-from-git","title":"14.2 Package from Git","text":"<p>Recipe for Git repository: <pre><code>SRC_URI = \"git://github.com/user/project.git;protocol=https;branch=main\"\nSRCREV = \"${AUTOREV}\"  # Always use latest (not recommended for production)\nPV = \"1.0+git${SRCPV}\"\n</code></pre></p> <p>Pin to specific commit (recommended): <pre><code>SRCREV = \"abc123def456789...\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#143-multi-package-recipes","title":"14.3 Multi-Package Recipes","text":"<p>Split binary and libraries: <pre><code>PACKAGES =+ \"${PN}-libs\"\n\nFILES:${PN}-libs = \"${libdir}/lib*.so.*\"\nFILES:${PN} = \"${bindir}/*\"\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#144-runtime-package-recommendations","title":"14.4 Runtime Package Recommendations","text":"<p>Suggest optional packages: <pre><code>RRECOMMENDS:${PN} = \"package-data package-docs\"\n</code></pre></p> <p>Installed if available, but not required.</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#15-key-takeaways","title":"15. Key Takeaways","text":"<p>What You Accomplished: 1. \u2705 Wrote a complete BitBake recipe from scratch 2. \u2705 Handled source downloads with checksums 3. \u2705 Managed build dependencies 4. \u2705 Fixed cross-compilation issues 5. \u2705 Implemented custom install task 6. \u2705 Integrated application into rootfs image 7. \u2705 Tested on hardware</p> <p>Recipe Development Skills: - Checksum generation (SHA256, MD5) - License compliance - Dependency declaration - Build customization (CFLAGS, LDFLAGS) - Installation scripting - Debugging techniques</p> <p>Next Steps: - Lab 13: Organize recipes into custom layers - Lab 14: Extend existing recipes with bbappend - Lab 15: Create custom machine configurations</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#16-verification-checklist","title":"16. Verification Checklist","text":"<p>Before proceeding to Lab 13, verify:</p> <ul> <li>[ ] <code>ninvaders_0.1.1.bb</code> recipe builds without errors</li> <li>[ ] <code>bitbake ninvaders</code> completes successfully</li> <li>[ ] Binary installed in rootfs at <code>/usr/bin/ninvaders</code></li> <li>[ ] nInvaders runs on BeaglePlay hardware</li> <li>[ ] Understand recipe metadata (LICENSE, HOMEPAGE, etc.)</li> <li>[ ] Understand checksums (SRC_URI, LIC_FILES_CHKSUM)</li> <li>[ ] Can navigate recipe work directory</li> <li>[ ] Can read build logs (temp/log.do_*)</li> <li>[ ] Understand do_install task</li> </ul> <p>Build time: ~5 minutes Recipe lines: ~20 lines Success criteria: Playable game on target hardware</p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#17-complete-recipe-reference","title":"17. Complete Recipe Reference","text":"<p>Final <code>ninvaders_0.1.1.bb</code>: <pre><code>SUMMARY = \"nInvaders - ncurses-based Space Invaders clone\"\nDESCRIPTION = \"A terminal-based Space Invaders game using the ncurses library. \\\nControl your ship and defend against descending aliens!\"\nHOMEPAGE = \"https://ninvaders.sourceforge.net/\"\nSECTION = \"games\"\nLICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=8ca43cbc842c2336e835926c2166c28b\"\n\nDEPENDS = \"ncurses\"\n\nSRC_URI = \"http://downloads.sourceforge.net/ninvaders/ninvaders-${PV}.tar.gz\"\nSRC_URI[sha256sum] = \"0e20b62aa8fe4a8e8ec977a5b3834f0648dd606c20c0aae903d9a96fc2aba16c\"\n\n# Fix for GCC 10+ multiple definition errors\nCFLAGS:append = \" -fcommon\"\n\n# Ensure cross-compiler is used\nEXTRA_OEMAKE = \"'CC=${CC}' 'CFLAGS=${CFLAGS} -I${STAGING_INCDIR}' 'LDFLAGS=${LDFLAGS}'\"\n\ndo_install() {\n    install -d ${D}${bindir}\n    install -m 0755 ${B}/nInvaders ${D}${bindir}/ninvaders\n}\n</code></pre></p>"},{"location":"labs/yocto/lab12-yocto-custom-app/#18-additional-resources","title":"18. Additional Resources","text":"<p>Yocto Recipe Writing: - BitBake User Manual - Syntax: https://docs.yoctoproject.org/bitbake/user-manual/ - Yocto Dev Manual - Writing Recipes: https://docs.yoctoproject.org/dev-manual/new-recipe.html - Variable Reference: https://docs.yoctoproject.org/ref-manual/variables.html</p> <p>OpenEmbedded Layers: - Layer Index (search existing recipes): https://layers.openembedded.org/ - Recipe Style Guide: https://www.openembedded.org/wiki/Styleguide</p> <p>Debugging: - BitBake Logging: https://docs.yoctoproject.org/dev-manual/debugging.html - Devshell Usage: https://docs.yoctoproject.org/dev-manual/dev-manual-common-tasks.html#using-a-development-shell</p> <p>End of Lab 12</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>You can now create BitBake recipes for custom applications, handle dependencies, and integrate software into Yocto-based Linux distributions. The next lab will teach you how to organize recipes into proper layers for maintainability and reusability.</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/","title":"Lab 13: Create a Custom Yocto Layer","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about Yocto:</p> <p>\"The Yocto Project is a build system of such staggering complexity that it makes the Infinite Improbability Drive look straightforward. However, once you understand it (which will take approximately 42 tries), it's actually quite brilliant.\"</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#objectives","title":"Objectives","text":"<p>Learn to organize recipes into custom layers for maintainability, reusability, and proper project structure following Yocto best practices.</p> <p>What You'll Learn: - Create custom meta-layers from scratch - Configure layer priority and dependencies - Organize recipes within layers - Integrate layers into build configuration - Move recipes between layers - Understand layer indexing</p> <p>Time Required: 1-2 hours</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 10-12: Yocto basics and recipe writing</p> <p>Knowledge: - BitBake recipe structure - Layer configuration concepts</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#1-why-custom-layers","title":"1. Why Custom Layers?","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#11-layer-organization-benefits","title":"1.1 Layer Organization Benefits","text":"<p>Without layers: All recipes mixed in meta/ or meta-poky/ - Hard to maintain - Difficult to share - No clear ownership - Breaks on Yocto updates</p> <p>With custom layers: - \u2705 Clear separation of concerns - \u2705 Easy to version control separately - \u2705 Shareable across projects - \u2705 Survives Yocto version upgrades - \u2705 Professional project structure</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#12-layer-naming-convention","title":"1.2 Layer Naming Convention","text":"<p>Standard format: <pre><code>meta-&lt;layername&gt;\n</code></pre></p> <p>Examples: - <code>meta-ti</code>: Texas Instruments BSP - <code>meta-openembedded</code>: Community packages - <code>meta-beagleplay</code>: Custom BeaglePlay layer (your project)</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#2-creating-a-new-layer","title":"2. Creating a New Layer","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#21-using-bitbake-layers","title":"2.1 Using bitbake-layers","text":"<p>Navigate to layers directory: <pre><code>cd ~/yocto-labs\nsource poky/oe-init-build-env\ncd ~/yocto-labs\n</code></pre></p> <p>Create layer structure: <pre><code>bitbake-layers create-layer meta-beagleplay\n</code></pre></p> <p>Output: <pre><code>NOTE: Starting bitbake server...\nAdd your new layer with 'bitbake-layers add-layer meta-beagleplay'\n</code></pre></p> <p>Explore structure: <pre><code>cd meta-beagleplay\ntree\n</code></pre></p> <p>Generated structure: <pre><code>meta-beagleplay/\n\u251c\u2500\u2500 conf/\n\u2502   \u2514\u2500\u2500 layer.conf\n\u251c\u2500\u2500 COPYING.MIT\n\u251c\u2500\u2500 README\n\u2514\u2500\u2500 recipes-example/\n    \u2514\u2500\u2500 example/\n        \u2514\u2500\u2500 example_0.1.bb\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#22-configure-layer-metadata","title":"2.2 Configure Layer Metadata","text":"<p>Edit README: <pre><code>nano README\n</code></pre></p> <p>Content: <pre><code># meta-beagleplay\n\nCustom Yocto layer for BeaglePlay development projects.\n\n## Dependencies\n\nThis layer depends on:\n- meta\n- meta-oe\n- meta-ti\n\n## Contributing\n\nMaintained by: Your Name\nContact: your.email@example.com\n</code></pre></p> <p>Edit layer.conf: <pre><code>nano conf/layer.conf\n</code></pre></p> <p>Review generated configuration: <pre><code># We have a conf and classes directory, add to BBPATH\nBBPATH .= \":${LAYERDIR}\"\n\n# We have recipes-* directories, add to BBFILES\nBBFILES += \"${LAYERDIR}/recipes-*/*/*.bb \\\n            ${LAYERDIR}/recipes-*/*/*.bbappend\"\n\nBBFILE_COLLECTIONS += \"meta-beagleplay\"\nBBFILE_PATTERN_meta-beagleplay = \"^${LAYERDIR}/\"\nBBFILE_PRIORITY_meta-beagleplay = \"7\"\n\nLAYERDEPENDS_meta-beagleplay = \"core\"\nLAYERSERIES_COMPAT_meta-beagleplay = \"scarthgap\"\n</code></pre></p> <p>Important variables: - <code>BBFILE_PRIORITY</code>: 7 (higher = higher priority, overrides lower layers) - <code>LAYERSERIES_COMPAT</code>: Must match Yocto release (\"scarthgap\") - <code>LAYERDEPENDS</code>: Declares required layers</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#3-organizing-recipe-directories","title":"3. Organizing Recipe Directories","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#31-standard-directory-structure","title":"3.1 Standard Directory Structure","text":"<p>Create recipe categories: <pre><code>cd ~/yocto-labs/meta-beagleplay\nmkdir -p recipes-core/packagegroups\nmkdir -p recipes-games/ninvaders\nmkdir -p recipes-kernel/linux\nmkdir -p recipes-bsp/u-boot\nmkdir -p recipes-graphics\nmkdir -p recipes-connectivity\n</code></pre></p> <p>Why categorize? - Easier navigation - Clear purpose - Matches upstream conventions - Simplifies layer indexing</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#32-layer-directory-conventions","title":"3.2 Layer Directory Conventions","text":"Directory Purpose Examples <code>recipes-core/</code> System essentials init, base packages <code>recipes-kernel/</code> Kernel and modules linux, kernel modules <code>recipes-bsp/</code> Board support bootloaders, firmware <code>recipes-graphics/</code> GUI applications Wayland, X11 apps <code>recipes-connectivity/</code> Networking WiFi, Bluetooth tools <code>recipes-games/</code> Game applications Your games <code>recipes-extended/</code> Optional packages Development tools"},{"location":"labs/yocto/lab13-yocto-custom-layer/#4-moving-recipes-to-custom-layer","title":"4. Moving Recipes to Custom Layer","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#41-identify-current-recipe-location","title":"4.1 Identify Current Recipe Location","text":"<pre><code>cd ~/yocto-labs/build\nbitbake-layers show-recipes ninvaders\n</code></pre> <p>Output: <pre><code>ninvaders:\n  meta-poky        0.1.1\n</code></pre></p> <p>Recipe is currently in <code>meta-poky</code> (not recommended).</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#42-move-ninvaders-recipe","title":"4.2 Move nInvaders Recipe","text":"<p>Copy recipe to custom layer: <pre><code>cd ~/yocto-labs\ncp -r poky/meta-poky/recipes-extended/ninvaders \\\n     meta-beagleplay/recipes-games/\n</code></pre></p> <p>Remove from meta-poky: <pre><code>rm -rf poky/meta-poky/recipes-extended/ninvaders\n</code></pre></p> <p>Verify new location: <pre><code>cd ~/yocto-labs/build\nbitbake-layers show-recipes ninvaders\n</code></pre></p> <p>Expected error: <pre><code>Nothing PROVIDES 'ninvaders'\n</code></pre></p> <p>Layer not yet integrated!</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#5-integrating-layer-into-build","title":"5. Integrating Layer into Build","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#51-add-layer-to-bblayersconf","title":"5.1 Add Layer to bblayers.conf","text":"<p>Option 1: Manual edit <pre><code>nano conf/bblayers.conf\n</code></pre></p> <p>Add line: <pre><code>BBLAYERS ?= \" \\\n  ... (existing layers) ...\n  /home/user/yocto-labs/meta-beagleplay \\\n\"\n</code></pre></p> <p>Option 2: Use bitbake-layers (recommended) <pre><code>bitbake-layers add-layer ~/yocto-labs/meta-beagleplay\n</code></pre></p> <p>Output: <pre><code>NOTE: Starting bitbake server...\nNOTE: Added layer '/home/user/yocto-labs/meta-beagleplay' to build/conf/bblayers.conf\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#52-verify-layer-integration","title":"5.2 Verify Layer Integration","text":"<pre><code>bitbake-layers show-layers\n</code></pre> <p>Output should include: <pre><code>layer                 path                                      priority\n==================================================================================\n...\nmeta-beagleplay       /home/user/yocto-labs/meta-beagleplay     7\n</code></pre></p> <p>Check recipe now found: <pre><code>bitbake-layers show-recipes ninvaders\n</code></pre></p> <p>Output: <pre><code>ninvaders:\n  meta-beagleplay  0.1.1\n</code></pre></p> <p>\u2705 Success!</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#6-creating-package-groups-in-custom-layer","title":"6. Creating Package Groups in Custom Layer","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#61-create-games-package-group","title":"6.1 Create Games Package Group","text":"<pre><code>cd ~/yocto-labs/meta-beagleplay\nnano recipes-core/packagegroups/packagegroup-beagleplay-games.bb\n</code></pre> <p>Content: <pre><code>SUMMARY = \"BeaglePlay games package group\"\nDESCRIPTION = \"Collection of terminal-based games for BeaglePlay\"\nLICENSE = \"MIT\"\n\ninherit packagegroup\n\nRDEPENDS:${PN} = \" \\\n    ninvaders \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#62-use-package-group-in-image","title":"6.2 Use Package Group in Image","text":"<p>Edit local.conf: <pre><code>cd ~/yocto-labs/build\nnano conf/local.conf\n</code></pre></p> <p>Replace individual package with group: <pre><code># Old:\n# IMAGE_INSTALL:append = \" ninvaders\"\n\n# New:\nIMAGE_INSTALL:append = \" packagegroup-beagleplay-games\"\n</code></pre></p> <p>Rebuild: <pre><code>bitbake core-image-minimal\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#7-layer-dependencies","title":"7. Layer Dependencies","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#71-declare-layer-dependencies","title":"7.1 Declare Layer Dependencies","text":"<p>Edit layer.conf: <pre><code>cd ~/yocto-labs/meta-beagleplay\nnano conf/layer.conf\n</code></pre></p> <p>Add dependencies: <pre><code>LAYERDEPENDS_meta-beagleplay = \" \\\n    core \\\n    openembedded-layer \\\n    meta-ti-bsp \\\n\"\n</code></pre></p> <p>Why declare dependencies? - BitBake validates required layers present - Documents layer requirements - Prevents cryptic build errors</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#72-version-compatibility","title":"7.2 Version Compatibility","text":"<p>Ensure Yocto version compatibility: <pre><code>LAYERSERIES_COMPAT_meta-beagleplay = \"scarthgap\"\n</code></pre></p> <p>For multi-version support: <pre><code>LAYERSERIES_COMPAT_meta-beagleplay = \"kirkstone scarthgap\"\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#8-advanced-layer-management","title":"8. Advanced Layer Management","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#81-check-layer-dependencies","title":"8.1 Check Layer Dependencies","text":"<pre><code>bitbake-layers show-layers\nbitbake-layers check-layers\n</code></pre> <p>Output (if OK): <pre><code>NOTE: All layers are compatible with the current Yocto version\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#82-show-layer-recipes","title":"8.2 Show Layer Recipes","text":"<p>List all recipes in layer: <pre><code>bitbake-layers show-recipes -i meta-beagleplay\n</code></pre></p> <p>Find overlayed recipes: <pre><code>bitbake-layers show-overlayed\n</code></pre></p> <p>Shows recipes provided by multiple layers.</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#83-layer-priority-resolution","title":"8.3 Layer Priority Resolution","text":"<p>When multiple layers provide same recipe: - Higher <code>BBFILE_PRIORITY</code> wins - Same priority = first in <code>BBLAYERS</code> wins</p> <p>Check effective recipe: <pre><code>bitbake-layers show-recipes -b ninvaders\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#9-version-control-for-layers","title":"9. Version Control for Layers","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#91-initialize-git-repository","title":"9.1 Initialize Git Repository","text":"<pre><code>cd ~/yocto-labs/meta-beagleplay\ngit init\ngit add .\ngit commit -m \"Initial commit: meta-beagleplay layer\"\n</code></pre>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#92-create-gitignore","title":"9.2 Create .gitignore","text":"<pre><code>nano .gitignore\n</code></pre> <p>Content: <pre><code># Temporary files\n*.swp\n*.swo\n*~\n\n# Build artifacts (should never be in layer)\ntmp/\nbuild/\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#93-tag-releases","title":"9.3 Tag Releases","text":"<pre><code>git tag -a v1.0 -m \"Release 1.0 - BeaglePlay games support\"\n</code></pre>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#10-layer-distribution","title":"10. Layer Distribution","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#101-create-distribution-script","title":"10.1 Create Distribution Script","text":"<p>For easy layer sharing: <pre><code>cd ~/yocto-labs/meta-beagleplay\nnano setup-layer.sh\n</code></pre></p> <p>Content: <pre><code>#!/bin/bash\nLAYER_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\necho \"Adding meta-beagleplay layer from: $LAYER_DIR\"\nbitbake-layers add-layer \"$LAYER_DIR\"\necho \"Layer added successfully!\"\n</code></pre></p> <pre><code>chmod +x setup-layer.sh\n</code></pre> <p>Usage: <pre><code>source poky/oe-init-build-env\n../meta-beagleplay/setup-layer.sh\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#11-going-further","title":"11. Going Further","text":""},{"location":"labs/yocto/lab13-yocto-custom-layer/#111-submit-to-layer-index","title":"11.1 Submit to Layer Index","text":"<p>Yocto maintains a searchable index: https://layers.openembedded.org/</p> <p>To submit: 1. Host layer on public Git repository (GitHub, GitLab) 2. Submit via web form 3. Maintain layer compatibility</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#112-create-multi-layer-project","title":"11.2 Create Multi-Layer Project","text":"<p>Example structure: <pre><code>yocto-beagleplay/\n\u251c\u2500\u2500 poky/\n\u251c\u2500\u2500 meta-openembedded/\n\u251c\u2500\u2500 meta-ti/\n\u251c\u2500\u2500 meta-beagleplay/         # Board-specific\n\u251c\u2500\u2500 meta-beagleplay-apps/    # Application layer\n\u2514\u2500\u2500 meta-beagleplay-prod/    # Production configuration\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#12-troubleshooting","title":"12. Troubleshooting","text":"<p>Problem: <code>ERROR: Layer 'meta-beagleplay' has incompatible version</code></p> <p>Solution: <pre><code># Update layer.conf\nLAYERSERIES_COMPAT_meta-beagleplay = \"scarthgap\"\n</code></pre></p> <p>Problem: Recipe not found after adding layer</p> <p>Solution: <pre><code># Verify layer path correct\nbitbake-layers show-layers\n\n# Check recipe directory structure\nls -R meta-beagleplay/recipes-*/\n\n# Re-parse recipes\nbitbake -e | grep BBFILES\n</code></pre></p> <p>Problem: Layer priority conflicts</p> <p>Solution: <pre><code># Check priorities\nbitbake-layers show-layers\n\n# Adjust in layer.conf\nBBFILE_PRIORITY_meta-beagleplay = \"10\"  # Higher priority\n</code></pre></p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#13-key-takeaways","title":"13. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Created professional layer structure 2. \u2705 Organized recipes by category 3. \u2705 Moved recipes to custom layer 4. \u2705 Declared layer dependencies 5. \u2705 Integrated layer into build 6. \u2705 Created reusable package groups</p> <p>Best Practices Learned: - Never modify meta/ or meta-poky/ - Use custom layers for all customizations - Version control layers separately - Document layer dependencies - Follow naming conventions</p> <p>Next Steps: - Lab 14: Extend recipes with bbappend - Lab 15: Custom machine configurations - Lab 16: Create custom distribution images</p>"},{"location":"labs/yocto/lab13-yocto-custom-layer/#14-verification-checklist","title":"14. Verification Checklist","text":"<ul> <li>[ ] <code>meta-beagleplay</code> layer created</li> <li>[ ] Layer added to <code>bblayers.conf</code></li> <li>[ ] <code>bitbake-layers show-layers</code> includes meta-beagleplay</li> <li>[ ] ninvaders recipe moved to custom layer</li> <li>[ ] Package group created for games</li> <li>[ ] Layer priority set to 7</li> <li>[ ] Layer dependencies declared</li> <li>[ ] Build succeeds with custom layer</li> <li>[ ] Recipes organized in appropriate directories</li> </ul> <p>Success criteria: Clean layer structure following Yocto conventions</p> <p>End of Lab 13</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>Your recipes are now properly organized in a custom layer, ready for version control, sharing, and long-term maintenance. This professional structure will scale as your project grows.</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/","title":"Lab 14: Extend Recipes with bbappend","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#objectives","title":"Objectives","text":"<p>Master the art of extending existing recipes without modifying the original files, using BitBake append (<code>.bbappend</code>) files for customization.</p> <p>What You'll Learn: - Create <code>.bbappend</code> files - Apply patches to existing recipes - Add custom configuration files - Extend kernel configuration - Add Nunchuk joystick support to Linux kernel - Best practices for recipe extension</p> <p>Time Required: 2-3 hours (or approximately 42 minutes in improbable circumstances)</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 13: Create Custom Yocto Layer</p> <p>Hardware: - Wii Nunchuk controller - mikroBUS connector on BeaglePlay</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#1-understanding-bbappend-files","title":"1. Understanding bbappend Files","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#11-why-bbappend","title":"1.1 Why bbappend?","text":"<p>Problem: You need to modify an existing recipe from another layer.</p> <p>Bad solution: Edit the original recipe - Breaks on layer updates - Merge conflicts - Not maintainable</p> <p>Good solution: Create <code>.bbappend</code> file - \u2705 Original recipe untouched - \u2705 Changes in your layer - \u2705 Survives upstream updates - \u2705 Clear separation of concerns</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#12-bbappend-mechanics","title":"1.2 bbappend Mechanics","text":"<p>Recipe location: <pre><code>meta-ti/recipes-kernel/linux/linux-ti-staging_6.6.bb\n</code></pre></p> <p>Your bbappend: <pre><code>meta-beagleplay/recipes-kernel/linux/linux-ti-staging_6.6.bbappend\n</code></pre></p> <p>Naming rules: - Must match recipe base name - Can use <code>%</code> wildcard for version: <code>linux-ti-staging_%.bbappend</code></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#2-creating-your-first-bbappend","title":"2. Creating Your First bbappend","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#21-extend-kernel-recipe","title":"2.1 Extend Kernel Recipe","text":"<p>Create directory structure: <pre><code>cd ~/yocto-labs/meta-beagleplay\nmkdir -p recipes-kernel/linux\n</code></pre></p> <p>Create bbappend file: <pre><code>nano recipes-kernel/linux/linux-ti-staging_%.bbappend\n</code></pre></p> <p>Minimal bbappend: <pre><code># Extend kernel recipe for BeaglePlay customizations\nFILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"\n</code></pre></p> <p>What this does: - <code>FILESEXTRAPATHS</code>: Adds directory to file search path - <code>:prepend :=</code>: Immediate prepend (evaluated once) - <code>${THISDIR}/files:</code>: Points to <code>files/</code> subdirectory</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#22-verify-bbappend-is-recognized","title":"2.2 Verify bbappend is Recognized","text":"<pre><code>cd ~/yocto-labs/build\nbitbake-layers show-appends\n</code></pre> <p>Expected output: <pre><code>linux-ti-staging_6.6.bb:\n  /home/user/yocto-labs/meta-beagleplay/recipes-kernel/linux/linux-ti-staging_%.bbappend\n</code></pre></p> <p>\u2705 bbappend matched!</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#3-adding-kernel-patches","title":"3. Adding Kernel Patches","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#31-nunchuk-driver-background","title":"3.1 Nunchuk Driver Background","text":"<p>We'll add a custom kernel driver for Wii Nunchuk joystick support.</p> <p>What it does: - Communicates with Nunchuk via I2C - Exposes joystick input device (<code>/dev/input/js0</code>) - Handles button and accelerometer data</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#32-obtain-patch-files","title":"3.2 Obtain Patch Files","text":"<p>Create files directory: <pre><code>cd ~/yocto-labs/meta-beagleplay/recipes-kernel/linux\nmkdir files\n</code></pre></p> <p>Download/create patches (example content):</p> <p>File 1: <code>files/0001-add-nunchuk-driver.patch</code> <pre><code>nano files/0001-add-nunchuk-driver.patch\n</code></pre></p> <p>Content (example structure): <pre><code>From abc123def456... Mon Sep 17 00:00:00 2001\nFrom: Your Name &lt;your.email@example.com&gt;\nDate: Mon, 20 Nov 2024 10:00:00 +0000\nSubject: [PATCH 1/2] Add Wii Nunchuk I2C joystick driver\n\nAdd kernel driver for Nintendo Wii Nunchuk controller\nconnected via I2C bus.\n\nSigned-off-by: Your Name &lt;your.email@example.com&gt;\n---\n drivers/input/joystick/Kconfig     |  10 ++\n drivers/input/joystick/Makefile    |   1 +\n drivers/input/joystick/nunchuk.c   | 250 +++++++++++++++++++++++++++++\n 3 files changed, 261 insertions(+)\n create mode 100644 drivers/input/joystick/nunchuk.c\n\ndiff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig\nindex 123456..789abc 100644\n--- a/drivers/input/joystick/Kconfig\n+++ b/drivers/input/joystick/Kconfig\n@@ -300,4 +300,14 @@ config JOYSTICK_XPAD_LEDS\n      This option enables support for the LED which surrounds the Big X on\n      XBox 360 controller.\n\n+config JOYSTICK_NUNCHUK\n+   tristate \"Nintendo Wii Nunchuk\"\n+   depends on I2C\n+   help\n+     Say Y here if you want to use a Nintendo Wii Nunchuk controller\n+     connected via I2C.\n+\n+     To compile this driver as a module, choose M here: the\n+     module will be called nunchuk.\n+\n endif\ndiff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile\nindex 654321..fedcba 100644\n--- a/drivers/input/joystick/Makefile\n+++ b/drivers/input/joystick/Makefile\n@@ -30,3 +30,4 @@ obj-$(CONFIG_JOYSTICK_WARRIOR)        += warrior.o\n obj-$(CONFIG_JOYSTICK_XPAD)        += xpad.o\n obj-$(CONFIG_JOYSTICK_ZHENHUA)     += zhenhua.o\n obj-$(CONFIG_JOYSTICK_WALKERA0701) += walkera0701.o\n+obj-$(CONFIG_JOYSTICK_NUNCHUK)     += nunchuk.o\ndiff --git a/drivers/input/joystick/nunchuk.c b/drivers/input/joystick/nunchuk.c\nnew file mode 100644\nindex 000000..123456\n--- /dev/null\n+++ b/drivers/input/joystick/nunchuk.c\n@@ -0,0 +1,250 @@\n+// SPDX-License-Identifier: GPL-2.0\n+/*\n+ * Nintendo Wii Nunchuk I2C joystick driver\n+ */\n+\n+#include &lt;linux/module.h&gt;\n+#include &lt;linux/i2c.h&gt;\n+#include &lt;linux/input.h&gt;\n+#include &lt;linux/delay.h&gt;\n+\n+// (Driver implementation code here)\n+// ...\n+\n+MODULE_LICENSE(\"GPL\");\n+MODULE_AUTHOR(\"Your Name\");\n+MODULE_DESCRIPTION(\"Nintendo Wii Nunchuk driver\");\n--\n2.40.1\n</code></pre></p> <p>File 2: <code>files/0002-enable-nunchuk-device-tree.patch</code> <pre><code>nano files/0002-enable-nunchuk-device-tree.patch\n</code></pre></p> <p>Content: <pre><code>From def456abc789... Mon Sep 17 00:00:00 2001\nFrom: Your Name &lt;your.email@example.com&gt;\nDate: Mon, 20 Nov 2024 10:05:00 +0000\nSubject: [PATCH 2/2] ARM64: dts: beagleplay: Add Nunchuk to I2C3\n\nEnable Nunchuk controller on I2C3 bus (mikroBUS connector).\n\nSigned-off-by: Your Name &lt;your.email@example.com&gt;\n---\n arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts b/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts\nindex 123456..789abc 100644\n--- a/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts\n+++ b/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dts\n@@ -400,6 +400,14 @@\n    status = \"okay\";\n    pinctrl-names = \"default\";\n    pinctrl-0 = &lt;&amp;mikrobus_i2c_pins_default&gt;;\n+\n+   nunchuk: joystick@52 {\n+       compatible = \"nintendo,nunchuk\";\n+       reg = &lt;0x52&gt;;\n+       interrupt-parent = &lt;&amp;main_gpio0&gt;;\n+       interrupts = &lt;12 IRQ_TYPE_EDGE_FALLING&gt;;\n+       status = \"okay\";\n+   };\n };\n\n &amp;main_i2c1 {\n--\n2.40.1\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#33-add-patches-to-bbappend","title":"3.3 Add Patches to bbappend","text":"<p>Edit bbappend: <pre><code>nano recipes-kernel/linux/linux-ti-staging_%.bbappend\n</code></pre></p> <p>Add patches: <pre><code>FILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"\n\nSRC_URI:append = \" \\\n    file://0001-add-nunchuk-driver.patch \\\n    file://0002-enable-nunchuk-device-tree.patch \\\n\"\n</code></pre></p> <p>Explanation: - <code>SRC_URI:append</code>: Adds files to source list - BitBake automatically applies <code>.patch</code> files - Patches applied in <code>do_patch</code> task - Order matters - patches applied sequentially</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#4-adding-kernel-configuration","title":"4. Adding Kernel Configuration","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#41-create-defconfig-fragment","title":"4.1 Create defconfig Fragment","text":"<p>Enable Nunchuk driver: <pre><code>nano files/nunchuk.cfg\n</code></pre></p> <p>Content: <pre><code>CONFIG_JOYSTICK_NUNCHUK=y\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_INPUT_EVDEV=y\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#42-add-defconfig-to-bbappend","title":"4.2 Add defconfig to bbappend","text":"<p>Update bbappend: <pre><code>FILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"\n\nSRC_URI:append = \" \\\n    file://0001-add-nunchuk-driver.patch \\\n    file://0002-enable-nunchuk-device-tree.patch \\\n    file://nunchuk.cfg \\\n\"\n</code></pre></p> <p>Kernel recipe automatically merges <code>.cfg</code> files via <code>kernel-yocto</code> class.</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#5-building-modified-kernel","title":"5. Building Modified Kernel","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#51-clean-and-rebuild","title":"5.1 Clean and Rebuild","text":"<pre><code>cd ~/yocto-labs/build\nbitbake -c cleanall virtual/kernel\nbitbake virtual/kernel\n</code></pre> <p>Build takes ~20-30 minutes (full kernel rebuild).</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#52-verify-patches-applied","title":"5.2 Verify Patches Applied","text":"<p>Check kernel work directory: <pre><code>cd ~/yocto-labs/build/tmp/work/beagleplay-poky-linux/linux-ti-staging/*/git\ngit log --oneline | head -5\n</code></pre></p> <p>Should show: <pre><code>abc123d (HEAD) enable-nunchuk-device-tree\ndef456e add-nunchuk-driver\n...\n</code></pre></p> <p>Check driver exists: <pre><code>ls drivers/input/joystick/nunchuk.c\n# Should exist\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#53-verify-configuration","title":"5.3 Verify Configuration","text":"<p>Check kernel config: <pre><code>cd ~/yocto-labs/build/tmp/work/beagleplay-poky-linux/linux-ti-staging/*/\ncat .config | grep NUNCHUK\n</code></pre></p> <p>Output: <pre><code>CONFIG_JOYSTICK_NUNCHUK=y\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#6-deploy-and-test","title":"6. Deploy and Test","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#61-rebuild-image","title":"6.1 Rebuild Image","text":"<pre><code>bitbake core-image-minimal\n</code></pre>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#62-deploy-to-nfs","title":"6.2 Deploy to NFS","text":"<pre><code>cd ~/yocto-labs/build/tmp/deploy/images/beagleplay\nsudo rm -rf /nfs/beagleplay/*\nsudo tar -xf core-image-minimal-beagleplay.rootfs.tar.xz -C /nfs/beagleplay\nsudo chown -R root:root /nfs/beagleplay\n\n# Copy new kernel to SD card boot partition (or TFTP)\nsudo mount /dev/sdb1 /mnt\nsudo cp Image /mnt/\nsudo cp k3-am625-beagleplay.dtb /mnt/\nsudo umount /mnt\n</code></pre>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#63-connect-nunchuk-hardware","title":"6.3 Connect Nunchuk Hardware","text":"<p>mikroBUS I2C3 pins on BeaglePlay: - Pin 11: SDA (I2C3 data) - Pin 12: SCL (I2C3 clock) - Pin 7: 3.3V (power) - Pin 10: GND (ground)</p> <p>Nunchuk pinout (UEXT connector): <pre><code>   1  2  3  4  5  6  7  8  9 10\n  \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n  \u25023V\u2502  \u2502  \u2502  \u2502  \u2502  \u2502GN\u2502SC\u2502SD\u2502  \u2502\n  \u25023V\u2502  \u2502  \u2502  \u2502  \u2502  \u2502D \u2502L \u2502A \u2502  \u2502\n  \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n</code></pre></p> <p>Connections: - Nunchuk 3V3 \u2192 mikroBUS Pin 7 - Nunchuk GND \u2192 mikroBUS Pin 10 - Nunchuk SCL \u2192 mikroBUS Pin 12 - Nunchuk SDA \u2192 mikroBUS Pin 11</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#64-boot-and-verify","title":"6.4 Boot and Verify","text":"<p>Boot BeaglePlay, check kernel log: <pre><code>dmesg | grep -i nunchuk\n</code></pre></p> <p>Expected: <pre><code>[    2.345678] nunchuk 3-0052: Nintendo Wii Nunchuk detected\n[    2.456789] input: Nintendo Wii Nunchuk as /devices/platform/.../input/input0\n</code></pre></p> <p>Check device node: <pre><code>ls -l /dev/input/js0\n# Output: crw-rw---- 1 root input 13, 0 Nov 20 10:00 /dev/input/js0\n</code></pre></p> <p>Test input events: <pre><code>cat /dev/input/js0\n# Move joystick, press buttons - should see binary data\n</code></pre></p> <p>Use evtest (if installed): <pre><code>evtest /dev/input/js0\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#7-advanced-bbappend-techniques","title":"7. Advanced bbappend Techniques","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#71-conditional-append","title":"7.1 Conditional Append","text":"<p>Machine-specific patches: <pre><code>SRC_URI:append:beagleplay = \" file://beagleplay-only.patch\"\nSRC_URI:append:qemux86-64 = \" file://qemu-only.patch\"\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#72-override-variables","title":"7.2 Override Variables","text":"<p>Change kernel version: <pre><code>PV = \"6.6.32\"\nSRCREV = \"abc123def456...\"\n</code></pre></p> <p>Add extra compiler flags: <pre><code>EXTRA_OEMAKE:append = \" CONFIG_DEBUG_INFO=y\"\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#73-extend-tasks","title":"7.3 Extend Tasks","text":"<p>Add post-install steps: <pre><code>do_install:append() {\n    install -m 0644 ${S}/extra-file ${D}/boot/\n}\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#74-remove-files-from-src_uri","title":"7.4 Remove Files from SRC_URI","text":"<p>Remove unwanted patches: <pre><code>SRC_URI:remove = \"file://unwanted-patch.patch\"\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#8-best-practices","title":"8. Best Practices","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#81-patch-naming","title":"8.1 Patch Naming","text":"<p>Convention: <pre><code>0001-short-description.patch\n0002-another-change.patch\n</code></pre></p> <p>Numbering ensures order.</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#82-patch-creation","title":"8.2 Patch Creation","text":"<p>Generate from Git: <pre><code>cd linux-source/\ngit format-patch -1 HEAD\n# Outputs: 0001-commit-message.patch\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#83-config-fragment-organization","title":"8.3 Config Fragment Organization","text":"<p>Separate by feature: <pre><code>files/\n\u251c\u2500\u2500 nunchuk.cfg       # Nunchuk driver config\n\u251c\u2500\u2500 debug.cfg         # Debug options\n\u251c\u2500\u2500 usb.cfg           # USB gadget features\n</code></pre></p> <p>Combine in bbappend: <pre><code>SRC_URI:append = \" \\\n    file://nunchuk.cfg \\\n    file://debug.cfg \\\n    file://usb.cfg \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#9-troubleshooting","title":"9. Troubleshooting","text":"<p>Problem: Patch fails to apply</p> <p>Solution: <pre><code># Check patch context\ncat files/0001-patch.patch\n\n# Manually apply to check\ncd tmp/work/.../linux-ti-staging/.../git\npatch -p1 &lt; /path/to/patch\n\n# If fails, regenerate patch against current kernel version\n</code></pre></p> <p>Problem: Configuration not taking effect</p> <p>Solution: <pre><code># Check merged config\nbitbake -c configure virtual/kernel\ncat tmp/work/.../linux-ti-staging/.../.config | grep NUNCHUK\n\n# Force reconfigure\nbitbake -c cleanall virtual/kernel\nbitbake virtual/kernel\n</code></pre></p> <p>Problem: bbappend not matched</p> <p>Solution: <pre><code># Check exact recipe name\nbitbake-layers show-recipes linux-ti-staging\n\n# Use wildcard version\nmv linux-ti-staging_6.6.bbappend linux-ti-staging_%.bbappend\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#10-going-further","title":"10. Going Further","text":""},{"location":"labs/yocto/lab14-yocto-extend-recipe/#101-patch-ninvaders-for-joystick","title":"10.1 Patch ninvaders for Joystick","text":"<p>Add joystick support to ninvaders: <pre><code># In meta-beagleplay/recipes-games/ninvaders/ninvaders_%.bbappend\nFILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"\n\nSRC_URI:append = \" file://0001-add-joystick-support.patch\"\n\nDEPENDS:append = \" linux-input\"\n</code></pre></p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#102-multiple-bbappend-files","title":"10.2 Multiple bbappend Files","text":"<p>You can have multiple appends for same recipe: <pre><code>meta-layer1/recipes-kernel/linux/linux-ti-staging_%.bbappend\nmeta-layer2/recipes-kernel/linux/linux-ti-staging_%.bbappend\n</code></pre></p> <p>Both applied, layer priority determines order.</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#11-key-takeaways","title":"11. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Created bbappend files 2. \u2705 Applied kernel patches 3. \u2705 Added kernel configuration fragments 4. \u2705 Extended Device Tree 5. \u2705 Added Nunchuk driver support 6. \u2705 Tested on hardware</p> <p>Skills Gained: - Non-invasive recipe modification - Patch management - Kernel customization workflow - Hardware driver integration</p> <p>Next Steps: - Lab 15: Custom machine configurations - Lab 16: Create custom distribution images - Lab 17: SDK development workflow</p>"},{"location":"labs/yocto/lab14-yocto-extend-recipe/#12-verification-checklist","title":"12. Verification Checklist","text":"<ul> <li>[ ] bbappend file created and recognized</li> <li>[ ] Patches apply successfully</li> <li>[ ] Kernel config includes Nunchuk driver</li> <li>[ ] Kernel rebuilds without errors</li> <li>[ ] Nunchuk device appears in <code>/dev/input/</code></li> <li>[ ] evtest shows joystick events</li> <li>[ ] No merge conflicts on kernel updates</li> </ul> <p>Success criteria: Functional Nunchuk joystick on BeaglePlay</p> <p>End of Lab 14</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>You now master recipe extension through bbappend files, enabling clean customization of upstream packages without breaking maintainability. This is the foundation of professional Yocto development.</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/","title":"Lab 15: Custom Machine Configuration","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#objectives","title":"Objectives","text":"<p>Create custom machine configurations to define hardware-specific settings, bootloader parameters, and kernel configurations for your target platform.</p> <p>What You'll Learn: - Machine configuration file structure - SoC family includes - Bootloader and kernel provider selection - Device Tree specification - Serial console configuration - Multi-config for R5 bootloader</p> <p>Time Required: 1-2 hours</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 13: Custom Yocto Layer - Lab 14: Recipe Extension</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#1-understanding-machine-configurations","title":"1. Understanding Machine Configurations","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#11-what-is-a-machine","title":"1.1 What is a Machine?","text":"<p>Machine = Hardware platform definition</p> <p>Includes: - CPU architecture - Bootloader settings - Kernel configuration - Device Tree files - Serial console parameters</p> <p>Example machines: - <code>beagleplay</code>: BeaglePlay board - <code>qemux86-64</code>: QEMU x86_64 - <code>raspberrypi4</code>: Raspberry Pi 4</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#12-machine-file-location","title":"1.2 Machine File Location","text":"<p>Standard path: <pre><code>meta-&lt;layer&gt;/conf/machine/&lt;machine-name&gt;.conf\n</code></pre></p> <p>Example: <pre><code>meta-ti/conf/machine/beagleplay.conf\nmeta-beagleplay/conf/machine/beagleplay-custom.conf\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#2-creating-custom-machine","title":"2. Creating Custom Machine","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#21-create-machine-config-file","title":"2.1 Create Machine Config File","text":"<pre><code>cd ~/yocto-labs/meta-beagleplay\nmkdir -p conf/machine\nnano conf/machine/beagleplay-custom.conf\n</code></pre>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#22-basic-machine-structure","title":"2.2 Basic Machine Structure","text":"<pre><code>#@TYPE: Machine\n#@NAME: BeaglePlay Custom\n#@DESCRIPTION: Custom BeaglePlay machine configuration\n\n# Include TI K3 SoC family settings\nrequire conf/machine/include/k3.inc\nrequire conf/machine/include/mc_k3r5.inc\n\n# SoC family\nSOC_FAMILY:append = \":am62xx\"\n\n# Serial console\nSERIAL_CONSOLES = \"115200;ttyS2\"\n\n# Kernel provider\nPREFERRED_PROVIDER_virtual/kernel = \"linux-ti-staging\"\nKERNEL_DEVICETREE = \"ti/k3-am625-beagleplay.dtb\"\n\n# Bootloader provider\nPREFERRED_PROVIDER_virtual/bootloader = \"u-boot-ti-staging\"\nPREFERRED_PROVIDER_u-boot = \"u-boot-ti-staging\"\n\n# U-Boot configuration\nUBOOT_MACHINE = \"am62x_beagleplay_a53_defconfig\"\n\n# TI-specific settings\nTFA_BOARD = \"lite\"\nTFA_K3_SYSTEM_SUSPEND = \"1\"\nOPTEEMACHINE = \"k3-am62x\"\n\n# Boot method (extlinux)\nrequire conf/machine/include/extlinux-bb.inc\n</code></pre>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#23-understanding-each-section","title":"2.3 Understanding Each Section","text":"<p>SoC Family: <pre><code>require conf/machine/include/k3.inc\n</code></pre> Inherits ARM64 TI K3 platform defaults.</p> <p>Serial Console: <pre><code>SERIAL_CONSOLES = \"115200;ttyS2\"\n</code></pre> Format: <code>\"baudrate;device\"</code></p> <p>Kernel: <pre><code>PREFERRED_PROVIDER_virtual/kernel = \"linux-ti-staging\"\nKERNEL_DEVICETREE = \"ti/k3-am625-beagleplay.dtb\"\n</code></pre> Selects TI kernel and Device Tree blob.</p> <p>Bootloader: <pre><code>UBOOT_MACHINE = \"am62x_beagleplay_a53_defconfig\"\n</code></pre> U-Boot defconfig for Cortex-A53.</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#3-r5-multi-config-support","title":"3. R5 Multi-Config Support","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#31-why-r5-configuration","title":"3.1 Why R5 Configuration?","text":"<p>BeaglePlay boot sequence: 1. ROM code loads R5 SPL (tiboot3.bin) 2. R5 SPL loads TF-A + A53 SPL (tispl.bin) 3. A53 SPL loads U-Boot proper (u-boot.img) 4. U-Boot boots Linux kernel</p> <p>R5 is ARM Cortex-R5 (different architecture from A53) \u2192 needs separate machine config.</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#32-create-r5-machine-config","title":"3.2 Create R5 Machine Config","text":"<pre><code>nano conf/machine/beagleplay-custom-k3r5.conf\n</code></pre> <p>Content: <pre><code>#@TYPE: Machine\n#@NAME: BeaglePlay Custom R5\n#@DESCRIPTION: R5 bootloader configuration for BeaglePlay Custom\n\nrequire conf/machine/include/k3r5.inc\n\n# System firmware\nSYSFW_SOC = \"am62x\"\nSYSFW_CONFIG = \"evm\"\nSYSFW_SUFFIX = \"gp\"  # General Purpose (not High Security)\n\n# U-Boot R5 defconfig\nUBOOT_MACHINE = \"am62x_beagleplay_r5_defconfig\"\n</code></pre></p> <p>Naming convention: <code>&lt;machine&gt;-k3r5.conf</code></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#4-using-custom-machine","title":"4. Using Custom Machine","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#41-update-build-configuration","title":"4.1 Update Build Configuration","text":"<pre><code>cd ~/yocto-labs/build\nnano conf/local.conf\n</code></pre> <p>Change MACHINE: <pre><code># Old:\n# MACHINE = \"beagleplay\"\n\n# New:\nMACHINE = \"beagleplay-custom\"\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#42-clean-and-rebuild","title":"4.2 Clean and Rebuild","text":"<pre><code>bitbake -c cleanall core-image-minimal\nbitbake core-image-minimal\n</code></pre> <p>Full rebuild required (different machine).</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#43-verify-output","title":"4.3 Verify Output","text":"<pre><code>ls tmp/deploy/images/beagleplay-custom/\n</code></pre> <p>Should contain: <pre><code>Image-beagleplay-custom.bin\nk3-am625-beagleplay.dtb\ntiboot3.bin\ntispl.bin\nu-boot.img\ncore-image-minimal-beagleplay-custom.rootfs.tar.xz\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#5-advanced-machine-configuration","title":"5. Advanced Machine Configuration","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#51-add-machine-features","title":"5.1 Add Machine Features","text":"<p>Edit machine config: <pre><code># Machine features\nMACHINE_FEATURES = \" \\\n    ext2 \\\n    usbhost \\\n    usbgadget \\\n    ethernet \\\n    wifi \\\n    bluetooth \\\n    alsa \\\n\"\n</code></pre></p> <p>Features control: - Package selection - Kernel modules - Image capabilities</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#52-storage-configuration","title":"5.2 Storage Configuration","text":"<p>SD card / eMMC: <pre><code># WIC image settings\nWKS_FILE = \"beagleplay-custom.wks\"\nIMAGE_FSTYPES = \"tar.xz wic.xz\"\nIMAGE_BOOT_FILES = \" \\\n    Image \\\n    k3-am625-beagleplay.dtb \\\n    tiboot3.bin \\\n    tispl.bin \\\n    u-boot.img \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#53-kernel-configuration","title":"5.3 Kernel Configuration","text":"<p>Default kernel config: <pre><code>KERNEL_DEFCONFIG = \"defconfig\"\nKERNEL_CONFIG_FRAGMENTS = \"beagleplay-custom.cfg\"\n</code></pre></p> <p>Extra kernel modules: <pre><code>KERNEL_MODULE_AUTOLOAD += \"nunchuk\"\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#6-creating-wks-partition-layout","title":"6. Creating WKS Partition Layout","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#61-custom-partition-table","title":"6.1 Custom Partition Table","text":"<p>Create WKS file: <pre><code>mkdir -p ~/yocto-labs/meta-beagleplay/wic\nnano ~/yocto-labs/meta-beagleplay/wic/beagleplay-custom.wks\n</code></pre></p> <p>Content: <pre><code># BeaglePlay Custom partition layout\n\npart /boot --source bootimg-partition --ondisk mmcblk0 --fstype=vfat --label boot --active --align 4096 --size 128M\npart / --source rootfs --ondisk mmcblk0 --fstype=ext4 --label rootfs --align 4096 --size 2G\n</code></pre></p> <p>Explanation: - <code>part /boot</code>: FAT32 boot partition (128MB) - <code>part /</code>: ext4 root filesystem (2GB) - <code>--ondisk mmcblk0</code>: SD card device - <code>--align 4096</code>: 4KB alignment</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#62-reference-in-machine-config","title":"6.2 Reference in Machine Config","text":"<pre><code>WKS_FILE = \"beagleplay-custom.wks\"\nWKS_FILE_DEPENDS = \"virtual/kernel u-boot-ti-staging\"\n</code></pre>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#7-machine-specific-overrides","title":"7. Machine-Specific Overrides","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#71-conditional-variables","title":"7.1 Conditional Variables","text":"<p>Syntax: <pre><code>VARIABLE:&lt;machine&gt; = \"value\"\nVARIABLE:append:&lt;machine&gt; = \" extra\"\n</code></pre></p> <p>Example: <pre><code># Different kernel for custom machine\nPREFERRED_VERSION_linux-ti-staging:beagleplay-custom = \"6.6.%\"\n\n# Extra packages for custom machine\nIMAGE_INSTALL:append:beagleplay-custom = \" custom-app\"\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#72-multi-machine-recipes","title":"7.2 Multi-Machine Recipes","text":"<p>Recipe can check machine: <pre><code>do_install() {\n    if [ \"${MACHINE}\" = \"beagleplay-custom\" ]; then\n        install -m 0644 custom-config ${D}/etc/\n    fi\n}\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#8-testing-custom-machine","title":"8. Testing Custom Machine","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#81-build-verification","title":"8.1 Build Verification","text":"<pre><code>bitbake core-image-minimal\n</code></pre> <p>Check variables: <pre><code>bitbake -e core-image-minimal | grep \"^MACHINE=\"\n# Output: MACHINE=\"beagleplay-custom\"\n\nbitbake -e core-image-minimal | grep \"^SERIAL_CONSOLES=\"\n# Output: SERIAL_CONSOLES=\"115200;ttyS2\"\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#82-flash-and-boot","title":"8.2 Flash and Boot","text":"<pre><code>cd tmp/deploy/images/beagleplay-custom\nxz -dc core-image-minimal-beagleplay-custom.rootfs.wic.xz | \\\n    sudo dd of=/dev/sdb bs=4M status=progress conv=fdatasync\n</code></pre> <p>Boot BeaglePlay from SD card.</p> <p>Verify in boot logs: <pre><code>U-Boot 2023.04 (Nov 20 2024)\nModel: BeagleBoard.org BeaglePlay\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#9-going-further","title":"9. Going Further","text":""},{"location":"labs/yocto/lab15-yocto-custom-machine/#91-machine-include-files","title":"9.1 Machine Include Files","text":"<p>Create reusable includes: <pre><code>nano conf/machine/include/beagleplay-common.inc\n</code></pre></p> <p>Content: <pre><code># Common settings for all BeaglePlay variants\n\nSOC_FAMILY:append = \":am62xx\"\nSERIAL_CONSOLES = \"115200;ttyS2\"\nPREFERRED_PROVIDER_virtual/kernel = \"linux-ti-staging\"\n</code></pre></p> <p>Use in machine configs: <pre><code>require conf/machine/include/beagleplay-common.inc\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#92-multiple-machine-variants","title":"9.2 Multiple Machine Variants","text":"<p>Create family of machines: <pre><code>conf/machine/\n\u251c\u2500\u2500 beagleplay-minimal.conf    # Minimal features\n\u251c\u2500\u2500 beagleplay-dev.conf        # Development tools\n\u251c\u2500\u2500 beagleplay-production.conf # Production config\n</code></pre></p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#10-key-takeaways","title":"10. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Created custom machine configuration 2. \u2705 Configured R5 multi-config support 3. \u2705 Defined custom partition layout 4. \u2705 Built and tested custom machine</p> <p>Skills Gained: - Machine configuration structure - SoC family includes - Multi-architecture support - WKS partition definitions</p> <p>Next Steps: - Lab 16: Create custom distribution images - Lab 17: SDK development workflow</p>"},{"location":"labs/yocto/lab15-yocto-custom-machine/#11-verification-checklist","title":"11. Verification Checklist","text":"<ul> <li>[ ] <code>beagleplay-custom.conf</code> created</li> <li>[ ] R5 config <code>beagleplay-custom-k3r5.conf</code> created</li> <li>[ ] Build succeeds with MACHINE=\"beagleplay-custom\"</li> <li>[ ] Images appear in <code>tmp/deploy/images/beagleplay-custom/</code></li> <li>[ ] SD card boots successfully</li> <li>[ ] Serial console works on ttyS2</li> </ul> <p>End of Lab 15</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>Custom machine configurations enable you to define precise hardware-specific settings, manage multiple board variants, and maintain clean separation between different product configurations.</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/","title":"Lab 16: Create Custom Image","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#objectives","title":"Objectives","text":"<p>Design custom image recipes that define exact package selections, image features, and build requirements for production and development variants.</p> <p>What You'll Learn: - Write custom image recipes - Control package selection - Differentiate production vs. debug images - Manage image features - Control rootfs size - Create custom package groups</p> <p>Time Required: 1-2 hours</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 13-15: Custom layers, machine configs</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#1-understanding-image-recipes","title":"1. Understanding Image Recipes","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#11-image-recipe-purpose","title":"1.1 Image Recipe Purpose","text":"<p>Image recipe defines: - Packages to install - Image features (debug, dev tools) - Rootfs size limits - License compliance - Post-processing tasks</p> <p>Common images: - <code>core-image-minimal</code>: Bare minimum - <code>core-image-base</code>: + networking - <code>core-image-full-cmdline</code>: All CLI tools</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#2-creating-custom-image","title":"2. Creating Custom Image","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#21-basic-image-recipe","title":"2.1 Basic Image Recipe","text":"<pre><code>cd ~/yocto-labs/meta-beagleplay\nmkdir -p recipes-images\nnano recipes-images/beagleplay-image-minimal.bb\n</code></pre> <p>Content: <pre><code>SUMMARY = \"Minimal BeaglePlay image\"\nDESCRIPTION = \"Production-ready minimal image for BeaglePlay\"\nLICENSE = \"MIT\"\n\n# Inherit core image class\ninherit core-image\n\n# Core packages\nIMAGE_INSTALL = \" \\\n    packagegroup-core-boot \\\n    packagegroup-core-ssh-dropbear \\\n    ${CORE_IMAGE_EXTRA_INSTALL} \\\n\"\n\n# Add custom packages\nIMAGE_INSTALL += \" \\\n    packagegroup-beagleplay-games \\\n    i2c-tools \\\n    can-utils \\\n\"\n\n# Image features\nIMAGE_FEATURES += \" \\\n    ssh-server-dropbear \\\n    package-management \\\n\"\n\n# Rootfs size limit (MB)\nIMAGE_ROOTFS_SIZE ?= \"512000\"\nIMAGE_ROOTFS_EXTRA_SPACE = \"10000\"\n</code></pre></p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#22-build-custom-image","title":"2.2 Build Custom Image","text":"<pre><code>cd ~/yocto-labs/build\nbitbake beagleplay-image-minimal\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#3-production-vs-debug-images","title":"3. Production vs. Debug Images","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#31-create-debug-image","title":"3.1 Create Debug Image","text":"<pre><code>nano ~/yocto-labs/meta-beagleplay/recipes-images/beagleplay-image-debug.bb\n</code></pre> <p>Content: <pre><code>SUMMARY = \"Debug BeaglePlay image\"\nDESCRIPTION = \"Development image with debugging tools\"\nLICENSE = \"MIT\"\n\n# Inherit production image\nrequire beagleplay-image-minimal.bb\n\n# Override description\nDESCRIPTION = \"Development image with debugging tools for BeaglePlay\"\n\n# Add debug features\nIMAGE_FEATURES += \" \\\n    tools-debug \\\n    tools-sdk \\\n    dbg-pkgs \\\n    dev-pkgs \\\n\"\n\n# Extra debug packages\nIMAGE_INSTALL += \" \\\n    gdb \\\n    gdbserver \\\n    strace \\\n    ltrace \\\n    perf \\\n    htop \\\n    vim \\\n\"\n\n# Allow larger rootfs for debug\nIMAGE_ROOTFS_SIZE = \"1024000\"\n</code></pre></p> <p>Benefits: - Code reuse via <code>require</code> - Clear differentiation - Same base, different tools</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#4-custom-package-groups","title":"4. Custom Package Groups","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#41-create-development-tools-group","title":"4.1 Create Development Tools Group","text":"<pre><code>nano ~/yocto-labs/meta-beagleplay/recipes-core/packagegroups/packagegroup-beagleplay-dev.bb\n</code></pre> <p>Content: <pre><code>SUMMARY = \"BeaglePlay development tools\"\nDESCRIPTION = \"Development and debugging utilities\"\nLICENSE = \"MIT\"\n\ninherit packagegroup\n\nRDEPENDS:${PN} = \" \\\n    gdbserver \\\n    strace \\\n    ltrace \\\n    i2c-tools \\\n    can-utils \\\n    mtd-utils \\\n    evtest \\\n    lsof \\\n    tree \\\n    nano \\\n\"\n</code></pre></p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#42-use-in-debug-image","title":"4.2 Use in Debug Image","text":"<pre><code>IMAGE_INSTALL += \" packagegroup-beagleplay-dev\"\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#5-image-features","title":"5. Image Features","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#51-common-features","title":"5.1 Common Features","text":"<pre><code>IMAGE_FEATURES += \" \\\n    ssh-server-dropbear \\  # SSH server\n    package-management \\   # opkg on target\n    debug-tweaks \\         # Root login, no password\n    tools-debug \\          # gdb, strace\n    tools-sdk \\            # Compiler on target\n    dbg-pkgs \\             # Debug symbols\n    dev-pkgs \\             # Headers\n    read-only-rootfs \\     # Immutable rootfs\n\"\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#52-security-vs-development","title":"5.2 Security vs. Development","text":"<p>Production: <pre><code># NO debug-tweaks (requires password)\n# NO tools-sdk (no compiler)\n# read-only-rootfs\nIMAGE_FEATURES = \"ssh-server-dropbear\"\n</code></pre></p> <p>Development: <pre><code># debug-tweaks (easy login)\n# tools-sdk (on-target compilation)\nIMAGE_FEATURES = \"debug-tweaks tools-sdk\"\n</code></pre></p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#6-rootfs-size-management","title":"6. Rootfs Size Management","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#61-size-configuration","title":"6.1 Size Configuration","text":"<pre><code># Base size (KB)\nIMAGE_ROOTFS_SIZE = \"512000\"  # 500MB\n\n# Extra space (KB)\nIMAGE_ROOTFS_EXTRA_SPACE = \"10000\"  # 10MB\n\n# Overhead factor\nIMAGE_OVERHEAD_FACTOR = \"1.3\"  # 30% overhead\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#62-handle-size-errors","title":"6.2 Handle Size Errors","text":"<p>Error: <pre><code>ERROR: Function do_rootfs failed: Image size exceeds IMAGE_ROOTFS_SIZE\n</code></pre></p> <p>Solutions: <pre><code># Increase size\nIMAGE_ROOTFS_SIZE = \"1024000\"\n\n# Or remove limit\nIMAGE_ROOTFS_SIZE = \"\"\n</code></pre></p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#7-license-manifest","title":"7. License Manifest","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#71-enable-license-tracking","title":"7.1 Enable License Tracking","text":"<pre><code># In image recipe\nCOPY_LIC_MANIFEST = \"1\"\nCOPY_LIC_DIRS = \"1\"\nLICENSE_CREATE_PACKAGE = \"1\"\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#72-view-licenses","title":"7.2 View Licenses","text":"<p>After build: <pre><code>ls tmp/deploy/licenses/beagleplay-image-minimal*/\n</code></pre></p> <p>Contains license files for all packages.</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#8-post-install-customization","title":"8. Post-Install Customization","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#81-add-custom-files","title":"8.1 Add Custom Files","text":"<pre><code>do_rootfs:append() {\n    # Create custom motd\n    echo \"Welcome to BeaglePlay!\" &gt; ${IMAGE_ROOTFS}/etc/motd\n\n    # Add startup script\n    install -d ${IMAGE_ROOTFS}/etc/init.d\n    install -m 0755 ${THISDIR}/files/custom-init.sh \\\n        ${IMAGE_ROOTFS}/etc/init.d/\n}\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#82-set-root-password","title":"8.2 Set Root Password","text":"<pre><code># Inherit extrausers class\ninherit extrausers\n\n# Set root password (hashed)\nEXTRA_USERS_PARAMS = \"usermod -P 'mypassword' root;\"\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#9-building-and-testing","title":"9. Building and Testing","text":""},{"location":"labs/yocto/lab16-yocto-custom-image/#91-build-both-images","title":"9.1 Build Both Images","text":"<pre><code>bitbake beagleplay-image-minimal\nbitbake beagleplay-image-debug\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#92-compare-sizes","title":"9.2 Compare Sizes","text":"<pre><code>cd tmp/deploy/images/beagleplay-custom\nls -lh *-image-*.rootfs.tar.xz\n\n# Minimal: ~50MB\n# Debug: ~200MB\n</code></pre>"},{"location":"labs/yocto/lab16-yocto-custom-image/#93-deploy-and-test","title":"9.3 Deploy and Test","text":"<p>Minimal: <pre><code>xz -dc beagleplay-image-minimal-*.wic.xz | \\\n    sudo dd of=/dev/sdb bs=4M\n</code></pre></p> <p>Debug: <pre><code>xz -dc beagleplay-image-debug-*.wic.xz | \\\n    sudo dd of=/dev/sdb bs=4M\n</code></pre></p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#10-key-takeaways","title":"10. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Created custom production image 2. \u2705 Created debug image variant 3. \u2705 Managed package groups 4. \u2705 Controlled image features 5. \u2705 Configured rootfs size</p> <p>Skills Gained: - Image recipe structure - Production vs. debug differentiation - Package group organization - License compliance</p>"},{"location":"labs/yocto/lab16-yocto-custom-image/#11-verification-checklist","title":"11. Verification Checklist","text":"<ul> <li>[ ] <code>beagleplay-image-minimal.bb</code> builds successfully</li> <li>[ ] <code>beagleplay-image-debug.bb</code> builds successfully</li> <li>[ ] Debug image includes gdb, strace</li> <li>[ ] Production image excludes debug tools</li> <li>[ ] Both images boot on BeaglePlay</li> <li>[ ] License manifest generated</li> </ul> <p>End of Lab 16</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>You can now create purpose-built images tailored to specific use cases, balancing functionality, security, and size requirements.</p>"},{"location":"labs/yocto/lab17-yocto-app-development/","title":"Lab 17: Application Development with SDK","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/yocto/lab17-yocto-app-development/#objectives","title":"Objectives","text":"<p>Generate and use the Yocto SDK for efficient cross-compilation and application development without full Yocto builds.</p> <p>What You'll Learn: - Build Yocto SDK - Install and configure SDK - Cross-compile applications - Use SDK sysroot - Debug with SDK toolchain - Integrate applications back into Yocto</p> <p>Time Required: 1-2 hours</p>"},{"location":"labs/yocto/lab17-yocto-app-development/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 16: Custom Image Creation</p>"},{"location":"labs/yocto/lab17-yocto-app-development/#1-understanding-the-sdk","title":"1. Understanding the SDK","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#11-what-is-the-sdk","title":"1.1 What is the SDK?","text":"<p>SDK (Software Development Kit) provides: - Cross-compiler toolchain - Libraries and headers (sysroot) - Development tools (gdb, qemu) - Environment setup script</p> <p>Two SDK types: 1. Standard SDK: Toolchain only 2. Extended SDK: + BitBake and devtool</p> <p>We'll use the extended SDK.</p>"},{"location":"labs/yocto/lab17-yocto-app-development/#2-building-the-sdk","title":"2. Building the SDK","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#21-generate-sdk","title":"2.1 Generate SDK","text":"<pre><code>cd ~/yocto-labs/build\nbitbake beagleplay-image-minimal -c populate_sdk\n</code></pre> <p>Build time: ~20-30 minutes</p>"},{"location":"labs/yocto/lab17-yocto-app-development/#22-locate-sdk-installer","title":"2.2 Locate SDK Installer","text":"<pre><code>ls tmp/deploy/sdk/\n</code></pre> <p>Output: <pre><code>poky-glibc-x86_64-beagleplay-image-minimal-cortexa53-beagleplay-custom-toolchain-5.0.4.sh\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#3-installing-the-sdk","title":"3. Installing the SDK","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#31-run-installer","title":"3.1 Run Installer","text":"<pre><code>cd ~/yocto-labs/build/tmp/deploy/sdk\n./poky-glibc-x86_64-beagleplay-image-minimal-cortexa53-beagleplay-custom-toolchain-5.0.4.sh\n</code></pre> <p>Prompts: <pre><code>Enter target directory for SDK (default: /opt/poky/5.0.4):\n/home/user/yocto-sdk\n\nExtracting SDK...\nSetting it up...\nSDK has been successfully set up and is ready to be used.\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#32-sdk-structure","title":"3.2 SDK Structure","text":"<pre><code>ls ~/yocto-sdk/\n</code></pre> <p>Output: <pre><code>environment-setup-cortexa53-poky-linux   # Setup script\nsysroots/                                 # Target and host sysroots\nsite-config-cortexa53-poky-linux\nversion-cortexa53-poky-linux\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#4-using-the-sdk","title":"4. Using the SDK","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#41-source-environment","title":"4.1 Source Environment","text":"<p>Open new terminal (clean environment): <pre><code>source ~/yocto-sdk/environment-setup-cortexa53-poky-linux\n</code></pre></p> <p>Verify: <pre><code>echo $CC\n# Output: aarch64-poky-linux-gcc ...\n\necho $SDKTARGETSYSROOT\n# Output: /home/user/yocto-sdk/sysroots/cortexa53-poky-linux\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#42-cross-compile-test-program","title":"4.2 Cross-Compile Test Program","text":"<pre><code>cat &gt; hello.c &lt;&lt; 'EOF'\n#include &lt;stdio.h&gt;\nint main() {\n    printf(\"Hello from BeaglePlay SDK!\\n\");\n    return 0;\n}\nEOF\n\n$CC hello.c -o hello\n</code></pre> <p>Verify architecture: <pre><code>file hello\n# Output: hello: ELF 64-bit LSB executable, ARM aarch64, ...\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#43-transfer-to-target","title":"4.3 Transfer to Target","text":"<pre><code>scp hello root@192.168.0.100:/tmp/\nssh root@192.168.0.100 /tmp/hello\n</code></pre> <p>Output: <pre><code>Hello from BeaglePlay SDK!\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#5-compiling-real-applications","title":"5. Compiling Real Applications","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#51-download-ctris-game","title":"5.1 Download Ctris Game","text":"<pre><code>wget https://download.mobatek.net/sources/ctris-0.42-1-src.tar.bz2\ntar -xf ctris-0.42-1-src.tar.bz2\ntar -xf ctris-0.42.tar.bz2\ncd ctris-0.42\n</code></pre>"},{"location":"labs/yocto/lab17-yocto-app-development/#52-fix-makefile","title":"5.2 Fix Makefile","text":"<p>Edit Makefile: <pre><code>nano Makefile\n</code></pre></p> <p>Delete lines that override CC: <pre><code># Remove or comment these:\n# CC = gcc\n# CXX = g++\n</code></pre></p> <p>Add compatibility flags: <pre><code>CFLAGS += -Wno-error=format-security -fcommon\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#53-cross-compile","title":"5.3 Cross-Compile","text":"<pre><code>make\n</code></pre> <p>Verify: <pre><code>file ctris\n# ELF 64-bit ARM aarch64\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#54-deploy-and-test","title":"5.4 Deploy and Test","text":"<pre><code>scp ctris root@192.168.0.100:/usr/bin/\nssh root@192.168.0.100\nctris\n# Play Tetris!\n</code></pre>"},{"location":"labs/yocto/lab17-yocto-app-development/#6-debugging-with-sdk","title":"6. Debugging with SDK","text":""},{"location":"labs/yocto/lab17-yocto-app-development/#61-compile-with-debug-symbols","title":"6.1 Compile with Debug Symbols","text":"<pre><code>$CC -g hello.c -o hello-dbg\n</code></pre>"},{"location":"labs/yocto/lab17-yocto-app-development/#62-remote-debugging","title":"6.2 Remote Debugging","text":"<p>On BeaglePlay: <pre><code>gdbserver :2345 /tmp/hello-dbg\n</code></pre></p> <p>On host: <pre><code>$GDB hello-dbg\n(gdb) target remote 192.168.0.100:2345\n(gdb) break main\n(gdb) continue\n</code></pre></p>"},{"location":"labs/yocto/lab17-yocto-app-development/#7-key-takeaways","title":"7. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Built and installed Yocto SDK 2. \u2705 Cross-compiled applications 3. \u2705 Debugged with gdbserver 4. \u2705 Deployed to target</p> <p>Skills Gained: - SDK generation and installation - Cross-compilation workflow - Remote debugging techniques</p> <p>End of Lab 17</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>The SDK enables rapid application development without rebuilding entire Yocto images, dramatically improving iteration speed.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/","title":"Lab 18: Using devtool","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#dont-panic","title":"DON'T PANIC","text":"<p>The Hitchhiker's Guide to Embedded Linux has this to say about debugging:</p> <p>\"Debugging is the art of figuring out why your code doesn't work, as opposed to why you thought it would work. This is similar to the difference between what Deep Thought calculated (42) and what everyone expected (a useful answer). Both are technically correct, but only one is helpful.\"</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#objectives","title":"Objectives","text":"<p>Master devtool for streamlined recipe development, modification, and upgrades with automated workflow management.</p> <p>What You'll Learn: - Use devtool for recipe creation - Modify recipes in workspace - Generate patches automatically - Upgrade recipes to new versions - Deploy changes to target - Finalize recipes in layers</p> <p>Time Required: 1-2 hours</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#prerequisites","title":"Prerequisites","text":"<p>Completed Labs: - Lab 13-17: Custom layers, recipes, SDK</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#1-understanding-devtool","title":"1. Understanding devtool","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#11-what-is-devtool","title":"1.1 What is devtool?","text":"<p>devtool automates: - Recipe creation from upstream sources - Source code modification with patch generation - Recipe upgrades to new versions - Deploy to target for testing - Integration back into layers</p> <p>Workspace concept: - Temporary layer for development - Isolated from main layers - Easy to finalize or discard</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#2-creating-recipes-with-devtool","title":"2. Creating Recipes with devtool","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#21-add-new-recipe","title":"2.1 Add New Recipe","text":"<pre><code>cd ~/yocto-labs/build\nsource ~/yocto-labs/poky/oe-init-build-env\n\ndevtool add --version 2.10 https://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz\n</code></pre> <p>Output: <pre><code>INFO: Creating workspace layer in .../build/workspace\nINFO: Recipe .../workspace/recipes/hello/hello_2.10.bb has been created\n</code></pre></p>"},{"location":"labs/yocto/lab18-yocto-devtool/#22-explore-workspace","title":"2.2 Explore Workspace","text":"<pre><code>tree workspace/ | head -20\n</code></pre> <p>Structure: <pre><code>workspace/\n\u251c\u2500\u2500 appends/\n\u2502   \u2514\u2500\u2500 hello_2.10.bbappend\n\u251c\u2500\u2500 conf/\n\u2502   \u2514\u2500\u2500 layer.conf\n\u251c\u2500\u2500 recipes/\n\u2502   \u2514\u2500\u2500 hello/\n\u2502       \u2514\u2500\u2500 hello_2.10.bb\n\u2514\u2500\u2500 sources/\n    \u2514\u2500\u2500 hello/\n        \u251c\u2500\u2500 configure\n        \u251c\u2500\u2500 Makefile.in\n        \u2514\u2500\u2500 src/hello.c\n</code></pre></p> <p>Key points: - <code>recipes/</code>: Generated recipe - <code>sources/</code>: Editable source code - <code>appends/</code>: Workspace-specific overrides</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#3-building-with-devtool","title":"3. Building with devtool","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#31-build-recipe","title":"3.1 Build Recipe","text":"<pre><code>devtool build hello\n</code></pre> <p>Sources from workspace, not downloads.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#32-deploy-to-target","title":"3.2 Deploy to Target","text":"<pre><code>devtool deploy-target hello root@192.168.0.100\n</code></pre> <p>Installs directly on target over SSH.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#33-test-on-target","title":"3.3 Test on Target","text":"<pre><code>ssh root@192.168.0.100\nhello\n# Output: Hello, world!\n</code></pre>"},{"location":"labs/yocto/lab18-yocto-devtool/#4-modifying-recipes","title":"4. Modifying Recipes","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#41-edit-source-code","title":"4.1 Edit Source Code","text":"<pre><code>cd workspace/sources/hello\nnano src/hello.c\n</code></pre> <p>Change: <pre><code>printf (\"Hello from BeaglePlay!\\n\");\n</code></pre></p>"},{"location":"labs/yocto/lab18-yocto-devtool/#42-rebuild-and-deploy","title":"4.2 Rebuild and Deploy","text":"<pre><code>devtool build hello\ndevtool deploy-target hello root@192.168.0.100\n</code></pre> <p>Test: <pre><code>ssh root@192.168.0.100 hello\n# Output: Hello from BeaglePlay!\n</code></pre></p>"},{"location":"labs/yocto/lab18-yocto-devtool/#43-generate-patches","title":"4.3 Generate Patches","text":"<p>Commit changes: <pre><code>cd workspace/sources/hello\ngit add src/hello.c\ngit commit -m \"Customize hello message for BeaglePlay\"\n</code></pre></p> <p>Update recipe with patches: <pre><code>devtool update-recipe hello\n</code></pre></p> <p>Patches automatically added to recipe!</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#5-upgrading-recipes","title":"5. Upgrading Recipes","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#51-upgrade-to-new-version","title":"5.1 Upgrade to New Version","text":"<pre><code>devtool upgrade hello --version 2.12\n</code></pre> <p>devtool: - Downloads new version - Updates recipe - Applies existing patches (if compatible) - Reports conflicts</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#52-handle-upgrade-issues","title":"5.2 Handle Upgrade Issues","text":"<p>If patches fail: <pre><code>cd workspace/sources/hello\n# Manually fix conflicts\ngit add .\ngit commit\n</code></pre></p> <p>Update recipe: <pre><code>devtool update-recipe hello\n</code></pre></p>"},{"location":"labs/yocto/lab18-yocto-devtool/#6-finalizing-recipes","title":"6. Finalizing Recipes","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#61-move-to-layer","title":"6.1 Move to Layer","text":"<pre><code>devtool finish hello ~/yocto-labs/meta-beagleplay\n</code></pre> <p>Recipe moved to: <pre><code>meta-beagleplay/recipes-hello/hello/hello_2.10.bb\n</code></pre></p> <p>Workspace cleaned up.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#62-build-from-layer","title":"6.2 Build from Layer","text":"<pre><code>bitbake hello\n</code></pre> <p>Now builds from meta-beagleplay, not workspace.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#7-advanced-devtool","title":"7. Advanced devtool","text":""},{"location":"labs/yocto/lab18-yocto-devtool/#71-edit-existing-recipe","title":"7.1 Edit Existing Recipe","text":"<pre><code>devtool modify ninvaders\n</code></pre> <p>Opens in workspace for editing.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#72-reset-workspace","title":"7.2 Reset Workspace","text":"<pre><code>devtool reset hello\n</code></pre> <p>Removes from workspace, reverts to layer version.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#73-status-overview","title":"7.3 Status Overview","text":"<pre><code>devtool status\n</code></pre> <p>Lists all recipes in workspace.</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#8-key-takeaways","title":"8. Key Takeaways","text":"<p>Accomplished: 1. \u2705 Created recipes with devtool 2. \u2705 Modified source code 3. \u2705 Generated patches automatically 4. \u2705 Upgraded recipes 5. \u2705 Deployed to target for testing 6. \u2705 Finalized recipes in layers</p> <p>Skills Gained: - Automated recipe development - Patch generation workflow - Recipe upgrade process - Rapid iteration with deploy-target</p>"},{"location":"labs/yocto/lab18-yocto-devtool/#9-verification-checklist","title":"9. Verification Checklist","text":"<ul> <li>[ ] devtool add creates recipe</li> <li>[ ] devtool build succeeds</li> <li>[ ] devtool deploy-target installs on BeaglePlay</li> <li>[ ] Source modifications generate patches</li> <li>[ ] devtool finish moves recipe to layer</li> <li>[ ] Recipe builds from layer after finish</li> </ul> <p>End of Lab 18</p> <p>The Guide rates this lab: Mostly Harmless \u2b50\u2b50\u2b50\u2b50</p> <p>devtool revolutionizes recipe development with automated workflows, patch management, and seamless integration, making Yocto development faster and more reliable.</p> <p>End of Yocto Track (Labs 10-18)</p> <p>You've completed a comprehensive journey through the Yocto Project, from basic builds to advanced recipe development, custom layers, and professional SDK workflows. You're now equipped to build production-ready embedded Linux distributions.</p>"},{"location":"methodologies/embedded-linux-development/","title":"Embedded Linux Development Methodology","text":""},{"location":"methodologies/embedded-linux-development/#dont-panic","title":"DON'T PANIC","text":"<p>The Guide has this to say about embedded Linux development:</p> <p>\"Embedded Linux development is the art of taking a perfectly good Linux distribution and cramming it into a device that has less computing power than a 1990s calculator. It's remarkably similar to fitting a whale into a phone booth - technically possible with the right tools, but requires careful planning and a willingness to make compromises.\"</p>"},{"location":"methodologies/embedded-linux-development/#overview","title":"Overview","text":"<p>This methodology defines the structured approach to embedded Linux development, from hardware bring-up to application deployment. Based on the BeaglePlay training curriculum and industry best practices.</p>"},{"location":"methodologies/embedded-linux-development/#development-workflow","title":"Development Workflow","text":""},{"location":"methodologies/embedded-linux-development/#phase-1-environment-setup","title":"Phase 1: Environment Setup","text":"<p>Objective: Establish development infrastructure</p> <p>Steps: 1. Host System Preparation    - Ubuntu 24.04 LTS recommended    - Install essential build tools    - Configure cross-compilation toolchain    - Set up serial console access</p> <ol> <li>Target Hardware Setup</li> <li>BeaglePlay board configuration</li> <li>Serial console connectivity</li> <li>Network configuration (optional)</li> <li>Storage preparation (microSD)</li> </ol> <p>Success Criteria: - \u2705 Cross-compiler installed and verified - \u2705 Serial console access working - \u2705 Hello World compiles for target architecture - \u2705 QEMU user-mode emulation functional</p> <p>Estimated Time: 1-2 hours</p>"},{"location":"methodologies/embedded-linux-development/#phase-2-toolchain-mastery","title":"Phase 2: Toolchain Mastery","text":"<p>Objective: Build and customize cross-compilation toolchain</p> <p>Approaches:</p>"},{"location":"methodologies/embedded-linux-development/#a-pre-built-toolchain-quick-start","title":"A. Pre-built Toolchain (Quick Start)","text":"<p><pre><code>sudo apt install gcc-aarch64-linux-gnu\n</code></pre> Pros: Fast, maintained, well-tested Cons: Less control, may not match target exactly</p>"},{"location":"methodologies/embedded-linux-development/#b-crosstool-ng-recommended","title":"B. Crosstool-NG (Recommended)","text":"<p><pre><code>git clone https://github.com/crosstool-ng/crosstool-ng\ncd crosstool-ng\n./bootstrap &amp;&amp; ./configure --enable-local\nmake\n./ct-ng list-samples\n./ct-ng aarch64-unknown-linux-gnu\n./ct-ng menuconfig\n./ct-ng build\n</code></pre> Pros: Full control, customizable, reproducible Cons: Longer build time, more complex</p>"},{"location":"methodologies/embedded-linux-development/#c-buildrootyocto-advanced","title":"C. Buildroot/Yocto (Advanced)","text":"<p>Generates toolchain as part of full system build.</p> <p>Best Practice: Start with pre-built, graduate to Crosstool-NG for production.</p>"},{"location":"methodologies/embedded-linux-development/#phase-3-bootloader-development","title":"Phase 3: Bootloader Development","text":"<p>Objective: Customize U-Boot for target platform</p> <p>Key Concepts: - SPL (Secondary Program Loader): First-stage bootloader - U-Boot Proper: Second-stage bootloader - Device Tree: Hardware description - Environment: Boot configuration</p> <p>Workflow: <pre><code># 1. Clone U-Boot\ngit clone https://source.denx.de/u-boot/u-boot.git\ncd u-boot\n\n# 2. Configure for BeaglePlay\nmake CROSS_COMPILE=aarch64-linux-gnu- am62x_evm_a53_defconfig\n\n# 3. Customize (optional)\nmake CROSS_COMPILE=aarch64-linux-gnu- menuconfig\n\n# 4. Build\nmake CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc)\n\n# 5. Deploy to SD card\n# See lab03-bootloader for details\n</code></pre></p> <p>Testing Strategy: 1. Verify boot via serial console 2. Check environment variables 3. Test network boot (TFTP) 4. Validate device tree loading</p>"},{"location":"methodologies/embedded-linux-development/#phase-4-kernel-development","title":"Phase 4: Kernel Development","text":"<p>Objective: Build custom Linux kernel for target</p> <p>Configuration Philosophy: - Minimal: Only essential drivers (faster boot, smaller size) - Modular: Drivers as modules (flexible, larger size) - Balanced: Common built-in, others modular (recommended)</p> <p>Workflow: <pre><code># 1. Get kernel source\ngit clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git\ncd linux\n\n# 2. Start with defconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig\n\n# 3. Customize for BeaglePlay\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig\n# Enable: TI AM62x support, device drivers, filesystems\n\n# 4. Build\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image modules dtbs -j$(nproc)\n\n# 5. Install modules (to rootfs staging area)\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- \\\n     INSTALL_MOD_PATH=/path/to/rootfs modules_install\n</code></pre></p> <p>Device Tree Modifications: <pre><code>// Custom DTS overlay for application-specific hardware\n/dts-v1/;\n/plugin/;\n\n/ {\n    compatible = \"ti,am625-sk\";\n\n    fragment@0 {\n        target = &lt;&amp;main_i2c0&gt;;\n        __overlay__ {\n            custom_sensor@48 {\n                compatible = \"vendor,sensor\";\n                reg = &lt;0x48&gt;;\n            };\n        };\n    };\n};\n</code></pre></p>"},{"location":"methodologies/embedded-linux-development/#phase-5-root-filesystem-construction","title":"Phase 5: Root Filesystem Construction","text":"<p>Objective: Create minimal yet functional root filesystem</p> <p>Approaches:</p>"},{"location":"methodologies/embedded-linux-development/#a-busybox-minimal-recommended-for-learning","title":"A. BusyBox (Minimal - Recommended for Learning)","text":"<pre><code># 1. Build BusyBox\ngit clone https://git.busybox.net/busybox\ncd busybox\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig\n# Enable: Static binary\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- install\n\n# 2. Create rootfs structure\nmkdir -p rootfs/{bin,sbin,etc,proc,sys,dev,lib,usr,tmp,home,root}\n\n# 3. Copy BusyBox\ncp -a _install/* rootfs/\n\n# 4. Add essential files\ncat &gt; rootfs/etc/inittab &lt;&lt; 'EOF'\n::sysinit:/etc/init.d/rcS\n::respawn:/sbin/getty -L console 0 vt100\n::shutdown:/bin/umount -a -r\nEOF\n\n# 5. Create init script\ncat &gt; rootfs/etc/init.d/rcS &lt;&lt; 'EOF'\n#!/bin/sh\nmount -t proc none /proc\nmount -t sysfs none /sys\nmount -t devtmpfs none /dev\nEOF\nchmod +x rootfs/etc/init.d/rcS\n</code></pre>"},{"location":"methodologies/embedded-linux-development/#b-buildroot-automated","title":"B. Buildroot (Automated)","text":"<pre><code>make beagleplay_defconfig\nmake menuconfig  # Customize packages\nmake -j$(nproc)\n# Output: output/images/rootfs.tar\n</code></pre>"},{"location":"methodologies/embedded-linux-development/#c-yoctoopenembedded-production","title":"C. Yocto/OpenEmbedded (Production)","text":"<p>Full-featured distribution with package management.</p> <p>Directory Structure: <pre><code>rootfs/\n\u251c\u2500\u2500 bin/           # Essential binaries\n\u251c\u2500\u2500 sbin/          # System binaries\n\u251c\u2500\u2500 lib/           # Shared libraries\n\u251c\u2500\u2500 usr/\n\u2502   \u251c\u2500\u2500 bin/       # User binaries\n\u2502   \u251c\u2500\u2500 sbin/      # Non-essential system binaries\n\u2502   \u2514\u2500\u2500 lib/       # User libraries\n\u251c\u2500\u2500 etc/           # Configuration files\n\u251c\u2500\u2500 dev/           # Device files\n\u251c\u2500\u2500 proc/          # Process information (mount point)\n\u251c\u2500\u2500 sys/           # Sysfs (mount point)\n\u251c\u2500\u2500 tmp/           # Temporary files\n\u251c\u2500\u2500 home/          # User home directories\n\u2514\u2500\u2500 root/          # Root user home\n</code></pre></p>"},{"location":"methodologies/embedded-linux-development/#phase-6-application-development","title":"Phase 6: Application Development","text":"<p>Objective: Develop and debug applications for target</p> <p>Cross-Development Workflow:</p> <ol> <li> <p>Write Code (on host) <pre><code>// example.c\n#include &lt;stdio.h&gt;\nint main(void) {\n    printf(\"Running on BeaglePlay!\\n\");\n    return 0;\n}\n</code></pre></p> </li> <li> <p>Cross-Compile (on host) <pre><code>aarch64-linux-gnu-gcc -o example example.c\n</code></pre></p> </li> <li> <p>Deploy (to target) <pre><code>scp example debian@beagleplay.local:~/\n</code></pre></p> </li> <li> <p>Debug (on target or remote) <pre><code># On target\ngdb ./example\n\n# Remote debugging\ngdbserver :2345 ./example  # On target\naarch64-linux-gnu-gdb      # On host\n(gdb) target remote beagleplay.local:2345\n</code></pre></p> </li> </ol> <p>Debugging Tools: - gdb: Interactive debugging - gdbserver: Remote debugging - strace: System call tracing - ltrace: Library call tracing - valgrind: Memory debugging - perf: Performance profiling</p>"},{"location":"methodologies/embedded-linux-development/#build-system-integration","title":"Build System Integration","text":""},{"location":"methodologies/embedded-linux-development/#buildroot-integration","title":"Buildroot Integration","text":"<p>Philosophy: Automated, reproducible builds</p> <p>Workflow: <pre><code># 1. Configure\nmake menuconfig\n  # Target options \u2192 aarch64\n  # Toolchain \u2192 External toolchain\n  # System \u2192 Custom scripts\n  # Filesystem images \u2192 tar\n\n# 2. Add custom packages\nmkdir -p package/myapp\ncat &gt; package/myapp/Config.in\ncat &gt; package/myapp/myapp.mk\n\n# 3. Build\nmake -j$(nproc)\n\n# 4. Output\nls output/images/\n</code></pre></p>"},{"location":"methodologies/embedded-linux-development/#yocto-integration","title":"Yocto Integration","text":"<p>Philosophy: Layer-based, scalable, industry-standard</p> <p>Workflow: <pre><code># 1. Setup\ngit clone git://git.yoctoproject.org/poky\ncd poky\nsource oe-init-build-env\n\n# 2. Configure (conf/local.conf)\nMACHINE = \"beagleplay\"\n\n# 3. Add custom layer\nbitbake-layers create-layer meta-custom\nbitbake-layers add-layer meta-custom\n\n# 4. Create recipe\n# meta-custom/recipes-apps/myapp/myapp_1.0.bb\n\n# 5. Build\nbitbake core-image-minimal\n</code></pre></p>"},{"location":"methodologies/embedded-linux-development/#testing-methodology","title":"Testing Methodology","text":""},{"location":"methodologies/embedded-linux-development/#unit-testing","title":"Unit Testing","text":"<p>On Host (with QEMU): <pre><code># Compile for ARM64\naarch64-linux-gnu-gcc -o test_suite tests/*.c\n\n# Run with QEMU\nqemu-aarch64 -L /usr/aarch64-linux-gnu ./test_suite\n</code></pre></p>"},{"location":"methodologies/embedded-linux-development/#integration-testing","title":"Integration Testing","text":"<p>On Target: <pre><code># Automated test script\n#!/bin/sh\necho \"Running integration tests...\"\n./test_hardware\n./test_peripherals\n./test_network\necho \"All tests passed!\"\n</code></pre></p>"},{"location":"methodologies/embedded-linux-development/#performance-testing","title":"Performance Testing","text":"<pre><code># Boot time\nsystemd-analyze\n\n# Application performance\nperf stat ./application\n\n# Memory usage\nvalgrind --tool=massif ./application\n</code></pre>"},{"location":"methodologies/embedded-linux-development/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"methodologies/embedded-linux-development/#development-deployment","title":"Development Deployment","text":"<p>NFS Root: - Fast iteration - No reflashing needed - Easy debugging</p> <pre><code># On host (NFS server)\nsudo exportfs -o rw,no_root_squash beagleplay:/srv/nfs/rootfs\n\n# U-Boot bootargs\nsetenv bootargs root=/dev/nfs nfsroot=192.168.1.100:/srv/nfs/rootfs ip=dhcp\n</code></pre> <p>TFTP + NFS: - Network boot kernel - NFS root filesystem - Ideal for development</p>"},{"location":"methodologies/embedded-linux-development/#production-deployment","title":"Production Deployment","text":"<p>SD Card: <pre><code># Partition\nsudo fdisk /dev/sdX\n# p1: boot (FAT32, 128MB)\n# p2: rootfs (ext4, remaining)\n\n# Format\nsudo mkfs.vfat -F 32 -n boot /dev/sdX1\nsudo mkfs.ext4 -L rootfs /dev/sdX2\n\n# Install\nsudo cp -a boot/* /media/boot/\nsudo cp -a rootfs/* /media/rootfs/\n</code></pre></p> <p>eMMC Flash: - Faster than SD - More reliable - Requires flashing utility</p>"},{"location":"methodologies/embedded-linux-development/#best-practices","title":"Best Practices","text":""},{"location":"methodologies/embedded-linux-development/#code-organization","title":"Code Organization","text":"<pre><code>project/\n\u251c\u2500\u2500 src/              # Application source\n\u251c\u2500\u2500 include/          # Headers\n\u251c\u2500\u2500 scripts/          # Build/deploy scripts\n\u251c\u2500\u2500 configs/          # Kernel/buildroot configs\n\u251c\u2500\u2500 patches/          # Custom patches\n\u2514\u2500\u2500 docs/             # Project documentation\n</code></pre>"},{"location":"methodologies/embedded-linux-development/#version-control","title":"Version Control","text":"<pre><code># Track configurations\ngit add configs/kernel.config\ngit add configs/buildroot.config\ngit commit -m \"feat: Add custom kernel configuration\"\n\n# Tag releases\ngit tag -a v1.0.0 -m \"Release 1.0.0\"\n</code></pre>"},{"location":"methodologies/embedded-linux-development/#documentation","title":"Documentation","text":"<p>Maintain: - Build instructions - Hardware setup guide - Troubleshooting notes - Known issues - Changelog</p>"},{"location":"methodologies/embedded-linux-development/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"methodologies/embedded-linux-development/#1-endianness-mismatch","title":"1. Endianness Mismatch","text":"<p>Problem: Code works on x86 but fails on ARM Solution: Use endian-safe code, test on target</p>"},{"location":"methodologies/embedded-linux-development/#2-library-path-issues","title":"2. Library Path Issues","text":"<p>Problem: Application can't find libraries Solution: Check <code>LD_LIBRARY_PATH</code>, use <code>ldd</code> to verify</p>"},{"location":"methodologies/embedded-linux-development/#3-device-tree-errors","title":"3. Device Tree Errors","text":"<p>Problem: Peripherals not detected Solution: Verify device tree, check kernel logs (<code>dmesg</code>)</p>"},{"location":"methodologies/embedded-linux-development/#4-cross-compilation-flags","title":"4. Cross-Compilation Flags","text":"<p>Problem: Binary won't run on target Solution: Verify <code>CROSS_COMPILE</code> and <code>ARCH</code> are set correctly</p>"},{"location":"methodologies/embedded-linux-development/#5-kernel-module-dependencies","title":"5. Kernel Module Dependencies","text":"<p>Problem: Module won't load Solution: Check <code>modprobe</code>, verify kernel version match</p>"},{"location":"methodologies/embedded-linux-development/#performance-optimization","title":"Performance Optimization","text":""},{"location":"methodologies/embedded-linux-development/#boot-time","title":"Boot Time","text":"<ol> <li>Kernel: Disable unused drivers</li> <li>Init: Minimize services</li> <li>Filesystem: Use compressed filesystem</li> <li>Async: Parallelize initialization</li> </ol>"},{"location":"methodologies/embedded-linux-development/#runtime-performance","title":"Runtime Performance","text":"<ol> <li>Compiler Flags: <code>-O2</code>, <code>-march=native</code></li> <li>Profiling: Use <code>perf</code> to identify hotspots</li> <li>Caching: Leverage CPU cache effectively</li> <li>Algorithms: Choose appropriate data structures</li> </ol>"},{"location":"methodologies/embedded-linux-development/#security-considerations","title":"Security Considerations","text":""},{"location":"methodologies/embedded-linux-development/#minimal-attack-surface","title":"Minimal Attack Surface","text":"<ul> <li>Remove unnecessary services</li> <li>Disable unused ports</li> <li>Minimal package installation</li> </ul>"},{"location":"methodologies/embedded-linux-development/#updates","title":"Updates","text":"<ul> <li>Secure boot (optional)</li> <li>Signed images</li> <li>OTA update mechanism</li> </ul>"},{"location":"methodologies/embedded-linux-development/#hardening","title":"Hardening","text":"<ul> <li>SELinux/AppArmor</li> <li>Firewall rules</li> <li>User permissions</li> </ul>"},{"location":"methodologies/embedded-linux-development/#references","title":"References","text":"<ul> <li>Yocto Project Documentation</li> <li>Buildroot Manual</li> <li>U-Boot Documentation</li> <li>Linux Kernel Documentation</li> </ul> <p>Remember: The answer to \"How long does a kernel build take?\" is 42 minutes... or longer if you forgot to enable ccache.</p> <p>Part of the Hitchhiker's Guide to Developing</p>"},{"location":"methodologies/linux-debugging/","title":"Linux Debugging Methodology","text":""},{"location":"methodologies/linux-debugging/#dont-panic","title":"DON'T PANIC","text":"<p>The Guide has this to say about debugging:</p> <p>\"Debugging is the art of determining why your code doesn't do what you thought you told it to do. It's a bit like being a detective, except the crime scene is a memory dump, the suspects are all pointers, and the smoking gun is usually a missing semicolon three files away from where the actual problem manifests.\"</p>"},{"location":"methodologies/linux-debugging/#overview","title":"Overview","text":"<p>This methodology provides a systematic approach to debugging Linux systems and applications, from user-space programs to kernel-level issues.</p>"},{"location":"methodologies/linux-debugging/#the-debugging-mindset","title":"The Debugging Mindset","text":""},{"location":"methodologies/linux-debugging/#core-principles","title":"Core Principles","text":"<ol> <li>Reproduce First: If you can't reproduce it, you can't fix it</li> <li>Isolate the Problem: Binary search through complexity</li> <li>Understand Before Changing: Random changes rarely fix issues</li> <li>One Change at a Time: Multiple changes obscure causation</li> <li>Document Everything: Future you will thank present you</li> </ol>"},{"location":"methodologies/linux-debugging/#the-guides-debugging-hierarchy","title":"The Guide's Debugging Hierarchy","text":"<pre><code>Level 1: Print Debugging    \u2190 \"Is it plugged in?\"\nLevel 2: Interactive GDB    \u2190 \"Let's talk to the code\"\nLevel 3: System Tracing     \u2190 \"What is the system actually doing?\"\nLevel 4: Performance Tools  \u2190 \"Why is it slow?\"\nLevel 5: Kernel Debugging   \u2190 \"The Matrix has you...\"\n</code></pre>"},{"location":"methodologies/linux-debugging/#user-space-debugging","title":"User-Space Debugging","text":""},{"location":"methodologies/linux-debugging/#level-1-printf-debugging","title":"Level 1: Printf Debugging","text":"<p>When to use: Initial investigation, quick checks</p> <p>Technique: <pre><code>printf(\"DEBUG: Entering function foo(), value=%d\\n\", value);\nprintf(\"DEBUG: After malloc, ptr=%p\\n\", ptr);\nprintf(\"DEBUG: Before critical section\\n\");\n</code></pre></p> <p>Best Practices: - Prefix with <code>DEBUG:</code> for easy filtering - Include variable values - Add timestamps for timing issues - Use conditional compilation for production</p> <pre><code>#ifdef DEBUG\n#define DBG_PRINT(fmt, ...) \\\n    printf(\"[DEBUG %s:%d] \" fmt \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__)\n#else\n#define DBG_PRINT(fmt, ...)\n#endif\n</code></pre>"},{"location":"methodologies/linux-debugging/#level-2-gdb-gnu-debugger","title":"Level 2: GDB (GNU Debugger)","text":"<p>When to use: Crashes, segfaults, logic errors</p>"},{"location":"methodologies/linux-debugging/#basic-workflow","title":"Basic Workflow","text":"<pre><code># Compile with debug symbols\ngcc -g -o myapp myapp.c\n\n# Run in GDB\ngdb ./myapp\n\n# GDB commands\n(gdb) run                    # Start program\n(gdb) break main             # Set breakpoint\n(gdb) break myfile.c:42      # Break at line\n(gdb) continue               # Continue execution\n(gdb) next                   # Step over\n(gdb) step                   # Step into\n(gdb) print variable         # Show value\n(gdb) backtrace             # Call stack\n(gdb) info locals           # Local variables\n</code></pre>"},{"location":"methodologies/linux-debugging/#advanced-techniques","title":"Advanced Techniques","text":"<p>Conditional Breakpoints: <pre><code>break myfunction if count &gt; 100\n</code></pre></p> <p>Watchpoints (break when variable changes): <pre><code>watch my_variable\n</code></pre></p> <p>Catchpoints (break on events): <pre><code>catch throw              # C++ exception\ncatch syscall open       # System call\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#remote-debugging-cross-development","title":"Remote Debugging (Cross-Development)","text":"<p>On target (BeaglePlay): <pre><code>gdbserver :2345 ./myapp\n</code></pre></p> <p>On host: <pre><code>aarch64-linux-gnu-gdb ./myapp\n(gdb) target remote beagleplay.local:2345\n(gdb) continue\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-3-core-dumps","title":"Level 3: Core Dumps","text":"<p>Enable core dumps: <pre><code>ulimit -c unlimited\n</code></pre></p> <p>Analyze crash: <pre><code>gdb ./myapp core\n(gdb) backtrace\n(gdb) info registers\n(gdb) disassemble\n</code></pre></p> <p>Automated core dump analysis: <pre><code># Set core pattern\necho \"/var/crash/core.%e.%p\" | sudo tee /proc/sys/kernel/core_pattern\n\n# Analyze automatically\ngdb -batch -ex \"thread apply all bt\" ./myapp /var/crash/core.myapp.1234\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-4-system-call-tracing","title":"Level 4: System Call Tracing","text":""},{"location":"methodologies/linux-debugging/#strace-system-call-tracer","title":"strace (System Call Tracer)","text":"<p>Basic usage: <pre><code># Trace all system calls\nstrace ./myapp\n\n# Follow forks\nstrace -f ./myapp\n\n# Time each call\nstrace -T ./myapp\n\n# Count calls\nstrace -c ./myapp\n\n# Filter specific calls\nstrace -e open,read,write ./myapp\n\n# Attach to running process\nstrace -p PID\n</code></pre></p> <p>Common patterns: <pre><code># Find missing files\nstrace -e openat ./myapp 2&gt;&amp;1 | grep ENOENT\n\n# Network debugging\nstrace -e socket,connect,send,recv ./myapp\n\n# Performance issues\nstrace -T -e trace=file ./myapp 2&gt;&amp;1 | grep -v \"&lt; 0.00\"\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#ltrace-library-call-tracer","title":"ltrace (Library Call Tracer)","text":"<pre><code># Trace library calls\nltrace ./myapp\n\n# Specific libraries\nltrace -l libmylib.so ./myapp\n</code></pre>"},{"location":"methodologies/linux-debugging/#level-5-memory-debugging","title":"Level 5: Memory Debugging","text":""},{"location":"methodologies/linux-debugging/#valgrind","title":"Valgrind","text":"<p>Memory leak detection: <pre><code>valgrind --leak-check=full --show-leak-kinds=all ./myapp\n</code></pre></p> <p>Use-after-free detection: <pre><code>valgrind --track-origins=yes ./myapp\n</code></pre></p> <p>Cache profiling: <pre><code>valgrind --tool=cachegrind ./myapp\nkcachegrind cachegrind.out.PID\n</code></pre></p> <p>Heap profiling: <pre><code>valgrind --tool=massif ./myapp\nms_print massif.out.PID\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#addresssanitizer-asan","title":"AddressSanitizer (ASan)","text":"<p>Compile with ASan: <pre><code>gcc -fsanitize=address -g -o myapp myapp.c\n./myapp\n</code></pre></p> <p>Detects: - Use-after-free - Heap buffer overflow - Stack buffer overflow - Global buffer overflow - Use-after-return - Memory leaks</p>"},{"location":"methodologies/linux-debugging/#kernel-space-debugging","title":"Kernel-Space Debugging","text":""},{"location":"methodologies/linux-debugging/#level-1-kernel-logs-dmesg","title":"Level 1: Kernel Logs (dmesg)","text":"<pre><code># View all messages\ndmesg\n\n# Follow new messages\ndmesg -w\n\n# Filter by level\ndmesg -l err,warn\n\n# Clear buffer\ndmesg -C\n\n# Show timestamps\ndmesg -T\n</code></pre> <p>Add custom kernel messages: <pre><code>printk(KERN_INFO \"Module loaded\\n\");\nprintk(KERN_DEBUG \"Debug info: value=%d\\n\", value);\npr_info(\"Simpler syntax\\n\");\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-2-dynamic-debug","title":"Level 2: Dynamic Debug","text":"<p>Enable dynamic debug: <pre><code># At boot\necho \"module mymodule +p\" &gt; /sys/kernel/debug/dynamic_debug/control\n\n# Runtime\necho \"file myfile.c +p\" &gt; /sys/kernel/debug/dynamic_debug/control\necho \"func myfunction +p\" &gt; /sys/kernel/debug/dynamic_debug/control\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-3-ftrace-function-tracer","title":"Level 3: ftrace (Function Tracer)","text":"<p>Basic function tracing: <pre><code>cd /sys/kernel/debug/tracing\n\n# Set tracer\necho function &gt; current_tracer\n\n# Enable tracing\necho 1 &gt; tracing_on\n\n# View trace\ncat trace\n\n# Disable\necho 0 &gt; tracing_on\n</code></pre></p> <p>Function graph: <pre><code>echo function_graph &gt; current_tracer\necho 1 &gt; tracing_on\ncat trace\n</code></pre></p> <p>Event tracing: <pre><code># List available events\ncat available_events\n\n# Enable specific event\necho 1 &gt; events/syscalls/sys_enter_open/enable\n\n# Filter\necho 'filename == \"/etc/passwd\"' &gt; events/syscalls/sys_enter_open/filter\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-4-perf-performance-analysis","title":"Level 4: perf (Performance Analysis)","text":"<p>Record system-wide events: <pre><code># Record for 10 seconds\nperf record -a sleep 10\n\n# Analyze\nperf report\n\n# Call graph\nperf record -g -a sleep 10\nperf report -g\n</code></pre></p> <p>CPU sampling: <pre><code># Sample on-CPU functions\nperf record -F 99 -a -g -- sleep 30\nperf report\n</code></pre></p> <p>Hardware events: <pre><code># Cache misses\nperf stat -e cache-misses,cache-references ./myapp\n\n# Branch mispredictions\nperf stat -e branches,branch-misses ./myapp\n</code></pre></p> <p>Flame graphs: <pre><code>perf record -F 99 -a -g -- sleep 30\nperf script | stackcollapse-perf.pl | flamegraph.pl &gt; flame.svg\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-5-kgdb-kernel-gdb","title":"Level 5: KGDB (Kernel GDB)","text":"<p>Setup:</p> <ol> <li> <p>Kernel config: <pre><code>CONFIG_KGDB=y\nCONFIG_KGDB_SERIAL_CONSOLE=y\n</code></pre></p> </li> <li> <p>Boot with: <pre><code>kgdbwait kgdboc=ttyS0,115200\n</code></pre></p> </li> <li> <p>Connect from host: <pre><code>aarch64-linux-gnu-gdb vmlinux\n(gdb) target remote /dev/ttyUSB0\n(gdb) continue\n</code></pre></p> </li> </ol> <p>Debug kernel panic: <pre><code># Trigger KGDB on panic\necho 1 &gt; /proc/sys/kernel/panic_on_oops\n\n# Manually enter KGDB\necho g &gt; /proc/sysrq-trigger\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#level-6-crash-analysis-kdumpkexec","title":"Level 6: Crash Analysis (kdump/kexec)","text":"<p>Setup kdump: <pre><code># Reserve memory\n# Add to kernel cmdline: crashkernel=256M\n\n# Install tools\nsudo apt install kdump-tools\n\n# Configure\nsudo vi /etc/default/kdump-tools\n# USE_KDUMP=1\n\n# Test\necho c &gt; /proc/sysrq-trigger\n</code></pre></p> <p>Analyze crash dump: <pre><code>crash /usr/lib/debug/boot/vmlinux-$(uname -r) /var/crash/dump\ncrash&gt; bt                  # Backtrace\ncrash&gt; ps                  # Process list\ncrash&gt; log                # Kernel log\ncrash&gt; dis                # Disassemble\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#performance-debugging","title":"Performance Debugging","text":""},{"location":"methodologies/linux-debugging/#cpu-profiling","title":"CPU Profiling","text":"<p>Find CPU hogs: <pre><code>top                        # Interactive\nhtop                       # Better interactive\npidstat -p PID 1          # Per-process stats\n</code></pre></p> <p>Profile application: <pre><code>perf record ./myapp\nperf report\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#io-profiling","title":"I/O Profiling","text":"<p>Block I/O: <pre><code>iostat -x 1               # I/O statistics\niotop                     # I/O per process\nblktrace /dev/sda         # Block layer tracing\n</code></pre></p> <p>File I/O: <pre><code>strace -T -e open,read,write,close ./myapp\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#network-profiling","title":"Network Profiling","text":"<p>Connections: <pre><code>ss -tunapl                # All connections\nnetstat -tulpn            # Listening ports\n</code></pre></p> <p>Traffic: <pre><code>tcpdump -i eth0           # Packet capture\niftop                     # Bandwidth per connection\nnethogs                   # Per-process bandwidth\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#debugging-strategies","title":"Debugging Strategies","text":""},{"location":"methodologies/linux-debugging/#the-binary-search-approach","title":"The Binary Search Approach","text":"<ol> <li>Identify working version: <code>git bisect start</code></li> <li>Mark bad commit: <code>git bisect bad</code></li> <li>Mark good commit: <code>git bisect good v1.0</code></li> <li>Test each: Build and test</li> <li>Repeat: <code>git bisect good/bad</code></li> <li>Find culprit: Git identifies exact commit</li> </ol>"},{"location":"methodologies/linux-debugging/#the-rubber-duck-method","title":"The Rubber Duck Method","text":"<p>Explain your code line-by-line to a rubber duck (or colleague). Often reveals the issue through verbalization.</p>"},{"location":"methodologies/linux-debugging/#the-divide-and-conquer","title":"The Divide and Conquer","text":"<ol> <li>Reproduce reliably</li> <li>Minimize test case: Remove unrelated code</li> <li>Binary search: Comment out half, test, repeat</li> <li>Isolate: Find minimal reproducer</li> </ol>"},{"location":"methodologies/linux-debugging/#the-scientific-method","title":"The Scientific Method","text":"<ol> <li>Observe: Gather data</li> <li>Hypothesize: Form theory</li> <li>Predict: What should happen if theory is correct?</li> <li>Test: Does prediction match reality?</li> <li>Repeat: Refine hypothesis</li> </ol>"},{"location":"methodologies/linux-debugging/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":""},{"location":"methodologies/linux-debugging/#segmentation-fault","title":"Segmentation Fault","text":"<p>Diagnosis: <pre><code>gdb ./myapp\n(gdb) run\n# Crash occurs\n(gdb) backtrace\n(gdb) print ptr        # Check pointer values\n</code></pre></p> <p>Common causes: - Null pointer dereference - Use-after-free - Buffer overflow - Stack overflow</p>"},{"location":"methodologies/linux-debugging/#memory-leak","title":"Memory Leak","text":"<p>Detection: <pre><code>valgrind --leak-check=full ./myapp\n</code></pre></p> <p>Fix patterns: <pre><code>// Always pair malloc/free\nptr = malloc(size);\n// ... use ptr ...\nfree(ptr);\nptr = NULL;\n\n// RAII in C++\nstd::unique_ptr&lt;T&gt; ptr(new T);\n// Automatic cleanup\n</code></pre></p>"},{"location":"methodologies/linux-debugging/#race-condition","title":"Race Condition","text":"<p>Detection: <pre><code># Thread sanitizer\ngcc -fsanitize=thread -g -o myapp myapp.c\n./myapp\n\n# Helgrind (Valgrind)\nvalgrind --tool=helgrind ./myapp\n</code></pre></p> <p>Prevention: - Use mutexes for shared data - Minimize shared state - Lock ordering discipline - Consider lock-free algorithms</p>"},{"location":"methodologies/linux-debugging/#deadlock","title":"Deadlock","text":"<p>Detection: <pre><code># GDB: Attach and check threads\ngdb -p PID\n(gdb) info threads\n(gdb) thread apply all bt\n</code></pre></p> <p>Prevention: - Always acquire locks in same order - Use lock hierarchies - Timeout on lock acquisition - Lock-free data structures</p>"},{"location":"methodologies/linux-debugging/#debugging-checklist","title":"Debugging Checklist","text":""},{"location":"methodologies/linux-debugging/#before-you-start","title":"Before You Start","text":"<ul> <li>[ ] Can you reproduce the issue?</li> <li>[ ] Do you have debug symbols? (<code>-g</code>)</li> <li>[ ] Do you have a minimal test case?</li> <li>[ ] Have you checked recent changes?</li> <li>[ ] Have you read the error message carefully?</li> </ul>"},{"location":"methodologies/linux-debugging/#during-debugging","title":"During Debugging","text":"<ul> <li>[ ] One change at a time</li> <li>[ ] Document what you try</li> <li>[ ] Test after each change</li> <li>[ ] Use version control</li> <li>[ ] Take breaks (fresh perspective)</li> </ul>"},{"location":"methodologies/linux-debugging/#after-fixing","title":"After Fixing","text":"<ul> <li>[ ] Understand root cause</li> <li>[ ] Add test to prevent regression</li> <li>[ ] Document in comments/commit message</li> <li>[ ] Consider if similar issues exist elsewhere</li> <li>[ ] Share knowledge with team</li> </ul>"},{"location":"methodologies/linux-debugging/#tools-reference","title":"Tools Reference","text":""},{"location":"methodologies/linux-debugging/#essential-tools","title":"Essential Tools","text":"Tool Purpose Platforms <code>gdb</code> Interactive debugger User/Kernel <code>strace</code> System call trace User <code>ltrace</code> Library call trace User <code>valgrind</code> Memory debugging User <code>perf</code> Performance analysis User/Kernel <code>ftrace</code> Function tracing Kernel <code>dmesg</code> Kernel messages Kernel <code>crash</code> Crash dump analysis Kernel"},{"location":"methodologies/linux-debugging/#compiler-flags","title":"Compiler Flags","text":"<pre><code>-g              # Debug symbols\n-g3             # Extra debug info\n-ggdb           # GDB-specific debug info\n-O0             # No optimization (easier debugging)\n-Wall           # All warnings\n-Wextra         # Extra warnings\n-Werror         # Warnings as errors\n-fsanitize=address     # Address sanitizer\n-fsanitize=thread      # Thread sanitizer\n-fsanitize=undefined   # Undefined behavior sanitizer\n</code></pre>"},{"location":"methodologies/linux-debugging/#advanced-topics","title":"Advanced Topics","text":""},{"location":"methodologies/linux-debugging/#ebpf-debugging","title":"eBPF Debugging","text":"<pre><code># Install bcc-tools\nsudo apt install bpfcc-tools\n\n# Trace syscalls\nsudo trace-bpfcc 'p:syscalls:sys_enter_open'\n\n# Profile stack traces\nsudo profile-bpfcc -F 99 -f 5\n</code></pre>"},{"location":"methodologies/linux-debugging/#kernel-oops-analysis","title":"Kernel Oops Analysis","text":"<pre><code># Example oops\nUnable to handle kernel NULL pointer dereference at virtual address 00000000\nPC is at my_function+0x20/0x60\nLR is at calling_function+0x40/0x80\n</code></pre> <p>Analysis: 1. Note the function (<code>my_function</code>) 2. Check offset (<code>+0x20</code>) 3. Disassemble: <code>objdump -d module.ko</code> 4. Find instruction at offset 5. Check source code</p>"},{"location":"methodologies/linux-debugging/#resources","title":"Resources","text":"<ul> <li>GDB Manual</li> <li>Valgrind Documentation</li> <li>perf Wiki</li> <li>ftrace Documentation</li> <li>Brendan Gregg's Blog</li> </ul> <p>Remember: The answer to \"How long will debugging take?\" is 42 minutes... plus however long it actually takes after that estimate.</p> <p>Part of the Hitchhiker's Guide to Developing</p>"},{"location":"standards/documentation-standards/","title":"Documentation Standards","text":""},{"location":"standards/documentation-standards/#writing-principles","title":"Writing Principles","text":"<p>All documentation in this repository adheres to professional technical writing standards designed for clarity, reproducibility, and educational value.</p>"},{"location":"standards/documentation-standards/#core-principles","title":"Core Principles","text":"<p>Clarity - Use precise technical terminology - Define acronyms on first use - Avoid ambiguous language - Structure information hierarchically</p> <p>Reproducibility - Include all version information - Document environmental dependencies - Provide complete command sequences - Specify expected outputs</p> <p>Accuracy - Verify all procedures before documentation - Include error cases and troubleshooting - Cite authoritative sources - Update documentation with corrections</p> <p>Professionalism - Maintain formal technical tone - Focus on factual information - Avoid colloquialisms and informal language - Use consistent terminology</p>"},{"location":"standards/documentation-standards/#document-structure","title":"Document Structure","text":""},{"location":"standards/documentation-standards/#research-notes","title":"Research Notes","text":"<pre><code># [Topic Title]\n\n**Date**: YYYY-MM-DD\n**Author**: [Name]\n**Status**: [Draft | Review | Final]\n\n## Abstract\n\nBrief summary of the research topic and findings.\n\n## Background\n\nContext and prerequisite knowledge.\n\n## Objectives\n\nClear statement of research goals.\n\n## Procedure\n\nStep-by-step methodology.\n\n## Results\n\nEmpirical observations and data.\n\n## Analysis\n\nInterpretation of results.\n\n## Conclusions\n\nKey findings and implications.\n\n## References\n\nCited sources in standard format.\n</code></pre>"},{"location":"standards/documentation-standards/#technical-procedures","title":"Technical Procedures","text":"<pre><code># [Procedure Title]\n\n## Overview\n\nBrief description of the procedure purpose.\n\n## Prerequisites\n\n- Required hardware\n- Software versions\n- Prior knowledge\n\n## Environment\n\n- Operating system: [name and version]\n- Toolchain: [version]\n- Target platform: [specifications]\n\n## Steps\n\n1. First action\n   - Sub-steps if needed\n   - Expected output\n\n2. Second action\n   ```bash\n   command with options\n   ```\n\n## Verification\n\nHow to confirm successful completion.\n\n## Troubleshooting\n\nCommon issues and solutions.\n\n## References\n\nRelated documentation and sources.\n</code></pre>"},{"location":"standards/documentation-standards/#experiment-reports","title":"Experiment Reports","text":"<pre><code># [Experiment Title]\n\n**Date**: YYYY-MM-DD\n**Hypothesis**: [Statement]\n**Platform**: [Hardware/software]\n\n## Setup\n\nDetailed configuration.\n\n## Methodology\n\nExperimental procedure.\n\n## Data\n\n| Metric | Value | Unit |\n|--------|-------|------|\n| ...    | ...   | ...  |\n\n## Analysis\n\nStatistical or qualitative analysis.\n\n## Conclusions\n\nFindings and implications.\n</code></pre>"},{"location":"standards/documentation-standards/#formatting-standards","title":"Formatting Standards","text":""},{"location":"standards/documentation-standards/#headings","title":"Headings","text":"<ul> <li>Use ATX-style headers (<code>#</code> syntax)</li> <li>One H1 per document (title)</li> <li>Hierarchical structure (no skipped levels)</li> <li>Blank lines before and after headings</li> </ul>"},{"location":"standards/documentation-standards/#code-blocks","title":"Code Blocks","text":"<ul> <li>Always specify language for syntax highlighting</li> <li>Include context (file paths, environment)</li> <li>Comment complex operations</li> <li>Show expected output when relevant</li> </ul>"},{"location":"standards/documentation-standards/#lists","title":"Lists","text":"<ul> <li>Blank lines before and after lists</li> <li>Consistent bullet style within document</li> <li>Ordered lists for sequential steps</li> <li>Unordered lists for non-sequential items</li> </ul>"},{"location":"standards/documentation-standards/#tables","title":"Tables","text":"<ul> <li>Use for structured data</li> <li>Include headers</li> <li>Align columns consistently</li> <li>Keep readable in plain text</li> </ul>"},{"location":"standards/documentation-standards/#links","title":"Links","text":"<ul> <li>Descriptive link text (not \"click here\")</li> <li>Prefer relative paths for internal links</li> <li>Include URL modification dates for external resources</li> <li>Verify links periodically</li> </ul>"},{"location":"standards/documentation-standards/#technical-writing-guidelines","title":"Technical Writing Guidelines","text":""},{"location":"standards/documentation-standards/#command-documentation","title":"Command Documentation","text":"<p>When documenting commands:</p> <pre><code># Always show the full command with context\ncd /path/to/directory\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-\n\n# Include expected output\n# Output:\n#   CC    main.o\n#   LD    program\n</code></pre>"},{"location":"standards/documentation-standards/#version-information","title":"Version Information","text":"<p>Always specify versions:</p> <pre><code>Software: GCC 11.2.0\nKernel: Linux 5.15.0-LTS\nHost: Ubuntu 22.04 LTS\nTarget: ARM Cortex-A53\n</code></pre>"},{"location":"standards/documentation-standards/#error-documentation","title":"Error Documentation","text":"<p>Document errors completely:</p> <pre><code>Error encountered:\n  make: *** No rule to make target 'install'. Stop.\n\nCause:\n  Missing installation target in Makefile\n\nSolution:\n  Add install target or use manual installation procedure\n</code></pre>"},{"location":"standards/documentation-standards/#code-documentation","title":"Code Documentation","text":""},{"location":"standards/documentation-standards/#inline-comments","title":"Inline Comments","text":"<pre><code>/* Initialize hardware timer for 1ms tick\n * Clock source: HCLK/8 (9MHz)\n * Prescaler: 9000 for 1kHz\n */\nvoid timer_init(void) {\n    // Register configuration\n    TIM2-&gt;PSC = 8999;  // Prescaler value\n    TIM2-&gt;ARR = 999;   // Auto-reload for 1ms\n}\n</code></pre>"},{"location":"standards/documentation-standards/#function-documentation","title":"Function Documentation","text":"<pre><code>/**\n * @brief Read data from I2C device\n * \n * @param dev_addr Device I2C address (7-bit)\n * @param reg_addr Register address to read\n * @param buffer Pointer to data buffer\n * @param length Number of bytes to read\n * \n * @return 0 on success, negative error code on failure\n * \n * @note This function blocks until transfer completes\n * @warning Buffer must be at least 'length' bytes\n */\nint i2c_read(uint8_t dev_addr, uint8_t reg_addr, \n             uint8_t *buffer, size_t length);\n</code></pre>"},{"location":"standards/documentation-standards/#diagrams-and-visualizations","title":"Diagrams and Visualizations","text":""},{"location":"standards/documentation-standards/#ascii-diagrams","title":"ASCII Diagrams","text":"<p>For simple system diagrams:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Bootloader \u2502 --&gt; \u2502 Linux Kernel \u2502\n\u2502   (U-Boot)  \u2502     \u2502   (zImage)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                    \u2502\n       v                    v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Device Tree \u2502     \u2502 Root FS      \u2502\n\u2502   (.dtb)    \u2502     \u2502 (initramfs)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"standards/documentation-standards/#mermaid-diagrams","title":"Mermaid Diagrams","text":"<p>For complex flows, use Mermaid:</p> <pre><code>graph TD\n    A[Source Code] --&gt; B[Preprocessor]\n    B --&gt; C[Compiler]\n    C --&gt; D[Assembler]\n    D --&gt; E[Object Files]\n    E --&gt; F[Linker]\n    F --&gt; G[Executable]\n</code></pre>"},{"location":"standards/documentation-standards/#file-naming","title":"File Naming","text":""},{"location":"standards/documentation-standards/#documentation-files","title":"Documentation Files","text":"<ul> <li>Use lowercase with hyphens: <code>cross-compilation-guide.md</code></li> <li>Descriptive names: <code>beagleplay-uart-configuration.md</code></li> <li>Date prefix for logs: <code>2025-11-23-build-log.md</code></li> </ul>"},{"location":"standards/documentation-standards/#code-files","title":"Code Files","text":"<ul> <li>Follow language conventions</li> <li>C files: <code>lowercase_with_underscores.c</code></li> <li>Headers: <code>lowercase_with_underscores.h</code></li> <li>Scripts: <code>lowercase-with-hyphens.sh</code></li> </ul>"},{"location":"standards/documentation-standards/#configuration-files","title":"Configuration Files","text":"<ul> <li>Preserve standard names: <code>.config</code>, <code>Makefile</code>, <code>CMakeLists.txt</code></li> <li>Custom configs: descriptive names with extension</li> <li>Example: <code>kernel-5.15-beagleplay.config</code></li> </ul>"},{"location":"standards/documentation-standards/#review-process","title":"Review Process","text":""},{"location":"standards/documentation-standards/#self-review-checklist","title":"Self-Review Checklist","text":"<p>Before committing documentation:</p> <ul> <li>[ ] All commands tested and verified</li> <li>[ ] Version information included</li> <li>[ ] Links checked and valid</li> <li>[ ] Code blocks have language specified</li> <li>[ ] Spelling and grammar checked</li> <li>[ ] Consistent terminology used</li> <li>[ ] References properly cited</li> <li>[ ] Procedures are reproducible</li> </ul>"},{"location":"standards/documentation-standards/#maintenance","title":"Maintenance","text":""},{"location":"standards/documentation-standards/#documentation-updates","title":"Documentation Updates","text":"<ul> <li>Update dates when content changes</li> <li>Track version history in git</li> <li>Mark deprecated content clearly</li> <li>Archive obsolete documentation</li> </ul>"},{"location":"standards/documentation-standards/#periodic-review","title":"Periodic Review","text":"<ul> <li>Quarterly review of all documentation</li> <li>Verify external links</li> <li>Update version information</li> <li>Incorporate feedback and corrections</li> </ul> <p>Document Version: 1.0</p> <p>Last Updated: November 2025</p>"}]}